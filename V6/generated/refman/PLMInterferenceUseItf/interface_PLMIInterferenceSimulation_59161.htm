<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
 <meta http-equiv="Content-Language" content="en-us"> 
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
 <meta name="Generator" content="CppGene v1.1">
 <meta http-equiv="Expires" content="Tue, 04 Dec 1993 21:29:02 GMT">
 <title>PLMInterferenceUseItf Interface PLMIInterferenceSimulation</title>
<link rel="Stylesheet" type="text/css" href="../../../caav5.css">
<link href="../_index/cdg.css" rel="stylesheet" type="text/css"> 
<script type="text/javascript">var PubDirExist = false; var ProDirExist = false; var PrivDirExist = false;</script> 
<script type="text/javascript" src="../_index/cdg.js"></script> 
<script language="Javascript" id="jsLinkjs" type="text/javascript" src="../_index/jslink.js"></script> 
<script language="Javascript" id="jsFwLinkjs" type="text/javascript" src="jsFwLink.js"></script> 
<script language="Javascript" id="jsTreejs" type="text/javascript" src="../_index/jsTree.js"></script>  
</head>
<body>
<div class="menu1" id="menuViewPPP" > 
 	<a href="javascript:writeIndex('IPublic')" name="viewPPP" id="PublicView"  class="ongletPub" > Public View</a> 
 	<a href="javascript:writeIndex('IProtected')" name="viewPPP" id="ProtectedView" class="ongletPro"  > Protected View</a>  
 	<a href="javascript:writeIndex('IPrivate')" name="viewPPP" id="PrivateView" class="ongletPriv" > Private View</a> 
 </div> 
 <div id="indexView" class="menu1">	 
 <a name="multiview" class="onglet" rel="../_index/main.htm" href="../_index/main.htm">All Frameworks</a>   
 <a name="multiview" class="onglet"  rel="../_index/tree.htm" href="../_index/tree.htm">Class Hierarchy</a>   
 <a name="multiview" class="onglet"  rel="../PLMInterferenceUseItf.htm" href="../PLMInterferenceUseItf.htm">This Framework</a>
<a name="multiview" class="onglet"  rel="../_index/HomeIdx.htm" href="../_index/HomeIdx.htm">Indexes</a>  
 <a id="multiviewP" class="onglet" href="javascript:openLinkNP(getCurrentObjectName(),getCurrentType(),'0')"  >Previous</a>  
 	<a id="multiviewN" class="onglet" href="javascript:openLinkNP(getCurrentObjectName(),getCurrentType(),'1')"  >Next</a> 
 </div> 
<script type="text/javascript" > 
 	function getCurrentLevel() { 
 return "";	} 
	function getCurrentFw() { 
	return "PLMInterferenceUseItf";	}
		function getCurrentObjectName() { 
 	return "PLMIInterferenceSimulation"; } 
	function getCurrentType() { 
 	return "interface"; }  
 function callInit() { 
 		if (PubDirExist == true || ProDirExist == true || PrivDirExist == true) {  
 			var parent = document.getElementById("indexView"); 
 			if (parent && (ProDirExist == true || PrivDirExist == true) ) { 
 			var elem = document.getElementById("multiviewP"); 
 			if(elem) parent.removeChild(elem); 
 			elem = document.getElementById("multiviewN"); 
 			if(elem) parent.removeChild(elem); }
 			initData(); 
 		} else { 
 			var elem; 
 			var parent = document.getElementById("menuViewPPP"); 
 			if (parent) { 
 				elem = document.getElementById("PublicView"); 
 				parent.removeChild(elem); 
 				elem = document.getElementById("ProtectedView"); 
 				parent.removeChild(elem); 
 				elem = document.getElementById("PrivateView"); 
 				parent.removeChild(elem); 
 			} 
 if (locateObject(getCurrentObjectName(), getCurrentType(), '0')==0) { 
 				elem = document.getElementById("multiviewP"); 
 				if (elem) { elem.removeAttribute("href"); elem.removeAttribute("onclick"); } 
 			} 
 			if (locateObject(getCurrentObjectName(), getCurrentType(), '1')==0) { 
 				elem = document.getElementById("multiviewN"); 
 				if (elem) { elem.removeAttribute("href"); elem.removeAttribute("onclick"); } 
 			} 
 }	 
 	} 
 	window.onload = callInit; 
  </script> 
 
<h1>PLMInterferenceUseItf Interface PLMIInterferenceSimulation</h1>
<script type="text/javascript" > 
 generatedFatherClass('interface_PLMIInterferenceSimulation_59161','PLMIInterferenceSimulation','0');</script>
<p><b>Usage: an implementation of this interface is supplied and you must use it as is. You should not reimplement it.</b></p>
<hr>
<p>
 interface <b>PLMIInterferenceSimulation</b>
</p>
<p>
<b><i> Interface to manage Interference Simulation.</i></b><br>

 <br> Use method <script type="text/javascript"> activateLinkAnchor('PLMIInterferenceServices','CreateInterferenceSimulation','PLMIInterferenceServices.CreateInterferenceSimulation') </script> to create a new Interference Simulation.
</p>
<hr>
 <h2>Method Index</h2> <br>
<dl>
 <dt> o 
    <a href="#AddComputeQuantifier(PLMIInterferenceSimulation::ComputeQuantifier)"><b>AddComputeQuantifier</b></a>(PLMIInterferenceSimulation::ComputeQuantifier)
<dd>  Adds the computation of a quantifier.
 <dt> o 
    <a href="#AddGroupObjects(PLMIInterferenceGroupObjects*&amp;)"><b>AddGroupObjects</b></a>(PLMIInterferenceGroupObjects*&amp;)
<dd>  Adds a new empty group and return it.
 <dt> o 
    <a href="#AddItfSpecificationTypeEngCnx(PLMIInterferenceSimulation::SpecificationTypeEngCnx)"><b>AddItfSpecificationTypeEngCnx</b></a>(PLMIInterferenceSimulation::SpecificationTypeEngCnx)
<dd>  Adds the type of engineering connection specification to take into account.
 <dt> o 
    <a href="#Execute()"><b>Execute</b></a>()
<dd>  Launches the computation.
 <dt> o 
    <a href="#GetClearanceValue(double&amp;)"><b>GetClearanceValue</b></a>(double&amp;)
<dd>  Returns the clearance value.
 <dt> o 
    <a href="#GetComparison(PLMIInterferenceSimulation::Comparison&amp;)"><b>GetComparison</b></a>(PLMIInterferenceSimulation::Comparison&amp;)
<dd>  Gets the mode of interference comparison.
 <dt> o 
    <a href="#GetGroupComputationType(PLMIInterferenceSimulation::GroupComputationType&amp;)"><b>GetGroupComputationType</b></a>(PLMIInterferenceSimulation::GroupComputationType&amp;)
<dd>  Gets the mode of computation of groups for interference simulation.
 <dt> o 
    <a href="#GetGroupObjects(int,PLMIInterferenceGroupObjects*&amp;)"><b>GetGroupObjects</b></a>(int,PLMIInterferenceGroupObjects*&amp;)
<dd>  Retrieves a Group.
 <dt> o 
    <a href="#GetInterferenceResults(CATListPtrPLMIInterferenceResult&amp;)"><b>GetInterferenceResults</b></a>(CATListPtrPLMIInterferenceResult&amp;)
<dd>  Retrieves the Interference Results.
 <dt> o 
    <a href="#GetIntermediateRepresentation(PLMIInterferenceSimulation::IntermediateRepresentation&amp;)"><b>GetIntermediateRepresentation</b></a>(PLMIInterferenceSimulation::IntermediateRepresentation&amp;)
<dd>  Gets the option for intermediate representation.
 <dt> o 
    <a href="#GetName(CATUnicodeString&amp;)"><b>GetName</b></a>(CATUnicodeString&amp;)
<dd>  Gets the name of the Interference Simulation.
 <dt> o 
    <a href="#GetNumberOfGroupObjects(int&amp;)"><b>GetNumberOfGroupObjects</b></a>(int&amp;)
<dd>  Gets the number of groups of the simulation.
 <dt> o 
    <a href="#GetRuleSetName(CATUnicodeString&amp;)"><b>GetRuleSetName</b></a>(CATUnicodeString&amp;)
<dd>  Gets name of the RuleSet containing the knowledge rules of computation of the interference simulation.
 <dt> o 
    <a href="#GetSpecificationType(PLMIInterferenceSimulation::SpecificationType&amp;)"><b>GetSpecificationType</b></a>(PLMIInterferenceSimulation::SpecificationType&amp;)
<dd>  Gets the Interference Specification Type.
 <dt> o 
    <a href="#IsActiveComputeQuantifier(PLMIInterferenceSimulation::ComputeQuantifier,CATBoolean&amp;)"><b>IsActiveComputeQuantifier</b></a>(PLMIInterferenceSimulation::ComputeQuantifier,CATBoolean&amp;)
<dd>  Checks if the computation of a quantifier is active.
 <dt> o 
    <a href="#IsActiveItfSpecificationTypeEngCnx(PLMIInterferenceSimulation::SpecificationTypeEngCnx,CATBoolean&amp;)"><b>IsActiveItfSpecificationTypeEngCnx</b></a>(PLMIInterferenceSimulation::SpecificationTypeEngCnx,CATBoolean&amp;)
<dd>  Determines if one specific type of engineering connection specification is used.
 <dt> o 
    <a href="#IsComputeQuantifierAvailable(PLMIInterferenceSimulation::ComputeQuantifier,CATBoolean&amp;)"><b>IsComputeQuantifierAvailable</b></a>(PLMIInterferenceSimulation::ComputeQuantifier,CATBoolean&amp;)
<dd>  Checks if the computation of a quantifier is available.
 <dt> o 
    <a href="#RemoveComputeQuantifier(PLMIInterferenceSimulation::ComputeQuantifier)"><b>RemoveComputeQuantifier</b></a>(PLMIInterferenceSimulation::ComputeQuantifier)
<dd>  Removes the computation of a quantifier.
 <dt> o 
    <a href="#RemoveGroupObjects(int)"><b>RemoveGroupObjects</b></a>(int)
<dd>  Removes a Group.
 <dt> o 
    <a href="#RemoveItfSpecificationTypeEngCnx(PLMIInterferenceSimulation::SpecificationTypeEngCnx)"><b>RemoveItfSpecificationTypeEngCnx</b></a>(PLMIInterferenceSimulation::SpecificationTypeEngCnx)
<dd>  Removes one type of engineering connection specification.
 <dt> o 
    <a href="#RemoveRuleSet()"><b>RemoveRuleSet</b></a>()
<dd>  Removes the RuleSet of the current interference simulation.
 <dt> o 
    <a href="#SetClearanceValue(double)"><b>SetClearanceValue</b></a>(double)
<dd>  Sets the clearance value.
 <dt> o 
    <a href="#SetComparison(PLMIInterferenceSimulation::Comparison)"><b>SetComparison</b></a>(PLMIInterferenceSimulation::Comparison)
<dd>  Sets the mode of interference comparison.
 <dt> o 
    <a href="#SetGroupComputationType(PLMIInterferenceSimulation::GroupComputationType)"><b>SetGroupComputationType</b></a>(PLMIInterferenceSimulation::GroupComputationType)
<dd>  Sets the mode of computation of groups for interference simulation.
 <dt> o 
    <a href="#SetIntermediateRepresentation(PLMIInterferenceSimulation::IntermediateRepresentation)"><b>SetIntermediateRepresentation</b></a>(PLMIInterferenceSimulation::IntermediateRepresentation)
<dd>  Sets the option for intermediate representation.
 <dt> o 
    <a href="#SetName(CATUnicodeString)"><b>SetName</b></a>(CATUnicodeString)
<dd>  Sets the name of the Interference Simulation.
 <dt> o 
    <a href="#SetRuleSetByName(CATUnicodeString)"><b>SetRuleSetByName</b></a>(CATUnicodeString)
<dd>  Adds a RuleSet containing the knowledge rules of computation to the interference simulation.
 <dt> o 
    <a href="#SetSpecificationType(PLMIInterferenceSimulation::SpecificationType)"><b>SetSpecificationType</b></a>(PLMIInterferenceSimulation::SpecificationType)
<dd>  Sets the Interference Specification Type.
</dl>
<dl>
 <h2>Enumerated Type Index</h2> <br>
 <dt> o 
    <a href="#Comparison"><b>Comparison</b></a>
<dd>  Interference Simulation type of comparison, these options allow or not the reuse of existing interference simulation results.
 <dt> o 
    <a href="#ComputeQuantifier"><b>ComputeQuantifier</b></a>
<dd>  Interference Simulation computation of quantifier, these options allow or not the computation of quantifier for interference <br>
 
 
 <dt> o 
    <a href="#GroupComputationType"><b>GroupComputationType</b></a>
<dd>  Management of groups for Interference Simulation.
 <dt> o 
    <a href="#IntermediateRepresentation"><b>IntermediateRepresentation</b></a>
<dd>  Management of intermediate representations for Interference Simulation, these options allow to take into account or not intermediate representations during interference computation.
 <dt> o 
    <a href="#SpecificationType"><b>SpecificationType</b></a>
<dd>  Interference Simulation Specification type of computation for the standard specification.
 <dt> o 
    <a href="#SpecificationTypeEngCnx"><b>SpecificationTypeEngCnx</b></a>
<dd>  Interference Simulation Specification type of computation for the use of engineering connection specification.
</dl>
<dl>
</dl>
 <h2>Methods</h2> <br>
<a name="AddComputeQuantifier"></a><a name="AddComputeQuantifier(PLMIInterferenceSimulation::ComputeQuantifier)"></a> <dt> o <b>AddComputeQuantifier</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>AddComputeQuantifier</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::ComputeQuantifier','PLMIInterferenceSimulation::ComputeQuantifier')</script> <td><tt>iQuantifierMode</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Adds the computation of a quantifier.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iQuantifierMode</tt>
   <dd> [in]   The type of quantifier to take into account defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','ComputeQuantifier','ComputeQuantifier') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br> By default, Interference Simulation is created without the computation of any quantifier.

 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example adds the computation of the quantifier of minimum distance to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::ComputeQuantifier  iQuantifierMode = PLMIInterferenceSimulation::MinimumDistance ;
   
   HRESULT hr = piItfSimu->AddComputeQuantifier (iQuantifierMode) ;
 
   </pre></pre></dd>
</dl>
</dl>
<a name="AddGroupObjects"></a><a name="AddGroupObjects(PLMIInterferenceGroupObjects*&amp;)"></a> <dt> o <b>AddGroupObjects</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>AddGroupObjects</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceGroupObjects','PLMIInterferenceGroupObjects*&amp;')</script> <td><tt>oGroup</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Adds a new empty group and return it.
 <br> This method adds a group depending of the value of the parameter <b>GroupComputationType </b>.
 <br />
 <strong>Precondition</strong>: If the value of GroupComputationType is:
 <ul>
 <li>  <b> <code>AllAgainstAllInGroup</code>   </b> : groups can be added.                                                     </li>
 <li>  <b> <code>GroupAgainstGroup</code>      </b> : groups can be added.                                                     </li>
 <li>  <b> <code>GroupAgainstContext</code>    </b> : groups can be added.                                                     </li>
 <li>  <b> <code>AllAgainstAllInContext</code> </b> : no group can be added because no group is necessary in this case.        </li>
 </ul>

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oGroup</tt>
   <dd> [out, CATBaseUnknown#Release]   The new group created.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed. Check that the precondition is fulfilled.
   </dl>
   
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the GroupComputationType "GroupAgainstGroup" to the current interference simulation and adds a new group.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::GroupComputationType  GroupType = PLMIInterferenceSimulation::GroupAgainstGroup ;
   PLMIInterferenceGroupObjects * piNewGroup    = NULL ;
   
   HRESULT hr = piItfSimu->SetGroupComputationType (GroupType) ;
   if (SUCCEEDED(hr))
   {
     hr = piItfSimu->AddGroupObjects (piNewGroup) ;
   }
   
   </pre></pre></dd>
</dl>
</dl>
<a name="AddItfSpecificationTypeEngCnx"></a><a name="AddItfSpecificationTypeEngCnx(PLMIInterferenceSimulation::SpecificationTypeEngCnx)"></a> <dt> o <b>AddItfSpecificationTypeEngCnx</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>AddItfSpecificationTypeEngCnx</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::SpecificationTypeEngCnx','PLMIInterferenceSimulation::SpecificationTypeEngCnx')</script> <td><tt>iTypeEngCnx</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Adds the type of engineering connection specification to take into account.
 <br> The following values can be added one by one:
 <ul>
 <li>  <code> <b>CheckNoClash</b>   </code> to take into account engineering connection specifications of type "Check No Clash"  </li>
 <li>  <code> <b>CheckContact</b>   </code> to take into account engineering connection specifications of type "Check Contact"   </li>
 <li>  <code> <b>CheckClearance</b> </code> to take into account engineering connection specifications of type "Check Clearance" </li>
 <li>  <code> <b>NoCheck</b>        </code> to take into account engineering connection specifications of type "NoCheck"         </li>
 <li>  <code> <b>CheckNone</b>      </code> to not use engineering connection specification                                      </li>
 </ul>
 
 If the value <b> <code>NoCheck</code> </b> is the only value used, standard specification must also be used.
 <br> In this case, the value of <b> <code>SpecificationType</code> </b> must be:
 <ul>
 <li>     <b> <code>SpecStdClash</code>      </b>  </li>
 <li>  or <b> <code>SpecStdClearance</code>  </b>  </li>
 </ul>
 
 <br> Remove the <b> <code>CheckNone</code> </b> value (see 
<script type="text/javascript"> activateLinkAnchor('','RemoveItfSpecificationTypeEngCnx','RemoveItfSpecificationTypeEngCnx') </script> ) activates the first four values.
 <br> <br> Add value <b> <code>CheckNone</code> </b> means that no engineering connection specification will be used.
 In this case, as a specification (standard specification or engineering connection specification or knowledge rules specification) must always be active,
 one of the others specifications (standard specification or knowledge rules specification) has to be added before.

  <br> <br> By default, Interference Simulation is created with the type: <b> <code>CheckNone</code> </b>
  <br> <br>
  
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iTypeEngCnx</tt>
   <dd> [in]   The type of engineering connection specification defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','SpecificationTypeEngCnx','SpecificationTypeEngCnx') </script> enum.  
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example allows to take into account the engineering connection of type "Check No Clash" of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::SpecificationTypeEngCnx  ItfSpecTypeEngCnx = PLMIInterferenceSimulation::CheckNoClash ;
   
   HRESULT hr = piItfSimu->AddItfSpecificationTypeEngCnx (ItfSpecTypeEngCnx) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="Execute"></a><a name="Execute()"></a> <dt> o <b>Execute</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>Execute</b>(<td>)<script type="text/javascript"> activateLink('0','= 0 ')</script>  </table></dt>
<dl>
  <dd>
 Launches the computation.
 <br> Executes the Simulation and computes the Interferences Results (see 
<script type="text/javascript"> activateLinkAnchor('PLMIInterferenceResult)','','PLMIInterferenceResult)') </script> 
<dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
</dl>
</dl>
<a name="GetClearanceValue"></a><a name="GetClearanceValue(double&amp;)"></a> <dt> o <b>GetClearanceValue</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetClearanceValue</b>(<td><script type="text/javascript"> activateLink('double','double&amp;')</script> <td><tt>oClearVal</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Returns the clearance value.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oClearVal</tt>
   <dd> [out]   The value of Clearance. It is expressed in meter.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example retrieves the value of Clearance of the InterferenceSimulation <tt>piItfSimu</tt> .
   <pre>
   double oClearVal = 0.0 ;
   HRESULT hr = piItfSimu->GetClearanceValue (oClearVal) ;
   </pre></pre></dd>
</dl>
</dl>
<a name="GetComparison"></a><a name="GetComparison(PLMIInterferenceSimulation::Comparison&amp;)"></a> <dt> o <b>GetComparison</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetComparison</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::Comparison','PLMIInterferenceSimulation::Comparison&amp;')</script> <td><tt>oComparisonMode</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets the mode of interference comparison.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oComparisonMode</tt>
   <dd> [out]   The mode of interference comparison defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','Comparison','Comparison') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the mode of comparison of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::Comparison  ItfComparisonMode = PLMIInterferenceSimulation::ComparisonNone ;
   
   HRESULT hr = piItfSimu->GetComparison (ItfComparisonMode) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetGroupComputationType"></a><a name="GetGroupComputationType(PLMIInterferenceSimulation::GroupComputationType&amp;)"></a> <dt> o <b>GetGroupComputationType</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetGroupComputationType</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::GroupComputationType','PLMIInterferenceSimulation::GroupComputationType&amp;')</script> <td><tt>oType</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets the mode of computation of groups for interference simulation.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oType</tt>
   <dd> [out]   The type of computation for groups defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','GroupComputationType','GroupComputationType') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
   
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the value of group computation for the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::GroupComputationType  GroupType = PLMIInterferenceSimulation::AllAgainstAllInContext ;
   
   HRESULT hr = piItfSimu->GetGroupComputationType (GroupType) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetGroupObjects"></a><a name="GetGroupObjects(int,PLMIInterferenceGroupObjects*&amp;)"></a> <dt> o <b>GetGroupObjects</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetGroupObjects</b>(<td><script type="text/javascript"> activateLink('int','int')</script> <td><tt>iIndex</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('PLMIInterferenceGroupObjects','PLMIInterferenceGroupObjects*&amp;')</script> <td><tt>oGroup</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Retrieves a Group.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iIndex</tt>
   <dd> [in]    The index of the group to retrieve from the simulation.
   <br> This index is the rank of the group in the simulation.
   <br> The index of the first group is 1 and the index of the last group is the number of groups (see </dd>
<script type="text/javascript"> activateLinkAnchor('','GetNumberOfGroupObjects','GetNumberOfGroupObjects') </script> method).   
 
    <dt><tt> oGroup</tt>
   <dd> [out, CATBaseUnknown#Release]   The retrieved group
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
   
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the first group of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceGroupObjects * piGroup       = NULL ;
   int NbGroup = 0 ;
   
   HRESULT hr = piItfSimu->GetNumberOfGroupObjects (NbGroup) ;
   if (SUCCEEDED(hr) && (NbGroup > 0))
   {
     hr = piItfSimu->GetGroupObjects (1, piGroup) ;
   }
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetInterferenceResults"></a><a name="GetInterferenceResults(CATListPtrPLMIInterferenceResult&amp;)"></a> <dt> o <b>GetInterferenceResults</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetInterferenceResults</b>(<td><script type="text/javascript"> activateLink('CATListPtrPLMIInterferenceResult','CATListPtrPLMIInterferenceResult&amp;')</script> <td><tt>oListResults</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Retrieves the Interference Results.
 <br> This method retrieves a collection of Interferences results generated during interference simulation execution.
 <br> see 
<script type="text/javascript"> activateLinkAnchor('PLMIInterferenceResult','','PLMIInterferenceResult') </script> <br> All the pointers of this list must be released after use.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oListResults</tt>
   <dd> [out]    The list of results
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>

 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the list of results of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation       * piItfSimu   = ... ;  // (created by PLMIInterferenceServices)
   CATListPtrPLMIInterferenceResult   ListResults ;
   
   HRESULT hr = piItfSimu->GetInterferenceResults (ListResults) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetIntermediateRepresentation"></a><a name="GetIntermediateRepresentation(PLMIInterferenceSimulation::IntermediateRepresentation&amp;)"></a> <dt> o <b>GetIntermediateRepresentation</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetIntermediateRepresentation</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::IntermediateRepresentation','PLMIInterferenceSimulation::IntermediateRepresentation&amp;')</script> <td><tt>oInterRepMode</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets the option for intermediate representation.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oInterRepMode</tt>
   <dd> [out]   The mode of intermediate representation defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','IntermediateRepresentation','IntermediateRepresentation') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the mode for the intermediate representations during computation of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::IntermediateRepresentation  InterRepMode = PLMIInterferenceSimulation::InterRepNone ;
   
   HRESULT hr = piItfSimu->GetIntermediateRepresentation (InterRepMode) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetName"></a><a name="GetName(CATUnicodeString&amp;)"></a> <dt> o <b>GetName</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetName</b>(<td><script type="text/javascript"> activateLink('CATUnicodeString','CATUnicodeString&amp;')</script> <td><tt>oSimuName</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets the name of the Interference Simulation.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oSimuName</tt>
   <dd> [out]   The name of the interference simulation.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the name of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   CATUnicodeString   oSimuName ("") ;
   
   hr = piItfSimu->GetName (oSimuName) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetNumberOfGroupObjects"></a><a name="GetNumberOfGroupObjects(int&amp;)"></a> <dt> o <b>GetNumberOfGroupObjects</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetNumberOfGroupObjects</b>(<td><script type="text/javascript"> activateLink('int','int&amp;')</script> <td><tt>oNbGroup</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets the number of groups of the simulation.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oNbGroup</tt>
   <dd> [out]    The number of groups.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>

 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the number of groups of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   int NbGroup = 0 ;
   
   HRESULT hr = piItfSimu->GetNumberOfGroupObjects (NbGroup) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetRuleSetName"></a><a name="GetRuleSetName(CATUnicodeString&amp;)"></a> <dt> o <b>GetRuleSetName</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetRuleSetName</b>(<td><script type="text/javascript"> activateLink('CATUnicodeString','CATUnicodeString&amp;')</script> <td><tt>oRuleSetName</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets name of the RuleSet containing the knowledge rules of computation of the interference simulation.
 <br> An empty string returned means that no RuleSet is taken into account.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oRuleSetName</tt>
   <dd> [out]   The name of the RuleSet.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example retrieves the name of the RuleSet used in the InterferenceSimulation <tt>iSimu</tt> .
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   CATUnicodeString               oRuleSetName  = "" ;
   
   HRESULT hr = piItfSimu->SetRuleSetByName (oRuleSetName) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="GetSpecificationType"></a><a name="GetSpecificationType(PLMIInterferenceSimulation::SpecificationType&amp;)"></a> <dt> o <b>GetSpecificationType</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>GetSpecificationType</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::SpecificationType','PLMIInterferenceSimulation::SpecificationType&amp;')</script> <td><tt>oItfSpecType</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Gets the Interference Specification Type.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> oItfSpecType</tt>
   <dd> [out]   The type of standard specification defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','SpecificationType','SpecificationType') </script> enum.  
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example gets the Interference Specification Type of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::SpecificationType  ItfSpecClear = PLMIInterferenceSimulation::SpecStdNone ;
   
   HRESULT hr = piItfSimu->GetSpecificationType (ItfSpecClear) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="IsActiveComputeQuantifier"></a><a name="IsActiveComputeQuantifier(PLMIInterferenceSimulation::ComputeQuantifier,CATBoolean&amp;)"></a> <dt> o <b>IsActiveComputeQuantifier</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>IsActiveComputeQuantifier</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::ComputeQuantifier','PLMIInterferenceSimulation::ComputeQuantifier')</script> <td><tt>iQuantifierMode</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATBoolean','CATBoolean&amp;')</script> <td><tt>oIsActive</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Checks if the computation of a quantifier is active.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iQuantifierMode</tt>
   <dd> [in]   the type of calculation option quantifier to verify.
 </dd>
    <dt><tt> oIsActive</tt>
   <dd> [out]   State of the option: 
      <dl>
      <dt><tt>TRUE</tt>   <dd> the option is active.
      <dt><tt>FALSE</tt>  <dd> the option is inactive.
      </dl>
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example verifies if the computation of the quantifier of minimum distance is activated for the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::ComputeQuantifier  iQuantifierMode = PLMIInterferenceSimulation::MinimumDistance ;
   CATBoolean   bool1 = FALSE ;
   
   HRESULT hr = piItfSimu->IsActiveComputeQuantifier (iQuantifierMode, bool1) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="IsActiveItfSpecificationTypeEngCnx"></a><a name="IsActiveItfSpecificationTypeEngCnx(PLMIInterferenceSimulation::SpecificationTypeEngCnx,CATBoolean&amp;)"></a> <dt> o <b>IsActiveItfSpecificationTypeEngCnx</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>IsActiveItfSpecificationTypeEngCnx</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::SpecificationTypeEngCnx','PLMIInterferenceSimulation::SpecificationTypeEngCnx')</script> <td><tt>iTypeEngCnx</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATBoolean','CATBoolean&amp;')</script> <td><tt>oIsActive</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Determines if one specific type of engineering connection specification is used.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iTypeEngCnx</tt>
   <dd> [in]   The type of engineering connection specification to verify.
 </dd>
    <dt><tt> oIsActive</tt>
   <dd> [out]   State of the option: 
      <dl>
      <dt><tt>TRUE</tt>   <dd> the option is active.
      <dt><tt>FALSE</tt>  <dd> the option is inactive.
      </dl>
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example verifies if the engineering connection of type "Check Contact" is taken into account for the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::SpecificationTypeEngCnx  ItfSpecTypeEngCnx = PLMIInterferenceSimulation::CheckContact ;
   CATBoolean   bool1 = FALSE ;
   
   HRESULT hr = piItfSimu->IsActiveItfSpecificationTypeEngCnx (ItfSpecTypeEngCnx, bool1) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="IsComputeQuantifierAvailable"></a><a name="IsComputeQuantifierAvailable(PLMIInterferenceSimulation::ComputeQuantifier,CATBoolean&amp;)"></a> <dt> o <b>IsComputeQuantifierAvailable</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>IsComputeQuantifierAvailable</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::ComputeQuantifier','PLMIInterferenceSimulation::ComputeQuantifier')</script> <td><tt>iQuantifierMode</tt>,<tr><td></td><td><script type="text/javascript"> activateLink('CATBoolean','CATBoolean&amp;')</script> <td><tt>oIsAvailable</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Checks if the computation of a quantifier is available.
 <br>  Computation of vector of penetration has only effect when the result is a clash and is always available.
 <br>  Computation of minimum distance between parts has only effect when the result is a clearance. It is only available if one of the following specifications is active:
 <ul>
 <li>  standard computation with a computation of clearance (see parameter: <code>SpecStdClearance</code> of 
<script type="text/javascript"> activateLinkAnchor('','SpecificationType','SpecificationType') </script> )                                 </li> <li>  engineering connections of type "Check Clearance" are taken into account (see parameter: <code>CheckClearance</code> of 
<script type="text/javascript"> activateLinkAnchor('','SpecificationTypeEngCnx','SpecificationTypeEngCnx') </script> )  </li> <li>  knowledges rules are taken into account (see method: 
<script type="text/javascript"> activateLinkAnchor('','SetRuleSetByName','SetRuleSetByName') </script> )                                                                                                                                </li> </ul>

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iQuantifierMode</tt>
   <dd> [in]   the type of calculation option quantifier to check.
 </dd>
    <dt><tt> oIsAvailable</tt>
   <dd> [out]   State of the option: 
      <dl>
      <dt><tt>TRUE</tt>   <dd> the option is available.
      <dt><tt>FALSE</tt>  <dd> the option is not available.
      </dl>
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
   
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example verifies if the computation of the quantifier of minimum distance is allowed for the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::ComputeQuantifier  iQuantifierMode = PLMIInterferenceSimulation::MinimumDistance ;
   CATBoolean   bool1 = FALSE ;
   
   HRESULT hr = piItfSimu->IsComputeQuantifierAvailable (iQuantifierMode, bool1) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="RemoveComputeQuantifier"></a><a name="RemoveComputeQuantifier(PLMIInterferenceSimulation::ComputeQuantifier)"></a> <dt> o <b>RemoveComputeQuantifier</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>RemoveComputeQuantifier</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::ComputeQuantifier','PLMIInterferenceSimulation::ComputeQuantifier')</script> <td><tt>iQuantifierMode</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Removes the computation of a quantifier.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iQuantifierMode</tt>
   <dd> [in]   The type of quantifier to not take into account defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','ComputeQuantifier','ComputeQuantifier') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example removes the computation of the quantifier of minimum distance to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::ComputeQuantifier  iQuantifierMode = PLMIInterferenceSimulation::MinimumDistance ;
   
   HRESULT hr = piItfSimu->RemoveComputeQuantifier (iQuantifierMode) ;
 
   </pre></pre></dd>
</dl>
</dl>
<a name="RemoveGroupObjects"></a><a name="RemoveGroupObjects(int)"></a> <dt> o <b>RemoveGroupObjects</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>RemoveGroupObjects</b>(<td><script type="text/javascript"> activateLink('int','int')</script> <td><tt>iIndex</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Removes a Group.
 <br> This method removes a group depending of the value of the parameter <b><code>GroupComputationType</code> </b>.
 <br />
 <strong>Precondition</strong>: If the value of GroupComputationType is:
 <ul>
 <li>  <b> <code>AllAgainstAllInGroup</code>   </b> : group can be removed if there is more than one group.   </li>
 <li>  <b> <code>GroupAgainstGroup</code>      </b> : group can be removed if there are more than two groups. </li>
 <li>  <b> <code>GroupAgainstContext</code>    </b> : group can be removed if there is more than one group.   </li>
 <li>  <b> <code>AllAgainstAllInContext</code> </b> : no group can be removed.                                </li>
 </ul>

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iIndex</tt>
   <dd> [in]   The number of group to remove.
   <br> This index is the rank of the group in the simulation.
   <br> The index of the first group is 1 and the index of the last group is the number of groups (see </dd>
<script type="text/javascript"> activateLinkAnchor('','GetNumberOfGroupObjects','GetNumberOfGroupObjects') </script> method). 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed. Check that the precondition is fulfilled.
   </dl>
   
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example removes the last group of the the current interference simulation.
   We suppose that the interference simulation has a GroupComputationType value equal to 
   <b> <code>GroupAgainstGroup</code> </b> and that a new group has already been added.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   int NbGroup = 0 ;
   
   HRESULT hr = piItfSimu->GetNumberOfGroupObjects (NbGroup) ;
   if (SUCCEEDED(hr) && (NbGroup > 2))
   {
     hr = piItfSimu->RemoveGroupObjects (NbGroup) ;
   }
   
   </pre></pre></dd>
</dl>
</dl>
<a name="RemoveItfSpecificationTypeEngCnx"></a><a name="RemoveItfSpecificationTypeEngCnx(PLMIInterferenceSimulation::SpecificationTypeEngCnx)"></a> <dt> o <b>RemoveItfSpecificationTypeEngCnx</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>RemoveItfSpecificationTypeEngCnx</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::SpecificationTypeEngCnx','PLMIInterferenceSimulation::SpecificationTypeEngCnx')</script> <td><tt>iTypeEngCnx</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Removes one type of engineering connection specification.
 <br> Removes the value <b> <code>CheckNone</code> </b> will take into account all the other values:
 <ul>
 <li> <code>CheckNoClash</code>    </li>
 <li> <code>CheckContact</code>    </li>
 <li> <code>CheckClearance</code>  </li>
 <li> <code>NoCheck</code>         </li>
 </ul>
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iTypeEngCnx</tt>
   <dd> [in]   The type of engineering connection specification to remove.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example removes the taken into account of the engineering connection of type "Check Clearance" of the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::SpecificationTypeEngCnx  ItfSpecTypeEngCnx = PLMIInterferenceSimulation::CheckClearance ;
   
   HRESULT hr = piItfSimu->RemoveItfSpecificationTypeEngCnx (ItfSpecTypeEngCnx) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="RemoveRuleSet"></a><a name="RemoveRuleSet()"></a> <dt> o <b>RemoveRuleSet</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>RemoveRuleSet</b>(<td>)<script type="text/javascript"> activateLink('0','= 0 ')</script>  </table></dt>
<dl>
  <dd>
 Removes the RuleSet of the current interference simulation.
 <br> In this case, knowledge rules specification will not be taken into account during computation.

 <br> <br> A specification (standard specification or engineering connection specification or knowledge rules specification) must always be active.
      <br> So, before removing the taking account of the knowledge rules (RemoveRuleSet), one of the others specifications (standard specification or
 engineering connection specification) must be active.
 
 
<dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example removes the RuleSet used in the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   
   HRESULT hr = piItfSimu->SetRuleSetByName (iRuleSetName) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="SetClearanceValue"></a><a name="SetClearanceValue(double)"></a> <dt> o <b>SetClearanceValue</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetClearanceValue</b>(<td><script type="text/javascript"> activateLink('double','double')</script> <td><tt>iClearVal</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Sets the clearance value.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iClearVal</tt>
   <dd> [in]   The value of Clearance. It must be expressed in meter.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the value of Clearance of 32 mm to the interference simulation <tt>piItfSimu</tt> .
   <pre>
   double iClearVal = 0.032 ;
   HRESULT hr = piItfSimu->SetClearanceValue (iClearVal) ;
   </pre></pre></dd>
</dl>
</dl>
<a name="SetComparison"></a><a name="SetComparison(PLMIInterferenceSimulation::Comparison)"></a> <dt> o <b>SetComparison</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetComparison</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::Comparison','PLMIInterferenceSimulation::Comparison')</script> <td><tt>iComparisonMode</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Sets the mode of interference comparison.
 <br> By default, Interference Simulation is created with the option: <b> <code>RecomputeModify</code></b>.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iComparisonMode</tt>
   <dd> [in]   The mode of interference comparison defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','Comparison','Comparison') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the mode of comparison "DeleteOutOfScope" to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::Comparison  ItfComparisonMode = PLMIInterferenceSimulation::DeleteOutOfScope ;
   
   HRESULT hr = piItfSimu->SetComparison (ItfComparisonMode) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="SetGroupComputationType"></a><a name="SetGroupComputationType(PLMIInterferenceSimulation::GroupComputationType)"></a> <dt> o <b>SetGroupComputationType</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetGroupComputationType</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::GroupComputationType','PLMIInterferenceSimulation::GroupComputationType')</script> <td><tt>iType</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Sets the mode of computation of groups for interference simulation.
 <br> If you set the "GroupComputationType", the number of groups can be modified.
 <br> By default, Interference Simulation is created with the option: <b> <code>AllAgainstAllInContext</code> </b>.

 <br> If the new value of GroupComputationType is:
 <ul>
 <li>  <b> <code>AllAgainstAllInGroup</code> </b> :
           <ul style="list-style-type:none;">
             <li> One group is created if there is no existing group because one group at least is necessary. </li>
             <li> In the others cases, the number of group is not modified.                                   </li>
           </ul>
 </li>
 <li>  <b> <code>GroupAgainstGroup</code> </b> :
           <ul style="list-style-type:none;">
             <li> Two groups are created if there is no existing group.     </li>
             <li> One group is created if there is one existing group.      </li>
             <li> In the others cases, the number of group is not modified. </li>
           </ul>
 </li>
 <li>  <b> <code>GroupAgainstContext</code> </b> :
           <ul style="list-style-type:none;">
             <li> One group is created if there is no existing group.                                     </li>
           </ul>
 <li>  <b> <code>AllAgainstAllInContext</code> </b> :
           <ul style="list-style-type:none;">
             <li> No group is necessary in this case so, all the existings groups are removed. </li>
           </ul>
 </li>
 </ul>


 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iType</tt>
   <dd> [in]   The type of computation for groups defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','GroupComputationType','GroupComputationType') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
   
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the value of group computation "GroupAgainstGroup" to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::GroupComputationType  GroupType = PLMIInterferenceSimulation::GroupAgainstGroup ;
   
   HRESULT hr = piItfSimu->SetGroupComputationType (GroupType) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="SetIntermediateRepresentation"></a><a name="SetIntermediateRepresentation(PLMIInterferenceSimulation::IntermediateRepresentation)"></a> <dt> o <b>SetIntermediateRepresentation</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetIntermediateRepresentation</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::IntermediateRepresentation','PLMIInterferenceSimulation::IntermediateRepresentation')</script> <td><tt>iInterRepMode</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Sets the option for intermediate representation.
 <br> By default, Interference Simulation is created with the option: <b> <code>InterRepNone</code> </b>.

 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iInterRepMode</tt>
   <dd> [in]   The mode for intermediate representation defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','IntermediateRepresentation','IntermediateRepresentation') </script> enum. 
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the taken into account of the intermediate representations during computation for the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::IntermediateRepresentation  InterRepMode = PLMIInterferenceSimulation::InterRepAppend ;
   
   HRESULT hr = piItfSimu->SetIntermediateRepresentation (InterRepMode) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="SetName"></a><a name="SetName(CATUnicodeString)"></a> <dt> o <b>SetName</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetName</b>(<td><script type="text/javascript"> activateLink('CATUnicodeString','CATUnicodeString')</script> <td><tt>iSimuName</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Sets the name of the Interference Simulation.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iSimuName</tt>
   <dd> [in]   <tt>ItfSimu_01<tt> must be a not empty string of character.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the name <tt>ItfSimu_01<tt> to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   CATUnicodeString   iSimuName = "ItfSimu_01" ;
   
   HRESULT hr = opiItfSimu->SetName (iSimuName) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="SetRuleSetByName"></a><a name="SetRuleSetByName(CATUnicodeString)"></a> <dt> o <b>SetRuleSetByName</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetRuleSetByName</b>(<td><script type="text/javascript"> activateLink('CATUnicodeString','CATUnicodeString')</script> <td><tt>iRuleSetName</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Adds a RuleSet containing the knowledge rules of computation to the interference simulation.
 <br> In this case, knowledge rules specification will be taken into account during computation.
 <br> Note that a Search will be launch to retrieve the RuleSet by its name. So, the name given as argument to this method
 must be specific enough so that the search result finds only one RuleSet.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iRuleSetName</tt>
   <dd> [in]   The name of the RuleSet.
 </dd>
</dl>
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the RuleSet beginning with the string "RuleSet_01" to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   CATUnicodeString               iRuleSetName  = "RuleSet_01*" ;
   
   HRESULT hr = piItfSimu->SetRuleSetByName (iRuleSetName) ;
   
   </pre></pre></dd>
</dl>
</dl>
<a name="SetSpecificationType"></a><a name="SetSpecificationType(PLMIInterferenceSimulation::SpecificationType)"></a> <dt> o <b>SetSpecificationType</b>

<dt>  <table><tr><td>  public virtual <script type="text/javascript"> activateLink('HRESULT','HRESULT')</script>  <b>SetSpecificationType</b>(<td><script type="text/javascript"> activateLink('PLMIInterferenceSimulation::SpecificationType','PLMIInterferenceSimulation::SpecificationType')</script> <td><tt>iItfSpecType</tt>)<script type="text/javascript"> activateLink('0',' = 0 ')</script>  </table></dt>
<dl>
  <dd>
 Sets the Interference Specification Type.
 
 <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> iItfSpecType</tt>
   <dd> [in]   The type of standard specification defined by </dd>
<script type="text/javascript"> activateLinkAnchor('','SpecificationType','SpecificationType') </script> enum.  
  <dt> <b>Returns:</b> 
  <dd>    <dl>
   <dt><tt>S_OK</tt>   <dd> If the operation is successful.
   <dt><tt>E_FAIL</tt> <dd> If the operation is failed.
   </dl>
 
 <br>
 
</dl>
  <dt> Example: </dt>
  <dd> <pre class="code">   This example sets the Interference Specification Type <tt>SpecStdClearance<tt> to the current interference simulation.
   <pre>
   PLMIInterferenceSimulation   * piItfSimu     = ... ;  // (created by PLMIInterferenceServices)
   PLMIInterferenceSimulation::SpecificationType  ItfSpecClear = PLMIInterferenceSimulation::SpecStdClearance ;
   
   HRESULT hr = piItfSimu->SetSpecificationType (ItfSpecClear) ;
   
   </pre></pre></dd>
</dl>
</dl>
 <h2>Enumerated Types</h2> <br>
<a name="Comparison"> <dt> o <b>Comparison</b>
<dl>
  <dd>
<pre>
enum <b>Comparison</b> {
  ComparisonNone,
  RecomputeModify,
  DeleteOutOfScope
}
</pre>
 Interference Simulation type of comparison, these options allow or not the reuse of existing interference simulation results. <br>
 
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> ComparisonNone</tt>
   <dd>        No reuse of existing interference simulation results.
  <br>  Previously computed interferences are removed from the simulation.
 
 </dd>
    <dt><tt> RecomputeModify</tt>
   <dd>        Reuse of existing interference simulation results. In this case, only the modified parts are computed.
  <br>  Previously computed interferences are kept.
 
 </dd>
    <dt><tt> DeleteOutOfScope</tt>
   <dd>        This option forces the selection of option: <code>RecomputeModify</code>.
  <br>  This option allows to remove from the simulation the interferences for which the validity status is "Out of Scope"
 
 <br> <br> By default, Interference Simulation is created with the option: <code>RecomputeModify</code>.</dd>
</dl>
</dl>
</dl>
<a name="ComputeQuantifier"> <dt> o <b>ComputeQuantifier</b>
<dl>
  <dd>
<pre>
enum <b>ComputeQuantifier</b> {
  MinimumDistance,
  PenetrationVector
}
</pre>
 Interference Simulation computation of quantifier, these options allow or not the computation of quantifier for interference <br>
 
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> MinimumDistance</tt>
   <dd>        Computation of minimum distance between parts.
   <br> This option has only effect when the result is a clearance.
   <br> This option is only available if one of the following specifications is active:
   <br>    - standard computation with a computation of clearance (see: <code>SpecStdClearance</code> in </dd>
<script type="text/javascript"> activateLinkAnchor('','SpecificationType','SpecificationType') </script> ).   <br>    - engineering connections of type "Check Clearance" are taken into account (see: <code>CheckClearance</code> in 
<script type="text/javascript"> activateLinkAnchor('','SpecificationTypeEngCnx','SpecificationTypeEngCnx') </script> ).   <br>    - knowledges rules are taken into account (see method: 
<script type="text/javascript"> activateLinkAnchor('','SetRuleSetByName','SetRuleSetByName') </script> ).   <br> <br>

 
    <dt><tt> PenetrationVector</tt>
   <dd>        Computation of vector of penetration.
   <br> This option has only effect when the result is a clash.

 <br> <br> Use method </dd>
<script type="text/javascript"> activateLinkAnchor('','IsComputeQuantifierAvailable','IsComputeQuantifierAvailable') </script> to check if the desired computation of quantifier is available. <br> <br> By default, Interference Simulation is created without computation of quantifier.
</dl>
</dl>
</dl>
<a name="GroupComputationType"> <dt> o <b>GroupComputationType</b>
<dl>
  <dd>
<pre>
enum <b>GroupComputationType</b> {
  AllAgainstAllInGroup,
  GroupAgainstGroup,
  GroupAgainstContext,
  AllAgainstAllInContext
}
</pre>
 Management of groups for Interference Simulation. <br>
 The interference simulation may have followings types of groups:

 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> AllAgainstAllInGroup,</tt>
   <dd>   The computation takes into account all the occurrences against each other inside groups

 </dd>
    <dt><tt> GroupAgainstGroup,</tt>
   <dd>   The computation takes into account all the occurrences in a group against the others in other group.

 </dd>
    <dt><tt> GroupAgainstContext,</tt>
   <dd>   The computation takes into account all the occurrences of a group against the rest of the context.
   In that case, the context is the root of one occurrence in the group.

 </dd>
    <dt><tt> AllAgainstAllInContext,</tt>
   <dd>   The computation takes into account all the occurrences against each other inside context.
   In that case, the context is the root product.</dd>
</dl>
</dl>
</dl>
<a name="IntermediateRepresentation"> <dt> o <b>IntermediateRepresentation</b>
<dl>
  <dd>
<pre>
enum <b>IntermediateRepresentation</b> {
  InterRepNone,
  InterRepAppend,
  InterRepComputeBetween
}
</pre>
 Management of intermediate representations for Interference Simulation, these options allow to take into account or not intermediate representations during interference computation. <br>
 
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> InterRepNone</tt>
   <dd>        Intermediate representations are not taking into account for computation.
 
 </dd>
    <dt><tt> InterRepAppend</tt>
   <dd>        Intermediate representations are taking into account for computation.
 
 </dd>
    <dt><tt> InterRepComputeBetween</tt>
   <dd>        Intermediate representations are taking into account for computation and computation is also launched between them.

 <br> <br> By default, Interference Simulation is created with the option: <code> InterRepNone</code> .</dd>
</dl>
</dl>
</dl>
<a name="SpecificationType"> <dt> o <b>SpecificationType</b>
<dl>
  <dd>
<pre>
enum <b>SpecificationType</b> {
  SpecStdNone,
  SpecStdClash,
  SpecStdClearance
}
</pre>
 Interference Simulation Specification type of computation for the standard specification.
 
 <br>
   
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt>   SpecStdNone</tt>
   <dd>    NO standard computation.
    <br> A specification (standard specification or engineering connection specification or knowledge rules specification) must always be active. 
    <br> So, to remove the taking account of the standard specification (<code>SpecStdNone</code>), one of the others specifications (engineering connection specification
         with the option "No Check" unchecked or knowledge rules specification) has to be added before.
   </dd>
    <dt><tt>   SpecStdClash</tt>
   <dd>    CLASH + CONTACT computation.
   </dd>
    <dt><tt>   SpecStdClearance</tt>
   <dd>    CLASH + CONTACT + CLEARANCE computation.
   <br>
   <br> By default, the Interferene Simulation is created with the standard specification = SpecStdClash.</dd>
</dl>
</dl>
</dl>
<a name="SpecificationTypeEngCnx"> <dt> o <b>SpecificationTypeEngCnx</b>
<dl>
  <dd>
<pre>
enum <b>SpecificationTypeEngCnx</b> {
  CheckNone,
  CheckNoClash,
  CheckContact,
  CheckClearance,
  NoCheck
}
</pre>
 Interference Simulation Specification type of computation for the use of engineering connection specification. <br>
 
<dl>
  <dt> <b>Parameters:</b>
  <dd>
    <dl>
    <dt><tt> CheckNone</tt>
   <dd>        No use of engineering connection specification. 
  <br>  It means that the interference simulation uses:
           - the standard specification (see <code></dd>
<script type="text/javascript"> activateLinkAnchor('','SpecificationType</code>','SpecificationType</code>') </script> )           - or knowledge rules specification (see method: 
<script type="text/javascript"> activateLinkAnchor('','SetRuleSetByName','SetRuleSetByName') </script> ). 
 
    <dt><tt> CheckNoClash</tt>
   <dd>   to take into account engineering connection specifications of type "Check No Clash".
 
 </dd>
    <dt><tt> CheckContact</tt>
   <dd>   to take into account engineering connection specifications of type "Check Contact".
 
 </dd>
    <dt><tt> CheckClearance</tt>
   <dd>   to take into account engineering connection specifications of type "Check Clearance".
 
 </dd>
    <dt><tt> NoCheck</tt>
   <dd>   to take into account engineering connection specifications of type "No Check".
   <br> If this value is the only value used for engineering connection specification, standard specification must also be used.
        In this case the value of SpecificationType must be <code>SpecStdClash</code>  or  <code>SpecStdClearance</code>.

 <br> <br>
 When engineering connection specification is used, one or many following values can be used simultaneously:
  <br>   - <code>CheckNoClash</code>
  <br>   - <code>CheckContact</code>
  <br>   - <code>CheckClearance</code>
  <br>   - <code>NoCheck</code>
  <br>
 So, use method </dd>
<script type="text/javascript"> activateLinkAnchor('','AddItfSpecificationTypeEngCnx','AddItfSpecificationTypeEngCnx') </script> to specify the desired values or remove the value <code>CheckNone</code> value (see method:  
<script type="text/javascript"> activateLinkAnchor('','RemoveItfSpecificationTypeEngCnx','RemoveItfSpecificationTypeEngCnx') </script> ) to activate all these previous values.
 <br> <br>
 By default, Interference Simulation is created with the type: <code> CheckNone </code>
</dl>
</dl>
</dl>
<hr>
 This object is included in the file: <b>PLMIInterferenceSimulation.h</b><br>
If needed, your Imakefile.mk should include the module: <b>PLMInterferenceUseItf</b>
<hr/><p><i>
Copyright &#169; 1999-2014, Dassault Syst&#232;mes. All rights reserved.
</i></p>
</body>

</html>

