<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="en-us" />
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" type="text/css" href="../CAADocStyleSheets/caav5.css"/>
<script type="text/javascript" src="../CAADocJavaScript/DSDocTocToc.js">/* */</script>
<script type="text/javascript" src="../CAADocJavaScript/DSDocHighlight.js">/* */</script>
<script type="text/javascript" src="../CAADocJavaScript/submit.js">/* */</script>
<title>CAATpiUcCreateThreadAnnotation</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Creating NOA and Semantic Dimensions on Thread Annotations</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article discusses the CAATpiCreateThreadAnnotation use case. 
		This use case explains how to create semantic dimension annotations 
		associated with a selected thread geometry as well as text NOA &quot;Non 
		Object Annotations&quot; with leaders.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAATpiCreateThreadAnnotation Use Case</a>
			<ul>
				<li><a href="#What">What Does CAATpiCreateThreadAnnotation Do</a></li>
				<li><a href="#How">How to Launch CAATpiCreateThreadAnnotation</a></li>
				<li><a href="#Where">Where to Find the 
				CAATpiCreateThreadAnnotation Code</a></li>
			</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case is intended to help you to use Technological Product Specifications 
(TPS) interfaces [<a href="#References">3</a>]. The use case demonstrates <em>
CATITPSFactoryElementary</em> 
interface usage to create text NOA annotations and semantic dimensions on 
constructed geometry. Another interface demonstrated here is <em>
CATITPSFactoryTTRS</em> which is used for retrieving TTRS required for creating 
semantic dimensions. It also illustrates how to modify 
3D annotation properties by using interfaces from DraftingUseItf framework.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAATpiCreateThreadAnnotation Use Case</h2>
<p>CAATpiCreateThreadAnnotation is a use case of the CAATPSInterfaces.edu framework that illustrates 
DraftingUseItf, CATTPSUseItf &amp; CATTPSBaseUseItf as well as CATTTRSUseItf framework 
capabilities.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAATpiCreateThreadAnnotation Do</h3>
<p>The use case is an interactive command that prompts the user to select a 
geometrical thread representation and then a create text NOA annotation on each 
of the sub-elements associated to that geometry.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<p><img alt="Annotated Geometry" src="images/CAATpiCreateThreadAnnotationResult.png"/></p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAATpiCreateThreadAnnotation</h3>
<p>&nbsp;</p>
<p>To launch CAATpiCreateThreadAnnotation, you will need to set up the build time environment, then 
compile CAATpiCreateThreadAnnotation along with its prerequisites, set up the run time environment, 
and then execute the use case [<a href="#References">1</a>].
Do not type the module name on the command line, but type 3DEXPERIENCE instead.
When the application is ready, do the following:</p>
<p>&nbsp;</p>
<ul>
	<li>Create a 3D shape Representation, create a pad and add a threaded hole.</li>
	<li>Press the Thread Representation Creation icon if there is no constructed thread geometry displayed, by using Functional Tolerancing and Annotation workbench.</li>
	<li>Press the Create Thread Annotation icon to start the command (apparent 
	below).</li>
</ul>
<p>&nbsp;</p>
<p><img alt="CAA toolbar" height="50" src="images/toolbar.png" width="600"/></p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<p>&nbsp;</p>
<p>Import PLM Data: The use case may require input PLM Data: PLM Reference or PLM Representation Reference. 
This data is stored in 3D XML files, whose extension is "3dxml". 
You must import these PLM Data in the database using the PLM Access / Import As 3D XML command prior to launching the use case.
The "3dxml" file is supplied in the CAATPSInterfaces.edu framework:

InstallRootFolder\CAADoc\CAATPSInterfaces.edu\InputData\CreateThreadAnnotationModel.3dxml

where InstallRootFolder [<a href="#References">1</a>] is the folder where the API CD-ROM is installed.

This "3dxml" file contains the representation reference with the following attributes:</p>
<p>&nbsp;</p>
<ul>
	<li>PLMExternalIDValue: CreateThreadAnnotationModel</li>
	<li>Version: ---</li>	
</ul>
<p>&nbsp;</p>
<h3><a name="Where"></a>Where to Find the CAATpiCreateThreadAnnotation Code</h3>
<p>&nbsp;</p>
<p>The CAATpiCreateThreadAnnotation use case is made of several classes/a single file located in the 
CAATpiCreateThreadAnnotation.m module of the CAATPSInterfaces.edu framework: <code>InstallRootFolder\CAADoc\CAATPSInterfaces.edu\CAATpiCreateThreadAnnotation.m\</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">1</a>] is the folder 
where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a></h2>
<h2>Step-by-Step</h2>
<p>&nbsp;</p>
<p>There are nine logical steps in CAATpiCreateThreadAnnotation:</p>
<p>&nbsp;</p>
<p>CreateThreadAnnotationOnSelection correspond to step 2 through to step 9</p>
<ol>
	<li><a href="#Step1">Prolog</a></li>
	<li><a href="#Step2">Providing Appropriate Filter to the Geometric Selection Agent</a></li>
	<li><a href="#Step3">Retrieving the selected geometry</a></li>
	<li><a href="#Step4">Thread Cylinder Text NOA creation</a></li>
	<li><a href="#Step5">Thread Lower Plane Text NOA creation</a></li>
	<li><a href="#Step6">Thread Upper Plane Text NOA creation</a></li>
	<li><a href="#Step7">Semantic Dimension of the Thread Cylinder's diameter 
	creation</a></li>
	<li><a href="#Step8">Semantic Dimension between the two Thread Planes creation</a></li>
	<li><a href="#Step8">Epilog</a></li>
</ol>
<p>To avoid repeating certain parts of the code, the following functions were 
defined in CAATpiCreateThreadAnnotationCmd::</p>
<ol>
<li><a href="#Func1">CreateSemanticDimensionOnCylinder</a></li>
<li><a href="#Func2">CreateNoaOnAnnotationGeometry</a></li>
<li><a href="#Func3">CreateSemanticDimensionBetweenPlanes</a></li>
<li><a href="#Func4">RepostionNOA</a></li>
<li><a href="#Func5">AddLeaderToNOA</a></li>
<li><a href="#Func6">RePostionSemanticDimensionLine</a></li>
</ol>
<p>We will now comment each of these sections of code step by step, be it the </p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Prolog</h3>
<p>&nbsp;</p>
<p>The use case is the class CAATpiCreateTextCmd which is a CATStateCommand that 
implement the following statechart diagram.</p>
<p>
<img alt="CAATpiCreateTextCmd Command State Chart Diagram" height="159" src="images/CAATpiCreateThreadAnnotationStatechartDiagram.png" width="615"/></p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Providing Appropriate Filter to the Geometric Selection Agent</h3>
<pre class="code">void CAATpiCreateThreadAnnotationCmd::<strong>BuildGraph</strong> ()
{
// Create selection agent
//-----------------------
_pAgentGeometry = new <strong>CATPathElementAgent</strong> (&quot;AgentGeometry&quot;,
				      NULL,
				      CATDlgEngWithPrevaluation|
				      CATDlgEngMultiAcquisition|
				      CATDlgEngWithPSOHSO);

// Retrieve CATITPSFactoryTTRS interfaces
//---------------------------------------
<strong>CATITPSFactoryTTRS</strong> * piFactTTRS = NULL;
HRESULT rc = <strong>CATTPSInstantiateUseComponent</strong> (DfTPS_ItfTPSFactoryTTRS, (void**) &amp; piFactTTRS);

CATListOfCATString TypeList;
<span class="keyword">if</span> ( SUCCEEDED(rc) )
{
// Obtain Filter that must be used for selecting geometry to create 3D annotation
//-------------------------------------------------------------------------------
piFactTTRS -&gt; <strong>ObtainOrderedTypeList</strong> (TypeList);

...

_pAgentGeometry -&gt; <strong>SetOrderedTypeList</strong>(TypeList);

<strong>AddCSOClient</strong> (_pAgentGeometry);
...</pre>
<p>&nbsp;</p>
<p>The selection agent is created in the <code>Buildgraph</code> method of the command. 
Its a standard <em>CATPathElementAgent</em>. It's behavior <code>CATDlgEngMultiAcquisition</code> 
makes multiple selections possible. It's behavior <code>CATDlgEngWithPSOHSO</code> 
and the call to the <code>AddCSOClient</code> method allow the command to work in 
the object-action mode. That means that the user can select one or several geometrical 
elements then launch the command to create annotations that will be associated to the 
whole selection.</p>
<p>On which kind of geometrical element is it possible to create a 3D Text ? The 
answer to this question is given by the <em>CATITPSFactoryTTRS</em>::<code>GetOrderedTypeList</code> 
method. It returns a list of interface name (<code>TypeList</code><em>)</em> that 
is provided to the selection agent by <code>SetOrderedTypeList</code><em> </em>method. 
The selection agent use that list of interfaces to filter selection and keep only 
the geometrical elements on which it is possible to create a 3D annotation.</p>
<p><em>CATITPSFactoryTTRS</em> interface is obtained from the global service
<code>CATTPSInstantiateComponent</code>.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Retrieving the selected geometry&nbsp;</h3>

<pre class="code">// 1/ Retrieve the selected geometry
// =================================
CATSO *pSO = _pAgentGeometry-&gt;<strong>GetListOfValues</strong>();

<span class="keyword">if</span>(pSO)
{
int CSOSize = <strong>pSO</strong>-&gt;<strong>GetSize</strong>();
<span class="keyword">for</span>(int compt=(CSOSize-1); compt&gt;=0; --compt )
{
CATPathElement *<strong>pPath</strong> = (CATPathElement*)(*pSO)[compt];
</pre>
<script type="text/javascript">insertLinkToTop();</script>
<p>&nbsp;</p>
<p>It is important to keep the reverse loop due to remove operations 
performed on the selected geometry pointer pSO. Incrementing rather than 
decrementing the counter will return an error. </p>
<p>&nbsp;</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3>Search and retreive Set, Thread and FactoryElementary CATITPS interfaces&nbsp;</h3>
<pre class="code">// Search and retreive CATITPSSet interface
//=========================================
rc = pPath-&gt;<strong>Search</strong> (IID_CATITPSSet, (void**)&amp;piTPSSet);
<span class="keyword">if</span> (SUCCEEDED(rc) &amp;&amp; piTPSSet)
{

// Retrieve CATITPSFactoryElementary interfaces
//=============================================
rc = piTPSSet-&gt;QueryInterface(IID_CATITPSFactoryElementary, (void**)&amp;<strong>piFactElem</strong>);

...

// Search and retrieve CATITPSThread interface
//============================================
rc = pPath-&gt;<strong>Search</strong> (IID_CATITPSThread, (void**)&amp;piTPSThread);

<span class="keyword">if</span> (SUCCEEDED(rc) &amp;&amp; NULL != piTPSThread)
{
//Get thread construction geometry elements
//=========================================
piTPSThread-&gt;<strong>GetCylinder</strong>(&amp;piTPSCyl);
piTPSThread-&gt;<strong>GetLowerPlane</strong>(&amp;piTPSLowPlane);
piTPSThread-&gt;<strong>GetUpperPlane</strong>(&amp;piTPSUpPlane);
</pre>
<p>&nbsp;</p>
<p>When selection agent is valuated the transition method <code>
CreateThreadAnnotationOnSelection</code> 
is called. The selected geometry is retrieved by calling <code>GetListOfValues</code> 
on the selection agent. Selection is returned as a <em>CATSO</em> which contains 
one or more <em>CATPathElement</em>. <em>CATITPSFactoryAdvanced</em> interface is 
obtained from the global service <code>CATTPSInstantiateComponent</code>. The method
<code>CreateTextOnGeometry</code> is called with the following input arguments:</p>
<ul>
	<li>A <em>CATSO</em> which contains <em>CATPathElement</em> referencing geometry.</li>
	<li>The annotation Text as a <em>CATUnicodeString</em>.</li>
	<li>An optional plane to specify a favorite annotation plane for 3D visualization.</li>
</ul>
<p>Its output is a <em>CATITPSText</em> pointer on the created text.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4">Thread Cylinder Text NOA creation</a></h3>
<pre class="code">// 2.1 Thread Cylinder Text Noa creation
// ======================================
rc = CAATpiCreateThreadAnnotationCmd::<strong>CreateNoaOnAnnotationGeometry</strong> (<strong>piTPSCyl</strong>, piFactElem, &amp;piNOACylinder);
<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piNOACylinder)
{
// Translating the NOA away from the cylinder, by a distance relative to the size of the thread cylinder
//------------------------------------------------------------------------------------------------------
<strong>piTPSCyl</strong>-&gt;<strong>GetDiameter</strong>(Noa_XPos);
<strong>Noa_XPos</strong> = Noa_XPos/2;
<strong>Noa_YPos</strong> = Noa_XPos;

// Thread Cylinder Text Noa translation and leader creation
//---------------------------------------------------------
CAATpiCreateThreadAnnotationCmd::<strong>RepostionNOA</strong>(piNOACylinder,<strong>Noa_XPos</strong>,<strong>Noa_YPos</strong>);
CAATpiCreateThreadAnnotationCmd::<strong>AddLeaderToNOA</strong>(piNOACylinder, &amp;piNOACylinderLeader);

...</pre>
<p>&nbsp;</p>
<p>The interface <em>CATIDrwAnnotation</em> from the DraftingInterface framework [<a href="#References">2</a>] 
is available on 3D Text NOA Annotations. It can be used to retrieve and manipulate annotation's 
position in annotation plane. The GetDiameter method is preferred over fix values 
when calculating the NOA position as it allows the NOA's position to adapt to 
the diameter of the Thread depending on its size.</p>
<p>The <a href="#Func2">CreateNoaOnAnnotationGeometry</a> 
method defined in this use case is called for each of the thread geometry 
sub-elements, this section concerns the cylinder sub-element.
Once the NOA has been created it is then repositioned by a call to the <a href="#Func4">RepostionNOA</a> 
method and a leader symbol is added to the NOA by calling <a href="#Func5">AddLeaderToNOA</a>.
Both these methods require a pointer to the NOA in question as an input and both 
are methods defined within the use case.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>Thread Lower Plane Text NOA creation</h3>
<pre class="code">// 2.2 Thread Lower Plane Text NOA creation
//=========================================
rc = CAATpiCreateThreadAnnotationCmd::<strong>CreateNoaOnAnnotationGeometry</strong> (<strong>piTPSLowPlane</strong>, piFactElem, &amp;piNOALowerPlane);
<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piNOALowerPlane)
{
// Translating the NOA away from the cylinder, by a distance relative to the size of the thread cylinder
//------------------------------------------------------------------------------------------------------
<strong>piTPSCyl</strong>-&gt;<strong>GetDiameter</strong>(Noa_XPos);
<strong>Noa_XPos</strong> = Noa_XPos/2;
<strong>Noa_YPos</strong> = 0.0;

// Thread Lower Plane Text Noa translation and leader creation
--------------------------------------------------------------
CAATpiCreateThreadAnnotationCmd::<strong>RepostionNOA</strong>(piNOALowerPlane,<strong>Noa_XPos</strong>,<strong>Noa_YPos</strong>);
CAATpiCreateThreadAnnotationCmd::<strong>AddLeaderToNOA</strong>(piNOALowerPlane, &amp;piNOALowerPlaneLeader);

...</pre>
<p>&nbsp;</p>
<p>The interface <em>CATIDrwEltWithLeader</em> from DraftingInterface framework 
[<a href="#References">2</a>] is available on 3D Text NOA Annotations. It can be used 
to retrieve annotation's leaders and to modify them. The GetDiameter method is 
preferred over fix values when calculating the NOA position as it allows the 
NOA's position to adapt to the diameter of the Thread depending on it's size. 
The <a href="#Func2">CreateNoaOnAnnotationGeometry</a> method defined in this 
use case is called for each of the thread geometry sub-elements, this section 
concerns the lower plane sub-element.</p>
<p>Once the NOA has been created it is then repositionned by a call to the <a href="#Func4">RepostionNOA</a> 
method and a leader symbol is added to the NOA by calling <a href="#Func5">AddLeaderToNOA</a>. 
Both these methods require a pointer to the NOA in question as an input and both 
are defined in the use case as internal methods.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step6"></a>Thread Upper Plane Text NOA creation</h3>
<pre class="code">// 2.3 Thread Upper Plane Text NOA creation
//=========================================
rc = CAATpiCreateThreadAnnotationCmd::<strong>CreateNoaOnAnnotationGeometry</strong> (<strong>piTPSUpPlane</strong>, piFactElem, &amp;piNOAUpperPlane);
<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piNOAUpperPlane)
{
// Translating the NOA away from the cylinder, by a distance relative to the size of the thread cylinder
//------------------------------------------------------------------------------------------------------
<strong>piTPSCyl</strong>-&gt;<strong>GetDiameter</strong>(Noa_XPos);
<strong>Noa_XPos</strong> = Noa_XPos/2;
<strong>Noa_YPos</strong> = -Noa_XPos;

// Thread Upper Plane Text Noa translation and leader creation
//------------------------------------------------------------
CAATpiCreateThreadAnnotationCmd::<strong>RepostionNOA</strong>(piNOAUpperPlane,<strong>Noa_XPos</strong>,<strong>Noa_YPos</strong>);
CAATpiCreateThreadAnnotationCmd::<strong>AddLeaderToNOA</strong>(piNOAUpperPlane, &amp;piNOAUpperPlaneLeader);

...</pre>
<p>&nbsp;</p>
<p>The interface <em>CATIDrwTextProperties</em> from the DraftingInterface framework 
[<a href="#References">2</a>] is available on 3D Text NOA Annotations. It can be used 
to retrieve and modify annotation's properties like Size and Font. The 
GetDiameter method is preferred over fix values when calculating the NOA position 
as it allows the NOA's position to adapt to the diameter of the Thread depending 
on its size. The <a href="#Func2">CreateNoaOnAnnotationGeometry</a> method 
defined in this use case is called for each of the thread geometry sub-elements, 
this section concerns the upper plane sub-element.</p>
<p>Once the NOA has been created it is then repositionned by a call to the <a href="#Func4">RepostionNOA</a> 
method and a leader symbol is added to the NOA by calling <a href="#Func5">AddLeaderToNOA</a>. 
Both these methods require a pointer to the NOA in question as an input and both 
are defined in the use case as internal methods.</p>
<p>The <code>Refresh</code> method must be called to update 3D Text visualization.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step7"></a>Semantic Dimension of the thread cylinder's diameter creation</h3>
<pre class="code">// 3.1 Semantic Dimension of the thread cylinder's diameter creation
//==================================================================
rc = CAATpiCreateThreadAnnotationCmd::<strong>CreateSemanticDimensionOnCylinder</strong>(piTPSCyl, piFactElem);


// Retrieve CATITPSFactoryTTRS interfaces
//=======================================
CATITPSFactoryTTRS * piFactTTRS = NULL;

rc = CATTPSInstantiateUseComponent (<strong>DfTPS_ItfTPSFactoryTTRS</strong>, (void**)&amp;piFactTTRS); 

</pre>
<p>&nbsp;</p>
<p>The method <a href="#Func1">CreateSemanticDimensionOnCylinder</a> requires 
that a CATITPSFactoryElementary interface be passed into it.</p>
<p>This factory interface is associated with the annotation set containing the construction 
geometry, used in this use case. The cylinder corresponding to the barrel of the 
thread annotation is the only other argument required for the <strong>CreateSemanticDimensionOnCylinder </strong>
method call.
The following semantic creation exposed below requires a different factory interface: CATITPSFactoryTTRS, and unlike CATITPSFactoryElementary 
retrieving the interface is done by calling CATTPSInstantiateUseComponent rather than 
query interface from the annotation set. </p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step8"></a>Semantic dimension between the two thread planes creation</h3>
<pre class="code">// 3.2 Semantic dimension between the two thread planes creation
//==============================================================

CATITPSDimension * ipiDimension = NULL;
// input translation vecteur definition for the Semantic Dimension translation
//----------------------------------------------------------------------------
double <strong>x</strong> = 0.0;
double <strong>y</strong> = 0.0;

// Translating the dimension away from the cylinder, by a distance relative to the size of the thread cylinder
//------------------------------------------------------------------------------------------------------------
piTPSCyl-&gt;<strong>GetDiameter</strong>(y);
<strong>y</strong> = <strong>y/1.5</strong>;

rc = CAATpiCreateThreadAnnotationCmd::<strong>CreateSemanticDimensionBetweenPlanes</strong>(piTPSLowPlane, piTPSUpPlane, piFactElem, piFactTTRS, &amp;ipiDimension);

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != ipiDimension)
{

CAATpiCreateThreadAnnotationCmd::<strong>RePostionSemanticDimensionLine</strong>(ipiDimension, <strong>x, y</strong>); 

...&nbsp;</pre>
<p>&nbsp;</p>
<p>The method <a href="#Func3">CreateSemanticDimensionBetweenPlanes</a> requires 
that a CATITPSFactoryElementary interface be passed into it.</p>
<p>A GetDiameter method call is once again used to distance the dimension in proportion to the size of the thread</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step9"></a>Epilog</h3>
<p>&nbsp;</p>
<p>The use case finishes when the command ends. A new 3D text is created. Each 
of the text NOA leaders, point to one of the selected thread geometry's 
sub-elements. Semantic dimension annotations on both the selected thread's 
diameter and depth are created. These new annotations appear in the graph 
and in the 3D view.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Func1"></a>CreateSemanticDimensionOnCylinder</h3>
<p><img alt="Create Semantic Dimension On Cylinder" src="images/DimensionCylinderSemantic.png"/></p>
<pre class="code">HRESULT CAATpiCreateThreadAnnotationCmd::<strong>CreateSemanticDimensionOnCylinder</strong>(IUnknown * ipiUnknown, CATITPSFactoryElementary * piFactElem)

....

// 1/ Retrieve the TTRS interface pointer to the thread cylinder's support TTRS
//=============================================================================

// 1.1 Retrieve the CATITPSGeometry interface pointer
//===================================================
rc = ipiUnknown-&gt;QueryInterface(IID_CATITPSGeometry,(void**)&amp;<strong>piTPSGeometry</strong>);

CATITTRSList *piTTRSList = NULL;

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piTPSGeometry)
{
// 1.2 Retrieve the list of TTRS interface pointers
//=================================================
rc = piTPSGeometry-&gt;<strong>GetRepresentedTTRS</strong>(&amp;piTTRSList);

...

CATITTRS * pItem = NULL;

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piTTRSList)
{
// 1.3 Retrieve the first pointer from the TTRS list and assign it to pItem
//=========================================================================
rc = piTTRSList-&gt;<strong>Item</strong>(0, &amp;pItem);

...
</pre>
<p>&nbsp;</p>
<p>At this stage from the list of TTRS elements retrieved from the input 
argument &quot;ipiUnknown&quot; only the first element of the list has been kept.</p>
<p>This single TTRS element is a support type TTRS element by elimination 
because a node type TTRS element by definition links together two TTRS support 
type elements and with here only being one cylinder in this case.</p>
<p>In effect creating a semantic dimension upon a cylinder is done in two 
stages, number one being retrieving the appropriate TTRS support element and 
number two creating a dimension upon this same entity.</p>
<p>&nbsp;</p>
<pre class="code">
// 2/ Semantic Dimension Creation on the thread cylinder
//======================================================

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != pItem)
{

CATTPSDimensionType iDimensionType = CATTPSLinearDimension;
CATTPSLinearDimensionSubType iSubType = CATTPSDiameterDimension;
CATITPSDimension * ipiDimension = NULL;

// 2.1 Semantic Dimension created from the cylinder's support TTRS
//================================================================
rc = p<span class="keyword">if</span>actElem-&gt;<strong>CreateSemanticDimension</strong> (pItem,
				     iDimensionType,
				     iSubType,
				     &amp;ipiDimension);
...
&nbsp;</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Func2"></a>CreateNoaOnAnnotationGeometry</h3>
<p><img alt="Create Noa On Annotation Geometry" src="images/AllSampleNOAText.png"/></p>

<pre class="code">HRESULT CAATpiCreateThreadAnnotationCmd::<strong>CreateNoaOnAnnotationGeometry</strong> (IUnknown * ipiUnknown, CATITPSFactoryElementary * p<span class="keyword">if</span>actElem, CATITPSNoa ** oppiNOA)

...

// 1/ NOA Creation:
// ================

CATITPSGeometry * piTPSGeometry = NULL;

CATITTRSList *piTTRSList = NULL;

// 1.1 Retrieve the CATITPSGeometry interface pointer
//---------------------------------------------------
rc = ipiUnknown-&gt;QueryInterface(IID_CATITPSGeometry,(void**)&amp;piTPSGeometry);

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piTPSGeometry)
{
// 1.2 Retrieve the list of TTRS interface pointers linked with the retrieved geometry
//------------------------------------------------------------------------------------
rc = piTPSGeometry-&gt;<strong>GetRepresentedTTRS</strong>(&amp;piTTRSList);

...

CATITTRS * pItem = NULL;

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piTTRSList)
{
// 1.3 Retrieve the first pointer from the TTRS list and assign it to pItem
//-------------------------------------------------------------------------
rc = piTTRSList-&gt;<strong>Item</strong>(0, &amp;pItem);

...
</pre>
<p>&nbsp;</p>
<p> Once again as was the case for <a href="#Func1">CreateSemanticDimensionOnCylinder</a> the first step of the procedure is 
to retrieve the appropriate TTRS upon which the NOA annotation will be created in this method.</p>
<p>The second stage is creating the aforementioned NOA and defining the attributes which will be associated to them. Seeing as the method implements text NOA, these have mainly text attributes.</p>
<p>These text attributes once defined have to be converted into a suitable type so as to be assigned to the NOA object.</p>
<p>&nbsp;</p>
<pre class="code">
<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != pItem)
{
// 1.4 Create the Text Noa from the TTRS pointer linked with the Noa's geometry
//-----------------------------------------------------------------------------
rc = piFactElem-&gt;<strong>CreateTextNOA</strong> (pItem, oppiNOA);

...

// 2/ Conversion of Text, FlagText and Type from CATUnicodeString to wchar_t
//==========================================================================

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != (*oppiNOA))
{ 

// 2.1 Declaration of the text which will accompany the Noa object
//----------------------------------------------------------------
CATUnicodeString NoaText = &quot;&quot;;
NoaText.<strong>Append</strong>(&quot; Sample NOA text&quot;);

// 2.2 Declaration of the Noa object type
//---------------------------------------
CATUnicodeString NoaType = &quot;&quot;;
NoaType.<strong>Append</strong>(&quot; Sample NOA&quot;);

// 2.3 Declaration of the FlagText which will accompany the Noa object
//-------------------------------------------------------------------
CATUnicodeString NoaFlagText = &quot;&quot;;
NoaFlagText.<strong>Append</strong>(&quot; Sample NOA flagtext&quot;);

// 2.4 Decalration of the wchar_t: Text, FlagText and Type objects as outputs for conversion 
//------------------------------------------------------------------------------------------
wchar_t * pStringText = new wchar_t [1 + NoaText.GetLengthInChar ()];
wchar_t * pStringType = new wchar_t [1 + NoaType.GetLengthInChar ()];
wchar_t * pStringFlagText = new wchar_t [1 + NoaFlagText.GetLengthInChar ()];

// 2.5 Conversion of Text, FlagText and Type from CATUnicodeString to wchar_t
//---------------------------------------------------------------------------
NoaText.<strong>ConvertToWChar</strong> (pStringText);
NoaType.<strong>ConvertToWChar</strong> (pStringType);
NoaFlagText.<strong>ConvertToWChar</strong> (pStringFlagText);

// 3/ Set the created NOA Text, FlagText and Type to the converted wchar_t texts
//==============================================================================

// 3.1 Assign the pStringText Noa sample text to the output pointer of a pointer
//------------------------------------------------------------------------------
rc = (*oppiNOA)-&gt;<strong>SetText</strong> (pStringText);

// 3.2 Assign the pStringText Noa type to the output pointer of a pointer
//-----------------------------------------------------------------------
rc = (*oppiNOA)-&gt;<strong>SetNoaType</strong> (pStringType);

// 3.3 Assign the pStringText sample flag text to the output pointer of a pointer
//-------------------------------------------------------------------------------
rc = (*oppiNOA)-&gt;<strong>SetFlagText</strong> (pStringFlagText);
</pre>
<p>&nbsp;</p>
<p>These converted text attributes have to be assigned twice if not they will not be visible at runtime.</p>
<p>One assignment is for the NOA object itself and the second is to update the representation frame which authorizes the representation of attribute modification.</p> 
<p>&nbsp;</p>
<pre class="code">
// 4/ A second Set Text to store the NOA text that appears on screen, this SetText is responsible for updating the Noa Representation Frame
//=========================================================================================================================================
CATITPSDrawable * piDrawable = NULL;
CATIDftAnnotation *piDftAnnotation = NULL;

// 4.1 Retrieve the CATITPSDrawable interface pointer from the output pointer of a pointer to an Noa, oppiNOA
//-----------------------------------------------------------------------------------------------------------
rc = (*oppiNOA) -&gt; QueryInterface (IID_CATITPSDrawable, (void **)&amp;<strong>piDrawable</strong>);
<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL!= piDrawable)
{ 
// 4.2 Retrieve the CATIDftAnnotation interface pointer
//-----------------------------------------------------
rc = piDrawable -&gt; <strong>GetAnnotation</strong> (&amp;piDftAnnotation);

...

CATIDftComplexText *piCpxText = NULL;

<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL != piDftAnnotation)
{
// 4.3 Retrieve the CATIDftComplexText interface pointer from the retrieved CATIDftAnnotation interface pointer
//-------------------------------------------------------------------------------------------------------------
rc = piDftAnnotation -&gt; QueryInterface (IID_CATIDftComplexText, (void **)&amp;<strong>piCpxText</strong>);

...

<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL!= piCpxText)
{
// 4.4 The second SetText to define the text associated with the Noa so it is stored in the Noa representation frame
//------------------------------------------------------------------------------------------------------------------
piCpxText-&gt;<strong>SetText</strong>(NoaText);

...


// 5/ Visualization Update to render the SetText visible on screen
// ===============================================================
CATIDrwTextProperties * piDrwTextPrp = NULL;

// 5.1 Retrieve the CATIDrwTextProperties interface pointer from the Noa interface pointer
//----------------------------------------------------------------------------------------
rc = (*oppiNOA)-&gt;QueryInterface(IID_CATIDrwTextProperties, (void**) &amp;<strong>piDrwTextPrp</strong>);
<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piDrwTextPrp)
{
// 5.2 Refresh the Draw text Properties to update the onscreen visualisation
//--------------------------------------------------------------------------
piDrwTextPrp-&gt;<strong>Refresh</strong>();

...
&nbsp;</pre>
<p>&nbsp;</p>
<p>To make the changes to the representation frame visible on screen the <strong>Refresh</strong> 
method of CATIDrwTextProperties needs to be called. This method is implicitly 
called when interactive changes are made by the user in a 3DExperience session.</p>
<p>The Unknown type geometry passed into CreateNoaOnAnnotationGeometry as an input argument 
allows multiple types of geometry to be passed into this method. </p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Func3"></a>CreateSemanticDimensionBetweenPlanes</h3>
<p><img alt="Create Semantic Dimension Between Planes" src="images/DimensionBetweenPlanesSemantic.png"/></p>

<pre class="code">HRESULT CAATpiCreateThreadAnnotationCmd::<strong>CreateSemanticDimensionBetweenPlanes</strong>(CATITPSPlane * piLowerPlane,
								     CATITPSPlane * piUpperPlane,
								     CATITPSFactoryElementary * piFactElem,
								     CATITPSFactoryTTRS * piFactTTRS, CATITPSDimension ** oppiDimension)
...
CATSO * ipSO = new CATSO();

// 1/ Retrieve PathElement of Lower plane
//=======================================
CATIBuildPath * piBuildPathLowPlane= NULL;
CATITPSGeometry * piTPSLowerPlaneGeometry = NULL;

// 1.1 Retrieve the TPSLowerPlaneGeometry interface pointer
//---------------------------------------------------------
rc = <strong>piLowerPlane</strong>-&gt;QueryInterface(IID_CATITPSGeometry, (void**)&amp;<strong>piTPSLowerPlaneGeometry</strong>);
<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL != piTPSLowerPlaneGeometry)
{
// 1.2 Retrieve the BuildPathLowPlane interface pointer
//-----------------------------------------------------
rc = piTPSLowerPlaneGeometry -&gt; QueryInterface (IID_CATIBuildPath,(void**) &amp;<strong>piBuildPathLowPlane</strong>);

...

CATPathElement * piPathElementLowPlane = NULL;
<span class="keyword">if</span> (SUCCEEDED(rc) &amp;&amp; NULL != piBuildPathLowPlane)
{
// 1.3 Extract the Path Element PathElementLowPlane interface pointer friom the BuildPathLowPlane interface pointer
//-----------------------------------------------------------------------------------------------------------------
rc = piBuildPathLowPlane -&gt; <strong>ExtractPathElement</strong> (NULL,&amp;piPathElementLowPlane);

...

// 2/ Retrieve PathElement of Upper plane
//=======================================
CATIBuildPath * piBuildPathUpperPlane = NULL;
CATITPSGeometry * piTPSUpperPlaneGeometry = NULL;

// 2.1 Retrieve the TPSLowerPlaneGeometry interface pointer
//---------------------------------------------------------
rc = <strong>piUpperPlane</strong>-&gt;QueryInterface(IID_CATITPSGeometry, (void**)&amp;<strong>piTPSUpperPlaneGeometry</strong>);
<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL != piTPSUpperPlaneGeometry)
{
// 2.2 Retrieve the BuildPathUpperPlane interface pointer
//-------------------------------------------------------
rc = piTPSUpperPlaneGeometry -&gt; QueryInterface (IID_CATIBuildPath,(void**) &amp;<strong>piBuildPathUpperPlane</strong>);

...

CATPathElement * piPathElementUpperPlane = NULL;
<span class="keyword">if</span> (SUCCEEDED(rc) &amp;&amp; NULL != piBuildPathUpperPlane)
{
// 2.3 Extract the Path Element PathElementUpperPlane interface pointer friom the BuildPathUpperPlane interface pointer
//---------------------------------------------------------------------------------------------------------------------
rc = piBuildPathUpperPlane -&gt; <strong>ExtractPathElement</strong> (NULL,&amp;piPathElementUpperPlane);

...


// 3/ Semantic Dimension creation:
// ===============================

// 3.1 Add paths context of Upper plane and Lower plane to ipSO the CATSO interface pointer
//-----------------------------------------------------------------------------------------
<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != piPathElementLowPlane &amp;&amp; NULL != piPathElementUpperPlane )
{
// 3.2 Add Upper Plane Element Path to ipSO the CATSO interface pointer
//---------------------------------------------------------------------
rc = ipSO-&gt;AddElement(<strong>piPathElementUpperPlane</strong>);
<span class="keyword">if</span>(SUCCEEDED(rc))
{
// 3.3 Add Lower Plane Element Path to ipSO the CATSO interface pointer
//---------------------------------------------------------------------
rc = ipSO-&gt;AddElement(<strong>piPathElementLowPlane</strong>);
}
}

...

// 4/ TTRS Creation:
//==================

CATITTRS * <strong>ThreadPlanesTTRS</strong> = NULL;

<span class="keyword">if</span>(SUCCEEDED(rc) &amp;&amp; NULL != ipSO)
{ 
CATMmrTTRSType NodeTypeNOA = CATMmrNodeTTRS;
IUnknown * ipiReferenceObject= NULL;
CATBoolean iDisplayErrorIfFailed = TRUE;

// 4.1 TTRS Creation from the CATSO interface pointer: ipSO containing the upper and lower PathElements
//-----------------------------------------------------------------------------------------------------
rc = piFactTTRS-&gt;GetTTRS(ipSO, &amp;<strong>ThreadPlanesTTRS</strong>, NodeTypeNOA, ipiReferenceObject, iDisplayErrorIfFailed);

...

// 5/ Semantic Dimension Creation between the thread planes:
//==========================================================

...

CATTPSDimensionType iDimensionType = CATTPSLinearDimension;
CATTPSLinearDimensionSubType iSubType = CATTPSDistanceDimension;

// 5.1 Semantic Dimension Creation from the TTRS containing CATMmrSupportTTRS of both planes and a CATMmrNodeTTRS
//---------------------------------------------------------------------------------------------------------------
rc = piFactElem-&gt;<strong>CreateSemanticDimension</strong> (ThreadPlanesTTRS,iDimensionType,iSubType,oppiDimension);

...
&nbsp;</pre>
<p>&nbsp;</p>
<p>Creates TTRS from ipSO the CATSO interface pointer and which includes both Upper and Lower Plane path elements.
ThreadPlanesTTRS, the output TTRS contains both TTRS CATMmrSupportTTRS from the Planes and a CATMmrNodeTTRS
linking the two together:</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Func4"></a>RepostionNOA</h3>
<pre class="code">HRESULT CAATpiCreateThreadAnnotationCmd::<strong>RepostionNOA</strong>(CATITPSNoa * piNOA, double x, double y)

...

// 1/ Retrieve CATIDftAnnotation interface for the NOA
// ===================================================

CATIDftAnnotation * piDftAnnotation = NULL;

// 1.1 Retrieve CATIDftAnnotation interface
//----------------------------------------- 
rc = piNOA-&gt;QueryInterface(IID_CATIDftAnnotation, (void **)&amp;<strong>piDftAnnotation</strong>);

// 2/ Repositioning of Noa by translation along VecteurDelta
// ==========================================================

<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL != piDftAnnotation)
{
// 2.1 Defintion of the translation vector: VectorDelta
//-----------------------------------------------------
double DeltaX = x;
double DeltaY = y;
double <strong>VectorDelta</strong> [2] = { DeltaX, DeltaY };

// 2.2 NOA translation according to VectorDelta
//---------------------------------------------
piDftAnnotation-&gt;<strong>Move</strong>(VectorDelta);

...</pre>
<p>&nbsp;</p>
<p>The interface CATIDftAnnotation from the DraftingInterface framework [<a href="#References">2</a>] is available on NOA Text Annotations.
It can be used to retrieve and modify annotation properties, in this case position.
The Refresh method must be called to update 3D Text visualization.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Func5"></a>AddLeaderToNOA</h3>
<pre class="code">HRESULT CAATpiCreateThreadAnnotationCmd::<strong>AddLeaderToNOA</strong>(CATITPSNoa * piNOA, CATIDftLeader ** oppiLeader)
{

...

// 1/ Creation of a leader to the input NOA
// ========================================

CATIDftElementWithLeader * piDftElementWithLeader = NULL;

int iAnchorOnElement = 1;
double iEndPoint [2] = {0.0,0.0};

// 1.1 Retrieve CATIDftElementWithLeader interface for the NOA
//------------------------------------------------------------
rc = piNOA-&gt;QueryInterface(IID_CATIDftElementWithLeader, (void**)&amp;<strong>piDftElementWithLeader</strong>);

<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL != piDftElementWithLeader)
{

// 1.2 Add leader to input Noa interface pointer AND output a pointer of a pointer to the leader created
//------------------------------------------------------------------------------------------------------
piDftElementWithLeader-&gt;<strong>AddLeader</strong>(iAnchorOnElement,iEndPoint,oppiLeader);

...</pre>
<p>&nbsp;</p>
<p>The interface CATIDrwEltWithLeader from the DraftingInterface framework [<a href="#References">2</a>] is available on 3D Text 
NOA Annotations. It can be used to retrieve annotation's leaders and to modify them, 
here its <strong>AddLeader</strong> method is used. The NOA which is passed in 
as an input argument serves as the anchor point for the leader.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-===>
<h3><a name="Func6"></a>RePostionSemanticDimensionLine</h3>
<pre class="code">HRESULT CAATpiCreateThreadAnnotationCmd::<strong>RePostionSemanticDimensionLine</strong>(CATITPSDimension * ipiDimension, double x, double y)
{
...

// 1/ Reposition the semantic dimension input according to the input coordonnates
//=============================================================================== 

CATIDrwDimDimension * piDrwDim = NULL;

// 1.1 Retrieve the CATIDrwDimDimension interface pointer for the Dimension
//-------------------------------------------------------------------------
rc = ipiDimension-&gt;QueryInterface(IID_CATIDrwDimDimension, (void **)&amp;<strong>piDrwDim</strong>);
<span class="keyword">if</span> ( SUCCEEDED(rc) &amp;&amp; NULL != piDrwDim)
{
// 1.2 Defines which part of the dimension should be moved, &quot;2&quot; corresponds to &quot;Dimension line&quot;
//----------------------------------------------------------------------------------------------------------------
int <strong>iSubPart</strong> = 2;

CATMathPoint2D ptPos;
ptPos.<strong>SetCoord</strong>( x, y);

// 1.3 Move the dimension line to the input coordinates
//-----------------------------------------------------
piDrwDim-&gt;<strong>MoveValue</strong>(ptPos, iSubPart);

...
</pre>
<p>&nbsp;</p>
<p>The repositioning of the semantic dimension unlike the NOA repostionning is 
not done by computing a translation vector, here it is done by defining new 
coordinates for the Semantic Dimension. The <strong>iSubPart</strong> argument dictates which parts of the semantic dimension are to be moved. This redefinition of coordinates is done by calling 
the <strong>SetCoord</strong> method from CATMathPoint2D. The approach is 
slightly different yet the resulting displacement is the same, displacement 
which takes places upon calling <strong>MoveValue</strong>  from the CATIDrwDimDimension 
interface.</p>
<p>&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This use case shows what the constructed geometry of a thread is made up of. While demonstrating
how to create annotations upon thread geometry representations, Non-Object-Annotations as well as
semantic dimension annotations.</p>
<p>The importance of knowing how to retrieve specific TTRS elements, is also 
demonstrated.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td>
	<a href="../CAADriDrafting/CAADriTaDraftingOverView.htm">
	An Overview of the Drafting Modeler</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td>
	<a href="CAATpiTaTPSOverview.htm">
	A Technological Product Specification Overview</a></td>
	</tr>

</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [May 2014]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
