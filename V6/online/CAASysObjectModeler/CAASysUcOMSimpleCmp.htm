<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Creating and Instantiating a Component</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Creating and Instantiating a Component</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article shows how to create and instantiate a CAA component.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAASysComponent Use Case</a>
				<ul>
					<li><a href="#What">What Does CAASysComponent Do</a></li>
					<li><a href="#How">How to Launch CAASysComponent</a></li>
					<li><a href="#Where">Where to Find the CAASysComponent Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case is intended to show you how to create a CAA component that isolates 
you implementation from client applications and how client application can instantiate 
it. The component represents an object with two facets, each of them being supported 
using an interface:</p>
<ol>
	<li>The first facet is described in ths article. It is the ability for the component 
		to be instantiated by client applications thanks to implementing the <em>
		CATICreateInstance</em> interface and its single method <code>CreateInstance</code> 
		in a code extension. Client application instantiate the component using 
		the <code>CATInstantiateComponent</code> global function.</li>
	<li>The second facet is the ability to print a message on the screen thanks 
		to an interface created for the use case and named <em>CAAISysMyInterface</em>. 
		You could easily find other facets in the industrial domains you deal with 
		to create a more realistic component that implements a lot more interfaces. 
		creating this interface and its implementation is not described. You can 
		refer to other articles dealing with this topic [<a href="#References">1</a>] 
		[<a href="#References">2</a>].</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAASysComponent Use Case</h2>
<p>CAASysComponent is a use case of the CAASystem.edu framework that illustrates 
the System framework capabilities.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAASysComponent Do</h3>
<p>This use case shows a template of the code to write to create a basic component 
and to enable client applications to instantiate it, retrieve a pointer to an interface 
this component implements, use this pointer to call methods, and navigate among 
the other possible interfaces the component implements.</p>
<p>
<img alt="An Object Modeler Basic Component" height="298" src="images/CAASysOMSimpleCmp.gif" width="488"/></p>
<p>This component is made of the <em>CAASysComponent</em> main class, and of the
<em>CAAESysCreateInstanceForComponent</em> extension class. <em>CAAESysCreateInstanceForComponent</em> 
implements the<em> CATICreateInstance</em> interface to enable the component creation. 
It is also made of the <em>CAAESysMyInterfaceForComponent</em> class that implements 
the <em>CAAISysMyInterface</em> interface. Other interfaces could be implemented 
to replace the latter and make a more realistic component, but have uselessly complicated 
the use case.</p>
<p>A main program instantiates the component and retrieves a pointer to this <em>
CAAISysMyInterface</em> interface to show what the client should do.</p>
<p><strong>Note</strong>: Extension links are shown as dashed arrows. Other links 
are shown as usual.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAASysComponent</h3>
<p>You first need to build CAASysComponent. To do this, you will need to set up 
the build time environment, then compile the four CAASysComponent*.m modules along 
with their prerequisites as described in [<a href="#References">5</a>]. Launch CAASysComponentCreate 
itself.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAASysComponent Code</h3>
<p>The CAASysComponent.m use case is made of four modules:</p>
<p><code>InstallRootFolder\CAADoc\CAASystem.edu\CAASysComponent*.m</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">5</a>] is the 
folder where the API CD-ROM is installed.</p>
<p>These modules are:</p>
<ol>
	<li>CAASysComponentImpl.m that contains the component main class and the extension 
		class that implements CATICreateInstance</li>
	<li>CAASysComponentCreate.m that contains the main program that instantiates 
		the component</li>
	<li>CAASysComponentInt.m that contains the <em>CAAISysMyInterface</em> interface 
		and its TIE, the interface header being located in the PublicInterfaces 
		folder of the CAASystem.edu framework</li>
	<li>CAASysComponentExt that contains the extension class that implements <em>
		CAAISysMyInterface</em></li>
</ol>
<p>The first two modules are described in this article. The two others are not described. 
Refer to their source code.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>To create a component such as <em>CAASysComponent</em>, there are nine main steps:</p>
<table>
	<colgroup span="3" valign="top">
	</colgroup>
	<tr>
		<th>#</th>
		<th>Step</th>
		<th>Where</th>
	</tr>
	<tr>
		<td>1</td>
		<td><a href="#Step1">Create the <em>CAASysComponent</em> component main 
		class header file</a></td>
		<td>CAASysComponent.m\LocalInterfaces\CAASysComponent.h</td>
	</tr>
	<tr>
		<td>2</td>
		<td><a href="#Step2">Create the <em>CAASysComponent</em> component main 
		class source file</a></td>
		<td>CAASysComponent.m\src\CAASysComponent.cpp</td>
	</tr>
	<tr>
		<td>3</td>
		<td><a href="#Step3">Create the <em>CAAESysCreateInstanceForComponent</em> 
		extension class header file</a></td>
		<td>CAASysComponent.m\LocaInterfaces\CAAESysCreateInstanceForComponent.h</td>
	</tr>
	<tr>
		<td>4</td>
		<td><a href="#Step4">Create the <em>CAAESysCreateInstanceForComponent</em> 
		extension class source file</a></td>
		<td>CAASysComponent.m\src\CAAESysCreateInstanceForComponent.cpp</td>
	</tr>
	<tr>
		<td>5</td>
		<td><a href="#Step5">Update the interface dictionary</a></td>
		<td>CAASystem.edu.dico file in CNext\code\dictionary</td>
	</tr>
	<tr>
		<td>6</td>
		<td><a href="#Step6">Instantiate and use the component</a></td>
		<td>CAASysComponent.m\src\CAASysMain.cpp</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Creating the CAASysComponent Header File</h3>
<pre class="code">#include &quot;CATBaseUnknown.h&quot;   //Needed to derive from CATBaseUnknown

class  CAASysComponent : public CATBaseUnknown
{
  // Used in conjunction with CATImplementClass in the .cpp file
  <strong>CATDeclareClass</strong>;

  public:

    CAASysComponent();
    virtual ~CAASysComponent();

  private:

    // Copy constructor, not implemented
    // Set as private to prevent from compiler automatic creation as public.
    CAASysComponent(const CAASysComponent &amp;iObjectToCopy);

    // Assignment operator, not implemented
    // Set as private to prevent from compiler automatic creation as public.
    CAASysComponent &amp; operator = (const CAASysComponent &amp;iObjectToCopy);

};</pre>
<p>The <em>CAASys</em><em>Component</em> class C++-derives from <em>CATBaseUnknown</em>. 
The <code>CATDeclareClass</code> macro declares that the class <em>CAASys</em><em>Component</em> 
belongs to a component. Note that the copy constructor is set as private. The class 
has a constructor and a destructor only.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Creating the CAASysComponent Source File</h3>
<pre class="code">#include &quot;CAASysComponent.h&quot;

//C++ standard library
#include &quot;iostream.h&quot;

//------------------------------------------------------------------------------------

// To declare that the class is a component main class 
<strong>CATImplementClass(CAASysComponent, Implementation, CATBaseUnknown, CATNull);</strong>

//------------------------------------------------------------------------------------

CAASysComponent::CAASysComponent() 
{
  cout &lt;&lt; &quot;CAASysComponent::CAASysComponent&quot; &lt;&lt; endl;
}

CAASysComponent::~CAASysComponent()
{
  cout &lt;&lt; &quot;CAASysComponent::~CAASysComponent&quot; &lt;&lt; endl;
}</pre>
<p>The <code>CATImplementClass</code> macro declares that the <em>CAASysComponent</em> 
class is a component main class thanks the <code>Implementation</code> keyword, 
and OM-derives [<a href="#References">6</a>] from <em>CATBaseUnknown</em>. Any component 
main class declared as an <code>Implementation</code> must C++-derive and OM-derive 
from the same class, that must either be <em>CATBaseUnknown</em> or another component 
main class. The component main class doesn't implement any interface, but it could.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Creating the CAAESysCreateInstanceForComponent Extension 
Class Header File</h3>
<pre class="code">#include &quot;CATBaseUnknown.h&quot;   //Needed to derive from CATBaseUnknown

class CAAESysCreateInstanceForComponent : public CATBaseUnknown
{
  // Used in conjunction with CATImplementClass in the .cpp file
  <strong>CATDeclareClass</strong>;

  public:

    CAAESysCreateInstanceForComponent();
    virtual ~CAAESysCreateInstanceForComponent();

    // CATICreateInstance 
    // -------------------

    virtual HRESULT __stdcall CreateInstance(void **oppv);

  private:

    // Copy constructor, not implemented
    // Set as private to prevent from compiler automatic creation as public.
    CAAESysCreateInstanceForComponent(const CAAESysCreateInstanceForComponent &amp;iObjectToCopy);

    // Assignment operator, not implemented
    // Set as private to prevent from compiler automatic creation as public.
    CAAESysCreateInstanceForComponent &amp; operator = (const CAAESysCreateInstanceForComponent &amp;iObjectToCopy);

};</pre>
<p>The <em>CAAESysCreateInstanceForComponent</em> extension class derives from
<em>CATBaseUnknown</em>. The <code>CATDeclareClass</code> macro declares that the 
class <em>CAAESysCreateInstanceForComponent</em> belongs to a component. The class 
has a constructor and a destructor, and declares the <code>CreateInstance</code> 
method which is the only method of the <em>CATICreateInstance</em> interface. Note 
that the copy constructor and the assignment operator are set as private. This is 
very important for extensions. Since extensions must never be directly instantiated 
by client applications, this prevents the compiler from creating the copy constructor 
and the assignment operator as public without you know. They are not implemented 
in the source file.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>Creating the CAAESysComponent Extension Class Source File</h3>
<pre class="code">//Local Framework
#include &quot;CAAESysCreateInstanceForComponent.h&quot;

//C++ standard library
#include &quot;iostream.h&quot;

// The class to create
#include &quot;CAASysComponent.h&quot;

// System Framework
#include &lt;CATErrorDef.h&gt;

//-----------------------------------------------------------------------------------
// To create the TIE object
#include &quot;TIE_CATICreateInstance.h&quot;
TIE_CATICreateInstance(CAAESysCreateInstanceForComponent);

// To declare that the class is a Code extension of CAASysComponent
//
<strong>CATImplementClass(CAAESysCreateInstanceForComponent, CodeExtension, CATBaseUnknown, CAASysComponent);</strong>
// 
// To declare that CAAESysCreateInstanceForComponent implements CATICreateInstance, insert 
// the following line in the interface dictionary:
//
//    CAASysComponent CATICreateInstance  libCAASysComponentImpl
//
//------------------------------------------------------------------------------------

CAAESysCreateInstanceForComponent::CAAESysCreateInstanceForComponent() 
{
  cout &lt;&lt; &quot;CAAESysCreateInstanceForComponent::CAAESysCreateInstanceForComponent&quot; &lt;&lt; endl;
}

//------------------------------------------------------------------------------------

CAAESysCreateInstanceForComponent::~CAAESysCreateInstanceForComponent()
{
  cout &lt;&lt; &quot;CAAESysCreateInstanceForComponent::~CAAESysCreateInstanceForComponent&quot; &lt;&lt; endl;
}

//------------------------------------------------------------------------------------

HRESULT __stdcall CAAESysCreateInstanceForComponent::CreateInstance(void ** oppv)
{
   CAASysComponent * pt = new CAASysComponent();
   if (NULL == pt) return(E_OUTOFMEMORY);

   *oppv = (void *)pt;

   return(S_OK);
}</pre>
<p>The <em>CAAESysCreateInstanceForComponent</em> class states that it implements 
the <em>CATICreatInstance</em> interface thanks to the <code>TIE_CATICreateInsatnce</code> 
macro. This extension class is dedicated to this component, and the <code>CATImplementClass</code> 
macro declares that the <em>CAAESysCreateInstanceFor</em><em>Component</em> class 
is code extension class, thanks to the <code>CodeExtension</code> keyword, and that 
it extends the component whose main class is <em>CAASys</em><em>Component</em>. 
The third parameter must always be set to <em>CATBaseUnknown</em>, makes no sense, 
and is unused for extensions. The <code>CreateInstance</code> method instantiates 
the <em>CAASys</em><em>Component</em> component main class. This method is called 
by the <code>CATInstantiateComponent</code> global function that is used by client 
applications to instantiate the component [<a href="#References">4</a>].</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>Updating the Interface Dictionary</h3>
<pre class="code">...
CAASysComponent CATICreateInstance  libCAASysComponentImpl
...</pre>
<p>The interface dictionary declares that the <em>CAASysComponent</em> component 
implements the <em>CAATICreateInstance</em> interface and that the code to load 
into memory to use these interfaces is located in the libCAASysComponentImpl.m shared 
library or DLL. Note that the component main class name is used to refer to the 
component in the interface dictionary, and never the extension class names. Note 
also that the shared library or DLL to associate with the component/interface pair 
is the one that contains the code created by the call to the TIE macro (This is 
generally the same library than the one that contains the interface implementation 
code, since the TIE macro is usually included in the extension class source file.) 
This is because when a client asks a component for an interface pointer, the TIE 
class is instantiated first, and it either retrieves the existing instance of the 
appropriate extension class, or otherwise instantiates it.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step6"></a>Instantiating and Using the Component</h3>
<pre class="code">// System Framework
#include &quot;CATErrorDef.h&quot;              // For the FAILED macro
#include &quot;CATInstantiateComponent.h&quot;  // For the global function to create the component
#include &quot;CAAISysMyInterface.h&quot;       // an interface implemented by the component

// C++ standard library    
#include &lt;iostream.h&gt;     // To display traces

int main()
{

  cout &lt;&lt; &quot;The CAASysComponentCreate Sample begins .....&quot;&lt;&lt; endl;

 
  // -------------------------------------------------------------------------------
  // Creates the component and retrieves a CAAISysMyInterface interface pointer
  // -------------------------------------------------------------------------------

  CAAISysMyInterface * piSysMyInterfaceOnComponent = NULL; 
  HRESULT rc = <strong>::CATInstantiateComponent</strong>( &quot;CAASysComponent&quot;,  
                                         IID_CAAISysMyInterface,
                                         (void**)&amp;piSysMyInterfaceOnComponent);   
                                          
  if ( FAILED (rc) )
  {
       cout &lt;&lt; &quot; Problem in the component Creation&quot;&lt;&lt; endl;
       return 1 ;
  }

  //-----------------------------------------------------------------------
  //The component is created, and we can use the returned interface pointer 
  //-----------------------------------------------------------------------
  piSysMyInterfaceOnComponent-&gt;Print();

  //-----------------------------
  // Pointer no any longer needed
  //-----------------------------
  piSysMyInterfaceOnComponent-&gt;Release();
  piSysMyInterfaceOnComponent = NULL;


  cout &lt;&lt; endl &lt;&lt; &quot;The CAASysComponentCreate Sample is finished.&quot;&lt;&lt; endl &lt;&lt; endl ;

  return 0 ;
}
</pre>
<p>The <em>CAASysComponent</em> component is instantiated using the <code>CATInstantiateComponent</code> 
global function to which the following parameters should be passed:</p>
<table>
	<tr>
		<td><code>CAASysComponent</code></td>
		<td>The component identifier that is also the component main class name</td>
	</tr>
	<tr>
		<td><code>IID_CAAISysMyInterface</code></td>
		<td>The IID of the interface with which the client application wants to 
		handle the component and to which a pointer is asked</td>
	</tr>
	<tr>
		<td><code>piSysMyInterfaceOnComponent</code></td>
		<td>The pointer to that interface</td>
	</tr>
</table>
<p>Once the component is instantiated and handled using a pointer to the requested 
interface, the client application can go on using the component. No link is necessary 
between the client application and the component code. <code>CATInstantiateComponent</code> 
and the implemented interfaces isolates these two codes and are used as a contract 
between them to ensure that they will go on running as planned, and that modification 
to the component's code will not affect the client application and will ensure run 
time compatibility.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This use case shows how to create a factory for a component. The main class declares 
the component inheritance and must C++-derive and OM-derive from <em>CATBaseUnknown</em> 
or from another component main class. The extension class that implement the <em>
CAATICreateInstance</em> interface must C++-derive from <em>CATBaseUnknown</em>, 
while OM-inheritance makes no sense for it. The interface dictionary declares the 
correspondence between the component, the interfaces it implements, and the shared 
library or DLL to load for each interface. <code>CATInstantiateComponent</code> 
is used to instantiate the component and returns a pointer to the interface requested 
by the client application.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td><a href="CAASysTaOMCreatingComponent.htm">Creating Components</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAASysTaOMCreatingInterfaces.htm">Creating Interfaces</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td><a href="CAASysUcOMCreatingCmpFact.htm">Creating a Component Factory</a></td>
	</tr>
	<tr>
		<td>[4]</td>
		<td><a href="CAASysUcOMUsingCmp.htm">Using Components</a></td>
	</tr>
	<tr>
		<td>[5]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[6]</td>
		<td><a href="CAASysTaOMInheritance.htm">Object Modeler Inheritances</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [May 2002]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
