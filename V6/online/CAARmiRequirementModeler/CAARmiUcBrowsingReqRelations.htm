<html>
	<head>
		<title>Browsing with Modeler APIs</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<meta content="Microsoft FrontPage 12.0" name="GENERATOR">
		<meta content="FrontPage.Editor.Document" name="ProgId">
		<link href="../CAADocStyleSheets/caav5.css" type="text/css" rel="Stylesheet">
         <script language="JavaScript" src="../CAADocJavaScript/submit.js">
		</script>

                <style type="text/css">
.style2 {
	font-family: "Courier New", Courier;
	font-size: 9pt;
	color: #976970;
}
.style3 {
	text-align: left;
}
</style>

                </head>
		
	<body  >
<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Browsing Requirement Relations</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>


				<!---------------------------------comment------------------------------------->
		<table class="abstract">
			<tr>
				<td>
					<h2>Abstract</h2>
					<p>This Use Case basically browses the Relations in a Requirement Model with 
					Requirement Modeler API's . The Use Case details the steps involved in the CAA Customization to browse through a 
					Requirement Relations, using the CATRequirementModelerUseItf framework (restricted to the 
					Requirement Modeler) CAA Exposition.</p>
				<ul>
							<li><A href="#Learn">What You Will Learn 
                                With This Use Case</A>
							<li><a href="#UseCase">The 
                                CAARmiBrowsingRequirementRelationsUse Case</a>
							<ul type="disc">
								<li><a href="#What">What Does 
                                        CAARmiBrowsingRequirementRelations Do</a>
								<li><a href="#How">How to Launch 
								CAARmiBrowsingRequirementRelations
								</a>
								<li><a href="#Where">Where to Find the 
								CAARmiBrowsingRequirementRelations Code</a>
								</li>
							</ul>
							<li><A href="#Step">Step-by-Step</A>
							<li><A href="#InShort">In Short</A>
							<li><A href="#References">References</A>
							</li>
						</ul>
				</td>
			</tr>
		</table>
		<!---------------------------------comment------------------------------------->
		<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>Most importantly, the user browses the Relations of a Requirement model. It means showing, from top to leaves, all the :</p>
<ul><li>Requirement Relations</li>
<li>Relations between the Child Requirement Entities under them</li>
	<li>Recursive browsing of the Requirement Relations</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script> 
		<!---------------------------------comment------------------------------------->
		<h2><a name="UseCase"></a>The CAARmiBrowsingRequirementRelations
        Use Case</h2>
		<p><code><a>CAARmiBrowsingRequirementRelations</a></code> is a use case of the 
        <code><a>CAAReqModelerUseItf.edu</a></code> framework that 
			illustrates <code>VPLMRequirementModelerItf</code> framework capabilities.</p>
		<script type="text/javascript">insertLinkToTop();</script> 
		<!---------------------------------comment------------------------------------->
		<h3><a name="What"></a>What Does CAARmiBrowsingRequirementRelations
        Do</h3>
<p>The input for this Use Case is a <span class="style2">Requirement</span> <code>
Model</code>&nbsp;as depicted below. </p>

<table>
	<caption>Fig.1 Requirement Data Model</caption>
	<tr>
		<td>
		<img alt="" src="images/CAARmiReqDataModel1.jpg" width="238" height="297"></td>
	</tr>
</table>

<p>It consists of a root Requirement Specification object <span class="style2">
Root_Req_Spec ---</span>.</p>
<p>The Root aggregates <span class="style2">
Chapter_X ---</span> and <span class="style2">Req_A ---</span>, the Requirement Entities.</p>
<p>These Entities in turn aggregates other Requirement Entities
<span class="style2">Comment_X1 and Comment_Main </span>of type 'Chapter', and <span class="style2">Req_X1 and SubReq_A1 </span> of type 'Requirement'.</p>
<p>All these above mentioned entities are connected by Relations. To know more 
about types of Relation between entities, please refer [<a href="#References">3</a>].</p>
<p><strong>NOTE</strong>: The above Data Model can be created on Requirements 
Central i.e. Web Apps side. Then you can query the Root node of the data model 
in CATIAV6 session. Please refer to the use-case [<a href="#References">4</a>] 
to understand how to open Requirement Root node in V6 session.</p>
<p>The process to retrieve a PLM Component from the database, essentially 
requires two inputs</p>
<ul>
	<li>A list of IDSet attribute-values, provided as an input for UC execution</li>
	<li>PLMType to determine the Knowledge type of the Requirement reference 
	to be browsed</li>
</ul>
<p>The Use Case thus retrieves an Identificator of the Requirement Specification, in the 
underlying database. It next loads it in session, in <strong>Authoring</strong> 
mode, which essentially loads in session all the Requirement Entities and 
Relations. </p>
<table>
	<caption align="center"><a name="Fig.2"></a>Fig. 2 Requirement Model Browse 
	Relations Output</caption>
	<tr>
		<td>
		<img alt="" src="images/CAARmiBrowseReqRelations1.jpg" width="561" height="494"></td>
	</tr>
</table>
	
<p>The Use Case browses input data model of Requirement objects and outputs 
Relations in its hierarchy as depicted in Fig.2. above. The aim of the use-case is to browse through 
the Relations of the given Requirement Data model and gives 'Type' of Relation 
as output. But along with the Relations, the use-case also shows the Requirement 
Entities connected by that Relation.</p>
<script type="text/javascript">insertLinkToTop();</script> 
		<h3><a name="How"></a>How to Launch CAARmiBrowsingRequirementRelations</h3>
		<p>To launch <code>CAARmiBrowsingRequirementRelations</code>, you will need to set up the build time environment, 
			then compile <code>CAARmiBrowsingRequirementRelations<b> </b></code>along with its prerequisites, set up the run time 
			environment, and then execute the use case.&nbsp;</p>
<p>To
launch the use case execute the command:</p>
<p><code> <a>mkrun -c &quot;</a>CAARmiBrowsingRequirementRelations </code><a><code><i>Repository Server User Password SecurityCtx 
PLMType iAllAttributes&nbsp;IDSetAttribute1 IDSetAttributeValue1 [IDSetAttribute1* IDSetAttributeValue1* ...]</i>&quot;</code></a> </p>
<p>where:</p>

<table class="border1"  id="table13" >
  <tr>
    <th class="style3"><b>Repository</b></th>
    <td><script type="text/javascript">insertRepository();</script>TST</td>
  </tr>
  <tr>
    <th class="style3"><b>Server</b></th>
    <td>The name and port of the server as name:port_number/RootURI</td>
  </tr>
  <tr>
    <th class="style3" ><b>User</b></th>
    <td>The user identifier</td>
  </tr>
  <tr>
    <th class="style3" ><b>Password</b></th>
    <td >The user password</td>
  </tr>
  <tr>
    <th class="style3"><b>SecurityCtx</b></th>
    <td>A string representing the security context (Role.Organization.Project). Choose Role as Reviewer ( as the use case does not modify the PLM Data) </td>
  </tr>
    <tr>
    <th class="style3"><b>PLMType</b></th>
    <td>A String representing the PLMType For Requirement Reference: Requirement 
	Specification or Requirement (depending on the root object type)</td>
  </tr>
<tr>
    <th class="style3" ><b>AllAtributes</b></th>
    <td>Yes (val=1) ,  No (val=0) </td>
  </tr>

	<tr>
    <th height="35" class="style3">IDSetAttribute1*<td height="16">First Identification Set(IDSet) 
	attribute for the Requirement Reference to browse</td>
  </tr>
		
		 <tr>
    <th height="35" class="style3">IDSetAttributeValue1*<td height="16">First IDSet attribute 
	value for the Requirement Reference to browse</td>
  </tr>
 
  </table>






<p align="left">* We could have several such Attribute-Value set. The count is 
determined by the IDSet attributes defined by the PLMType of the 
Requirement Reference to be browsed.</p>
<script type="text/javascript">insertLinkToTop();</script> 

<h3><a name="Where"></a>Where to Find the CAARmiBrowsingRequirementRelations
        Code</h3>
<p>The <code>CAARmiBrowsingRequirementRelations<b> </b></code>use case is defined at the 
location:</p>
<table>
  <tr>
    <td><code>InstallRootDirectory\CAADoc\CAAReqModelerUseItf.edu\CAARmiBrowsingRequirementRelations.m\</code></td>
  </tr>
</table>
<p>where <code><a>InstallRootDirectory</a></code>  [<a href="#References">1</a>]
is the directory where the CAA CD-ROM
is installed.</p>
		<script type="text/javascript">insertLinkToTop();</script> 
		<h2><a name="Step"></a>Step-by-Step</h2>
	 
		<p>Following are the main steps in <code><a>
		CAARmiBrowsingRequirementRelations</a></code>:</p>
<ol>
  <li><a href="#Prolog">Prolog</a></li>
   <li><a href="#Retrieve the Functional Ref">Retrieve Requirement Reference 
	to browse from underlying database</a></li>
	<li><a href="#Browse the Functional Structure">Browse the Requirement Reference</a></li>
	<li>
	<p style="line-height: 100%; margin-top: 0"><a href="#Epilog">Epilog</a>
	</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!---------------------------------comment------------------------------------->

<!---------------------------------comment------------------------------------->

<!---------------------------------comment------------------------------------->

<h3><a name="Prolog"></a>Prolog&nbsp;</h3>
<p>The <code>CAARmiBrowsingRequirementRelations <b> </b></code>use case, to begin with, 
creates a PLM Session. Its defined by the repository to be connected to, server, 
user, password and a Security Context. The Security context primarily defines a 
role with which the user is logged into the current session. In the current Use 
Case, since it simply browses through a Requirement Model hierarchy, it does not 
involve any modification of the PLM data. The article &quot;<strong>Creating a Basic PLM Batch</strong>&quot; [<a href="#References">2</a>] 
delves further deeper into this subject.</p>
<script type="text/javascript">insertLinkToTop();</script>

<h3><a name="Retrieve the Functional Ref"></a>Retrieve the Requirement 
Specification to browse, from an underlying database</h3>
<p>To begin with, we retrieve from the underlying database, the Requirement 
Specification for browsing. The query to an underlying database for a PLM Component is 
built with primarily two inputs</p>
<ul>
	<li>An attribute-value list </li>
	<li>The PLMType of the PLM Component being queried</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<h4><a name="Build an IDSet"></a>Build an Identification Attribute-Value set</h4>
<p>A PLM Type essentially defines a set of attributes, to uniquely identify it 
in the underlying database. These are referred to as IDSet attributes. A list of 
such attribute-value set, combined with the PLM Type uniquely identifies a PLM 
Component in the underlying database. This list is one of the inputs for the 
database query. The list is built, as depicted by the code extract below</p>
<pre class="code">
CATListOfCATString iListAttributeName ;
CATListOfCATUnicodeString iListAttributeValue ;

for (int AttrIndex=8; AttrIndex &lt;= (8+((NbAttributes-1)*2)); AttrIndex++)
{
    const CATString Attribute =  CATCkePLMNavPublicServices::RetrieveBasicAttributeNameFromPreviousOne(NULL_var,iArgv[AttrIndex]).CastToCharPtr();
    cout &lt;&lt; "The attribute name  is " &lt;&lt; Attribute.CastToCharPtr() &lt;&lt; endl;
    iListAttributeName.Append(Attribute); 		
    const CATUnicodeString Value(iArgv[AttrIndex+1]);
    cout &lt;&lt; "The attribute value is " &lt;&lt; Value.ConvertToChar() &lt;&lt; endl;
    iListAttributeValue.Append(Value);
    // Attribute names occur alternatively in the input arguments
    // So we need to jump two steps each time for each iteration of this loop
     AttrIndex++;
}

</pre>
<p>An attribute-value set are built with user inputs. The count 
of the attribute-value set is defined by the PLMType of the Requirement Reference 
to browse. </p>
<script type="text/javascript">insertLinkToTop();</script>
<script type="text/javascript">insertLinkToTop();</script>
<h4><a name="Run Query"></a>Run Query and Retrieve Requirement Reference from the Underlying Database</h4>
<p>At this stage, we have with us the inputs (PLMType and the  
attribute-value sets) which together define our database query. The query 
enables us retrieve an Identificator of a PLM Component, conforming to the 
search criteria, defined by the query. We then load this Component in session.</p>
<pre class="code">...
              
   CATIAdpPLMIdentificator* opiIDComp = NULL;
   hr = ::CAARetrieveIDofUniquePLMObject(iListAttributeName,iListAttributeValue,														
				    istrPLMType,opiIDComp);
   ...
   hr= opener.CompleteAndOpen(opiIDComp,IID_CATIPLMNavReference, (void**) &amp;piNavRef);
   
...
</pre>
<p>It next loads the Requirement Entities in session, which essentially loads in session all the 
Requirement Entities and Relations. </p>
<script type="text/javascript">insertLinkToTop();</script>
<h3><b><u><a name="Browse the Functional Structure"></a></u>Browse the 
Requirement Relations</b></h3>
<p>The process to browse Requirement Relations involves retrieving the 
Child Relations, immediately under the Root Requirement Entity. We then retrieve the 
Requirement Entity associated with each direct Relation. With the child entity, we 
further browse down the Requirement Relations. So the browsing is effectively a 
recursive process.</p>
<pre class="code">
HRESULT CAANavigateReqRelList(CATIPLMNavReference *piNavRefOnComp, CATBoolean iAllAtributes, int iDepth)
{
   HRESULT hr = E_FAIL;
   ...	
   // ===========================================================================================================
   // 1- Display attribute(s) of the Entity
   // ===========================================================================================================
   CATIPLMNavEntity_var spNavEnt = piNavRefOnComp;
   PLMIReqStructuralEntity* pReqStructEntity = NULL;
   hr = piNavRefOnComp -&gt; QueryInterface(IID_PLMIReqStructuralEntity, (void**) &amp;pReqStructEntity);
   ...
   
   //------------------------------------------------
   // 2- Get list of children Relations of Req object
   //-----------------------------------------------
   PLMIReqRelation *piReqRelation = NULL;
   int Entsize = 0;
   CATLISTV(CATBaseUnknown_var) spReqChildrenRelList = NULL;
   hr = pReqStructEntity-&gt;GetReqChildrenRelations(spReqChildrenRelList);
   ...
   
   //---------------------------------------------
   // 3. Loop to Navigate through the Relations
   //---------------------------------------------
   while (SUCCEEDED(hr) &amp;&amp; i &lt;= Entsize)
   {
   	CATBaseUnknown_var spReqChildRelation;
   	spReqChildRelation = spReqChildrenRelList[i];
   	spReqChildRelation -&gt; QueryInterface(IID_PLMIReqRelation, (void**) &amp;piReqRelation);
   	PLMReqRelationClassification oReqRelClassification;
   	
   	hr = piReqRelation -&gt;GetRelationClassification(oReqRelClassification);
   	...
   }
   
   ...
   // Display the 'FROM' object of Relation
   hr = piReqRelation -&gt; GetFromObject(spToReqEntity);
   
   // Display the 'TO' object of Relation
   hr = piReqRelation -&gt; GetToObject(spFromReqEntity);
   ...
   
   	CATIPLMNavReference_var piNavRefonEntity = ospiReqEntity;
   	if (NULL_var != piNavRefonEntity)
   	{
   	// 4-2-2 Recursively browse all entities
   	hr = CAANavigateReqRelList (piNavRefonEntity, iAllAtributes,iDepth+3);
   	}
   ...
   
 </pre>
<p>The <span class="style2">pReqStructEntity-&gt;GetReqChildrenRelations</span> implementation on a 
Requirement Entity, returns a list of direct Requirement Relations under it.</p>
<p>The <span class="style2">piReqRelation -&gt;GetRelationClassification</span> 
implementation will give the type of Requirement Relation.</p>
<p>The <span class="style2">DisplayReqRelationType()</span> is a function which 
prints the type of Relations under the Entity</p>
<p>The <span class="style2">piReqRelation -&gt; GetFromObject</span> and <span class="style2"> piReqRelation 
-&gt; GetToObject</span> are the functions which 
will give us the Requirement Entities connected to the above Relation</p>
<p>What follows is a recursive call to the same subroutine namely. <span class="style2">CAANavigateReqRelList()</span>, with the 
Requirement Entity, 
retrieved in the earlier step.</p>

<script type="text/javascript">insertLinkToTop();</script>

<h3><a name="Epilog"></a>Epilog</h3>
<p>The <code>CAARmiBrowsingRequirementRelations  </code>use case ends by simply closing 
the PLM session [<a href="#References">2</a>].&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script>
		<!---------------------------------comment------------------------------------->
		<h2><a name="InShort"></a>In Short</h2>
<p>The Use Case <code>CAARmiBrowsingRequirementRelations<b> </b></code>details the steps involved in the CAA Customization 
		to browse through a Requirement Model, using the <code>CATRequirementModelerUseItf</code> framework (restricted to the 
Requirement Modeler) CAA Exposition. </p>
<p>The Use Case thus retrieves an Identificator of the Requirement Root Reference, in the 
underlying database. It next loads it in session, in <strong>Authoring</strong> 
mode, which essentially loads in session all the Requirement Entities and 
Relations</p>
<script type="text/javascript">insertLinkToTop();</script> 
		<!---------------------------------comment------------------------------------->
		<h2><a name="References"></a>References</h2>
		<table>
			
			<tr>
				<td >[1]</td>
				<td ><a href="../CAADocUseCases/CAADocRunSample.htm">Building 
						and Launching a CAA Use Case</A></td>
			</tr>
			<tr>
				<td >[2]</td>
				<td >
                <a href="../CAAPlmServerAccess/CAAAdpUcBasicBatch.htm">
                Creating a PLM Basic Batch</a></td>
			</tr>
			<tr>
				<td >[3]</td>
				<td ><a href="CAARmiTaReqModelerOverview.htm">Requirement Modeler Overview</a></td>
			</tr>
			<tr>
				<td >[4]</td>
				<td ><a href="CAARmiUcOpeningReqObject.htm">Opening Requirement 
				object in session</a></td>
			</tr>


			
			</table>
		
		<!---------------------------------comment------------------------------------->
		<h2><a name="History"></a>History</h2>
		<table >
			<tr>
				<td vAlign="top">Version: <strong>1</strong> [Feb 2013]&nbsp;&nbsp; </td>
				<td vAlign="top">Document created</td>
			</tr>
			</table>
		<script type="text/javascript">insertLinkToTop();</script>
		<!---------------------------------comment------------------------------------->
	</body>
</html>


