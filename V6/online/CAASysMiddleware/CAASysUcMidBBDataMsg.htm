<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Creating a Backbone Data Message</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Creating a Backbone Data Message</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article shows how to create a backbone data message component, that 
		is, a message component that conveys data. This message component can then 
		be used to make two processes or applications communicate.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAASysBBMessage Use Case</a>
				<ul>
					<li><a href="#What">What Does CAASysBBMessage Do</a></li>
					<li><a href="#How">How to Launch CAASysBBMessage</a></li>
					<li><a href="#Where">Where to Find the CAASysBBMessage Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case shows you how to create a backbone data message, that is, that 
conveys data. This use case shows how to create a component that derives from the 
base message component <em>CATBBMessage</em>, and that implements, in the component 
main class, the <em>CATIStreamMsg</em> interface with data to stream and unstream. 
In addition, it shows you how to implement <em>CATICreateInstance</em> using a code 
extension class to enable clients to instantiate the message component.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAASysBBMessage Use Case</h2>
<p>CAASysBBMessage is a use case of the CAASystem.edu framework that illustrates 
the System framework capabilities.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAASysBBMessage Do</h3>
<p>The message component is named <em>CAASysDataMessage</em> and derives from the
<em>CATBBMessage</em> component. <em>CAASysDataMessage</em> implements the <em>CATIStreamMsg</em> 
and <em>CATICreateInstance</em> interfaces. It also inherits the implementation 
of the <em>CATICommMsg</em> and <em>CATIBBStreamer</em> interfaces from <em>CATBBMessage</em>.
<em>CATICreateInstance</em> is implemented using a code extension class.</p>
<p>
<img alt="use Case Data Model" height="305" src="images/CAASysMidBBDataMsg.jpg" width="459"/></p>
<p><em>CATIStreamMsg</em> is implemented to convey the data that define a circle. 
To get and set this data, <em>CAASysDataMessage</em> also implements the <em>CAAISysDataRequest</em> 
interface. This data is:</p>
<table>
	<tr>
		<td>The circle radius</td>
		<td>float</td>
	</tr>
	<tr>
		<td>The circle number</td>
		<td>int</td>
	</tr>
	<tr>
		<td>The circle color</td>
		<td>char *</td>
	</tr>
	<tr>
		<td>The circle sags</td>
		<td>array of floats</td>
	</tr>
</table>
<p>The CAASysBBMessage use case also includes another backbone message component 
that does not convey any data [<a href="#References">1</a>].</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAASysBBMessage</h3>
<p>CAASysBBMessage is launched by other backbone use cases [<a href="#References">2</a>][<a href="#References">3</a>], 
but you need to create the CAASysBBMessage shared library or DLL. To do this, you 
will need to set up the build time environment, and compile CAASysBBMessage along 
with its prerequisites [<a href="#References">4</a>].</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAASysBBMessage Code</h3>
<p>The CAASysBBMessage use case is made of several classes located in the CAASysBBMessage.m 
module of the CAASystem.edu framework:</p>
<p><code>InstallRootFolder\CAADoc\CAASystem.edu\CAASysBBMessage.m\</code> </p>
<p>where <code>InstallRootFolder</code> [<a href="#References">4</a>] is the 
folder where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>To create a backbone data message, there are four main steps:</p>
<table>
	<colgroup span="3" valign="top">
	</colgroup>
	<tr>
		<th>#</th>
		<th>Step</th>
		<th>Where</th>
	</tr>
	<tr>
		<td>1</td>
		<td><a href="#Step1">Creating the Message Component Main Class</a></td>
		<td>LocalInterfaces\CAASysDataMessage.h<br />
		src\CAASysDataMessage.cpp</td>
	</tr>
	<tr>
		<td>2</td>
		<td><a href="#Step2">Implementing <em>CATIStreamMsg</em></a></td>
		<td>LocalInterfaces\CAASysDataMessage.h<br />
		src\CAASysDataMessage.cpp</td>
	</tr>
	<tr>
		<td>3</td>
		<td><a href="#Step3">Implementing <em>CAAISysDataRequest</em></a></td>
		<td>LocalInterfaces\CAASysDataMessage.h<br />
		src\CAASysDataMessage.cpp</td>
	</tr>
	<tr>
		<td>4</td>
		<td><a href="#Step4">Creating the Message Component Factory</a></td>
		<td>LocalInterfaces\CAAESysCreateInstanceForDataMessage.h<br />
		src\CAAESysCreateInstanceForDataMessage.cpp</td>
	</tr>
	<tr>
		<td>5</td>
		<td><a href="#Step5">Updating the Interface Dictionary</a></td>
		<td>CNext\code\dictionary\CAASystem.edu.dico</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Creating the Message Component Main Class</h3>
<p>A backbone message is a component that is made up of a main class. Its header 
file is as follows:</p>
<pre class="code">#include &quot;CATBBMessage.h&quot;

class  CAASysDataMessage : public <strong>CATBBMessage</strong>
{
  <strong>CATDeclareClass</strong>;

  public:
    CAASysDataMessage();
    virtual ~CAASysDataMessage();

    // CATIStreamMsg interface methods
    virtual HRESULT StreamData    (void **oBuffer, uint32 *oLen);
    virtual HRESULT UnstreamData  (void  *iBuffer, uint32  iLen);
    virtual HRESULT FreeStreamData(void  *iBuffer, uint32  iLen);
    virtual HRESULT SetMessageSpecifications();

    // CAAISysDataRequest interface methods
    virtual HRESULT SetData(const float iRadiusOfCircle, 
                            const int   iNbOfCircle,
                            char      * iColorOfCircle,
                            float     * iSagOfCircle);
      
    virtual HRESULT GetData(float     &amp; oRadiusOfCircle,
                            int       &amp; oNbOfCircle,
                            char     ** oColorOfCircle,
                            float    ** oSagOfCircle);
      
  private:
    CAASysDataMessage(const CAASysDataMessage &amp;iObjectToCopy);

  private:
    float   _RadiusOfCircle;
    int     _NbOfCircle;
    char  * _ColorOfCircle;
    float   _SagOfCircle[3];
};</pre>
<p>The <em>CAASysDataMessage</em> class belongs to a component, thanks to the
<code>CATDeclareClass</code> macro. It C++ derives from <em>CATBBMessage</em>, and 
implements <em>CATIStreamMsg</em>, whose four methods are declared. In addition, 
it implements an application interface to retrieve and set the data of the circle 
component it is intended to convey. Note that the copy constructor is set as private, 
and is not implemented in the source file. This prevents the compiler from creating 
the copy constructor as public without you know. The circle component data are declared 
as private data members.</p>
<p>The source file of the backbone data message component main class begins as follows:</p>
<pre class="code">#include  &quot;CAASysDataMessage.h&quot;

#include &lt;CATErrorDef.h&gt;    // for the SUCCEEDED macro
#include &quot;CATIBBStreamer.h&quot; // To stream 
#include &quot;CATICommMsg.h&quot;    

#include &quot;TIE_CATIStreamMsg.h&quot;
<strong>TIE_CATIStreamMsg(CAASysDataMessage);</strong>

#include &quot;TIE_CAAISysDataRequest.h&quot;
<strong>TIE_CAAISysDataRequest(CAASysDataMessage);</strong>

<strong>CATImplementClass(CAASysDataMessage, Implementation, CATBBMessage, CATNull);</strong>

CAASysDataMessage::CAASysDataMessage()
                 : _ColorOfCircle(NULL),_NbOfCircle(0),_RadiusOfCircle(0.f)
{
  _SagOfCircle[0] = 0.0f;
  _SagOfCircle[1] = 0.0f;
  _SagOfCircle[2] = 0.0f;
}

CAASysDataMessage::~CAASysDataMessage()
{
  if ( NULL != _ColorOfCircle ) 
  {
    delete [] _ColorOfCircle;
    _ColorOfCircle = NULL;
  }
}
...</pre>
<p>The <em>CAASysDataMessage</em> class states that it implements the <em>CATIStreamMsg</em> 
and <em>CAAISysDataRequest</em> interfaces thanks to the <code>TIE_CATIStreamMsg</code> 
and <code>TIE_CAAISysDataRequest</code> macros respectively. The <code>CATImplementClass</code> 
macro declares that the <em>CAASysDataMessage</em> class is a component main class 
thanks the <code>Implementation</code> keyword, and that the component OM-derives 
[<a href="#References">5</a>] from <em>CATBBMessage</em>. Any component main class 
declared as an <code>Implementation</code> must C++-derive and OM-derive from the 
same class. The constructor and the destructor respectively initializes and deletes 
the data members.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Implementing CATIStreamMsg</h3>
<p><em>CATIStreamMsg</em> is the interface dedicated to streaming and unstreaming 
the data that the message conveys. Four methods must be implemented:</p>
<table>
	<tr>
		<td><a href="#StreamData"><code>StreamData</code></a></td>
		<td>Streams a backbone message</td>
	</tr>
	<tr>
		<td><a href="#UnstreamData"><code>UnstreamData</code></a></td>
		<td>Unstreams a backbone message</td>
	</tr>
	<tr>
		<td><a href="#FreeStreamData"><code>FreeStreamData</code></a></td>
		<td>Frees the backbone message streaming buffer</td>
	</tr>
	<tr>
		<td><a href="#SetMessageSpecifications"><code>SetMessageSpecifications</code></a></td>
		<td>Sets backbone message class name and options</td>
	</tr>
</table>
<p>These methods are implemented for the circle object.</p>
<ol>
	<li><a name="StreamData"></a>Streaming the backbone message
		<pre class="code">HRESULT CAASysDataMessage::<strong>StreamData</strong>(void **oBuffer, uint32 *oLen)
{
  CATIBBStreamer * pICATIBBStreamer = NULL ;
  HRESULT rc = QueryInterface(<strong>IID_CATIBBStreamer</strong>, (void**)&amp;pICATIBBStreamer);

  if ( SUCCEEDED(rc) )
  {
    pICATIBBStreamer-&gt;<strong>BeginStream</strong>();

    pICATIBBStreamer-&gt;<strong>StreamFloat</strong>(_RadiusOfCircle); 
    pICATIBBStreamer-&gt;<strong>StreamInt</strong>(_NbOfCircle); 
    pICATIBBStreamer-&gt;<strong>StreamString</strong>(_ColorOfCircle); 
    pICATIBBStreamer-&gt;<strong>StreamFixedFloatArray</strong>(_SagOfCircle,3); 

    int Len ; 
    *oBuffer = pICATIBBStreamer-&gt;<strong>EndStream</strong>(&amp;Len);
    *oLen = Len ;

    pICATIBBStreamer-&gt;Release();
    pICATIBBStreamer = NULL;
  }
  return rc;
}</pre>
		<p>The data to stream for the circle is made up of simple types only. An 
		easy way of implementing such data streaming is to retrieve a pointer to 
		the <em>CATIBBStreamer</em> interface that the component implements thanks 
		to the inheritance of <em>CATBBMessage</em>. <em>CATIBBStreamer</em> provides 
		a set of streaming methods for simple types that just need to be called. 
		First, initialize the streaming operation using <code>BeginStream</code>, 
		and then stream the data:</p>
		<table>
			<tr>
				<td>The circle radius</td>
				<td>float</td>
				<td><code>StreamFloat</code></td>
			</tr>
			<tr>
				<td>The circle number</td>
				<td>int</td>
				<td><code>StreamInt</code></td>
			</tr>
			<tr>
				<td>The circle color</td>
				<td>char *</td>
				<td><code>StreamString</code></td>
			</tr>
			<tr>
				<td>The circle sags</td>
				<td>array of floats</td>
				<td><code>StreamFixedFloatArray</code></td>
			</tr>
		</table>
		<p>Then, close the streaming operation using <code>EndStream</code>, release 
		the <em>CATIBBStreamer</em> pointer and set it to <code>NULL</code>, and 
		that's done.</p>
	</li>
	<li><a name="UnstreamData"></a>Unstreaming the backbone message
		<pre class="code">HRESULT CAASysDataMessage::<strong>UnstreamData</strong>(void *iBuffer, uint32 iLen)
{
  CATIBBStreamer * pICATIBBStreamer = NULL;
  HRESULT rc = QueryInterface(<strong>IID_CATIBBStreamer</strong>, (void**)&amp;pICATIBBStreamer);

  if ( SUCCEEDED(rc) )
  {
    pICATIBBStreamer-&gt;<strong>BeginUnstream</strong>(iBuffer,iLen);

    pICATIBBStreamer-&gt;<strong>UnstreamFloat</strong>(&amp;_RadiusOfCircle); 
    pICATIBBStreamer-&gt;<strong>UnstreamInt</strong>(&amp;_NbOfCircle); 

    int Len;
    pICATIBBStreamer-&gt;<strong>UnstreamNeededStringLength</strong>(&amp;Len); 
    _ColorOfCircle = new char [Len];
    pICATIBBStreamer-&gt;<strong>UnstreamString</strong>(_ColorOfCircle); 

    pICATIBBStreamer-&gt;<strong>UnstreamFixedFloatArray</strong>(_SagOfCircle, 3);

    rc = pICATIBBStreamer-&gt;<strong>EndUnstream</strong>();

    pICATIBBStreamer-&gt;Release();
    pICATIBBStreamer = NULL;
  }
  return rc;
}
...</pre>
		<p>Unstreaming the circle data streamed is also performed by retrieving 
		a pointer to the <em>CATIBBStreamer</em> interface. <em>CATIBBStreamer</em> 
		provides a set of unstreaming methods for simple types that just need to 
		be called. First, initialize the unstreaming operation using <code>BeginUnstream</code>, 
		and then <strong>unstream the data in the same order than when streaming</strong>:</p>
		<table>
			<tr>
				<td>The circle radius</td>
				<td>float</td>
				<td><code>UnstreamFloat</code></td>
			</tr>
			<tr>
				<td>The circle number</td>
				<td>int</td>
				<td><code>UnstreamInt</code></td>
			</tr>
			<tr>
				<td>The circle color</td>
				<td>char *</td>
				<td><code>UnstreamString</code></td>
			</tr>
			<tr>
				<td>The circle sags</td>
				<td>array of floats</td>
				<td><code>UnstreamFixedFloatArray</code></td>
			</tr>
		</table>
		<p>Note that prior to unstream a character string, you should retrieve its 
		length thanks to <code>UnstreamNeededStringLength</code>, and allocate the 
		character string. When all data is unstreamed, close the unstreaming operation 
		using <code>EndUnstream</code>, release the <em>CATIBBStreamer</em> pointer 
		and set it to <code>NULL</code>, and that's done.</p>
	</li>
	<li><a name="FreeStreamData"></a>Freeing the backbone message
		<pre class="code">...
HRESULT CAASysDataMessage::<strong>FreeStreamData</strong>(void *iBuffer, uint32 iLen)
{
  CATIBBStreamer * pICATIBBStreamer = NULL;
  HRESULT rc = QueryInterface(<strong>IID_CATIBBStreamer</strong>,(void**)&amp;pICATIBBStreamer);

  if ( SUCCEEDED(rc) )
  {
    pICATIBBStreamer-&gt;<strong>ResetStreamData</strong>();

    pICATIBBStreamer-&gt;Release();
    pICATIBBStreamer = NULL ;
  }
  return rc ;
}
...</pre>
		<p>To free the stream buffer when only simple types are streamed and unstreamed, 
		simply retrieve a pointer to the <em>CATIBBStreamer</em> interface and call
		<code>ResetStreamData</code>.</p>
	</li>
	<li><a name="SetMessageSpecifications"></a>Setting the message specifications
		<pre class="code">...
HRESULT CAASysDataMessage::<strong>SetMessageSpecifications</strong>()
{
  HRESULT rc = E_FAIL;
  CATICommMsg * pICommMsg = NULL ;
  rc = QueryInterface(<strong>IID_CATICommMsg</strong>, (void**)&amp;pICommMsg);
  if ( SUCCEEDED(rc) )
  {
    CATMessageClass MessageClassName= &quot;CAASysDataMessage&quot;;
    rc = pICommMsg-&gt;<strong>SetMessageClass</strong>(MessageClassName);

    pICommMsg-&gt;Release();
    pICommMsg = NULL ;

    rc = S_OK;
  }
  return rc;
}</pre>
		<p>The message specifications that must be set are at least the name of 
		the message component main class. This is to enable the message component 
		to be instantiated at unstreaming time. This is done by retrieving a pointer 
		to the <em>CATICommMsg</em> interface that the component implements thanks 
		to the inheritance of <em>CATBBMessage</em>. Simply call the <code>SetMessageClass</code> 
		with the message class name as argument.</p>
	</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Implementing CAAISysDataRequest</h3>
<p><em>CAAISysDataRequest</em> is an interface the component should implement to 
enable the data to be set and retrieved, and is therefore component dependent.
<em>CAAISysDataRequest</em> has two methods, <code>SetData</code> and <code>GetData</code>.</p>
<ul>
	<li><code>SetData</code>
		<pre class="code">HRESULT CAASysDataMessage::<strong>SetData</strong>(const float iRadiusOfCircle,
                                   const int   iNbOfCircle,
                                   char       *iColorOfCircle,
                                   float      *iSagOfCircle)
{
  _RadiusOfCircle = iRadiusOfCircle;
  _NbOfCircle     = iNbOfCircle;

  if ( NULL != iColorOfCircle )
  {
    _ColorOfCircle = new char [strlen(iColorOfCircle)+1];
    strcpy(_ColorOfCircle,iColorOfCircle);
  }

  _SagOfCircle[0] = iSagOfCircle[0];
  _SagOfCircle[1] = iSagOfCircle[1];
  _SagOfCircle[2] = iSagOfCircle[2];

  return S_OK;
}</pre>
		<p><code>SetData</code> is used by the message sender when the message is 
		created to feed the message with the circle data [<a href="#References">3</a>].</p>
	</li>
	<li><code>GetData</code>
		<pre class="code">HRESULT CAASysDataMessage::GetData(float  &amp; oRadiusOfCircle,
                                   int    &amp; oNbOfCircle,
                                   char  ** oColorOfCircle,
                                   float ** oSagOfCircle)
{
  HRESULT rc = E_FAIL;

  if ( (NULL != oSagOfCircle) &amp;&amp; ( NULL != oColorOfCircle) )
  {
    oRadiusOfCircle = _RadiusOfCircle;
    oNbOfCircle     = _NbOfCircle;

    if ( NULL != _ColorOfCircle )
    {
      *oColorOfCircle = new char [strlen(_ColorOfCircle)+1];
      strcpy(*oColorOfCircle,_ColorOfCircle);
    }
    else 
    {
      *oColorOfCircle = NULL;
    }

    *oSagOfCircle = new float[3] ;

    (*oSagOfCircle)[0] = _SagOfCircle[0];
    (*oSagOfCircle)[1] = _SagOfCircle[1];
    (*oSagOfCircle)[2] = _SagOfCircle[2];

    rc = S_OK;
   }
   return rc;
}</pre>
		<p><code>GetData</code> is used by the message receiver when the message 
		is received to get the circle data from the message [<a href="#References">3</a>].</p>
	</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>Creating the Message Component Factory</h3>
<p>As any component, a backbone message should provide a means for any client application 
to instantiate it [<a href="#References">6</a>]. This is made possible by making 
the component implement <em>CATICreateInstance</em> using a code extension class. 
Below is the header file of this class.</p>
<pre class="code">#include &quot;CATBaseUnknown.h&quot;   //Needed to derive from CATBaseUnknown

class CAAESysCreateInstanceForDataMessage : public CATBaseUnknown
{
  <strong>CATDeclareClass</strong>;
  public:
    CAAESysCreateInstanceForDataMessage();
    virtual ~CAAESysCreateInstanceForDataMessage();

    // CATICreateInstance method 
    virtual HRESULT __stdcall CreateInstance(void **oppv);

  private:
    CAAESysCreateInstanceForDataMessage(const CAAESysCreateInstanceForDataMessage &amp;iObjectToCopy);
};</pre>
<p>The <em>CAAESysCreateInstanceForDataMessage</em> class belongs to a component, 
thanks to the <code>CATDeclareClass</code> macro. It C++ derives from <em>CATBaseUnknown</em>, 
and implements <em>CATICreateInstance</em>, whose unique method <code>CreateInstance</code> 
is declared. Note that the copy constructor is set as private, and is not implemented 
in the source file. This prevents the compiler from creating the copy constructor 
as public without you know.</p>
<p>The source file of this code extension class is as follows:</p>
<pre class="code">#include &quot;CAAESysCreateInstanceForDataMessage.h&quot;

#include &quot;CAASysDataMessage.h&quot;

#include &quot;TIE_CATICreateInstance.h&quot;
<strong>TIE_CATICreateInstance(CAAESysCreateInstanceForDataMessage);</strong>
<strong>CATImplementClass(CAAESysCreateInstanceForDataMessage,
                  CodeExtension,
                  CATBaseUnknown,
                  CAASysDataMessage);</strong>

CAAESysCreateInstanceForDataMessage::CAAESysCreateInstanceForDataMessage() {}

CAAESysCreateInstanceForDataMessage::~CAAESysCreateInstanceForDataMessage() {}

HRESULT __stdcall CAAESysCreateInstanceForDataMessage::<strong>CreateInstance</strong>(void ** oppv)
{
  CAASysDataMessage * pt = new CAASysDataMessage();
  if (!pt) return(E_OUTOFMEMORY);
  *oppv = (void *)pt;
  return(S_OK);
}</pre>
<p>The <em>CAAESysCreateInstanceForDataMessage</em> class states that it implements 
the <em>CATICreateInstance</em> interface thanks to the <code>TIE_CATICreateInstance</code> 
macro. The <code>CATImplementClass</code> macro declares that the <em>CAAESysCreateInstanceForDataMessage</em> 
class is a code extension class, thanks to the <code>CodeExtension</code> keyword, 
and that it extends the component whose main class is <em>CAASysDataMessage</em>. 
The third parameter must always be set to <em>CATBaseUnknown</em>, makes no sense, 
and is unused for extensions. The <code>CreateInstance</code> method instantiates 
and returns the component main class.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>Updating the Interface Dictionary</h3>
<p>The interface dictionary is updated as follows.</p>
<pre class="code">CAASysDataMessage         CATIStreamMsg           libCAASysBBMessage
CAASysDataMessage         CATICreateInstance      libCAASysBBMessage
CAASysDataMessage         CAAISysDataRequest      libCAASysBBMessage</pre>
<p>The interface dictionary is a file whose name is the framework name suffixed 
by dico, such as CAASystem.edu.dico, and that you should create or update in the 
framework CNext\code\dictionary folder. The interface dictionary declares that 
the <em>CAASysDataMsg</em> component implements <em>CATIStreamMsg</em>, <em>CATICreateInstance</em>, 
and <em>CAAISysDataRequest</em>, and that the shared library or DLL to load to query 
pointers to these interfaces is libCAASysBBMessage.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This use case has shown how to create a backbone data message that can be used 
to communicate between two applications. As any backbone message, the message is 
made up of a component that derives from the supplied <em>CATBBMessage</em> component, 
that itself implements <em>CATIStreamMsg</em> and <em>CATICreateInstance</em> interfaces, 
and that inherits from <em>CATBBMessage</em> the implementation of the <em>CATIBBStreamer</em> 
and <em>CATICommMsg</em> interfaces. Such a message that conveys data of simple 
types can use the streaming and unstreaming methods provided by the <em>CATIBBStreamer</em> 
implementation of <code>CATBBMessage</code>. Data must be streamed and unstreamed 
in the same order. The message is now ready to be used by applications [<a href="#References">3</a>].</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td><a href="CAASysUcMidBBSimpleMsg.htm">Creating a Backbone Simple Message</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAASysUcMidBBSendRecSimpleMsg.htm">Sending a Backbone Simple 
		Message to an Application</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td><a href="CAASysUcMidBBSendRecDataMsg.htm">Sending a Backbone Data Message 
		to an Application</a></td>
	</tr>
	<tr>
		<td>[4]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[5]</td>
		<td>
		<a href="../CAASysObjectModeler/CAASysTaOMInheritance.htm">Object 
		Modeler Inheritances</a></td>
	</tr>
	<tr>
		<td>[6]</td>
		<td>
		<a href="../CAASysObjectModeler/CAASysTaOMCreatingComponent.htm">
		Creating Components</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [Jul 2000]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
