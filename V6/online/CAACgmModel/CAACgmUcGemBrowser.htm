<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 12.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="Stylesheet" type="text/css" href="../CAADocStyleSheets/caav5.css">
<script type="text/javascript" src="../CAADocJavaScript/DSDocHighlight.js"></script>
<script type="text/javascript" src="../CAADocJavaScript/submit.js"></script>
<title>Browsing the Geometric Container</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Browsing the Geometric Container</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>In all the CATIA Geometric Modeler use cases, a CATGeoFactory container, 
		creating and containing the geometric objects, is created and can be stored 
		in a .NCGM file. The purpose of the CAAGMModelGemBrowser use case is to 
		create an application and a document allowing you to visualize the created 
		objects of a CATGeoFactory container.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAAGMModelGemBrowser Use Case</a>
			<ul>
				<li><a href="#What">What Does CAAGMModelGemBrowser Do</a></li>
				<li><a href="#How">How to Launch CAAGMModelGemBrowser</a></li>
				<li><a href="#Where">Where to Find the CAAGMModelGemBrowser Code</a></li>
			</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case explains a means to visualize geometric objects:</p>
<ul>
	<li>The bodies.</li>
	<li>The points, curves, and surfaces which are not pointed to by any other geometric 
	object.</li>
</ul>
<p>First an application and a document are defined, following the same way as in 
the <code>CAAVisBase</code> use case. Then, the visualization of the objects are 
computed. Hence, you will learn:</p>
<ul>
	<li>How to load and use the geometry factory.</li>
	<li>How to read data on the geometric objects.</li>
	<li>How to use the tessellation operators: <code>CATCellOperator</code> to tessellate 
	a cell, <code>CATCurveTessellator</code> to tessellate a curve and <code>CATSurfaceTessellator</code> 
	to tessellate a surface.</li>
	<li>How to create representations.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAAGMModelGemBrowser Use Case</h2>
<p>CAAGMModelGemBrowser is a use case of the CAAGMModelInterfaces.edu framework. 
This use case illustrates the geometric modeler tessellation capabilities.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAAGMModelGemBrowser Do</h3>
<p>This use case:</p>
<ul>
	<li>First derives a new class of application CAAGemBrowserApplication and a 
	new class of document CAAGemBrowserDocument, and provides the corresponding 
	overridden methods.</li>
	<li>Then defines the class CAAGemRep that computes the representation.</li>
</ul>
<p>
<img alt="GEM Browser" src="images/CAACgmGemBrowser1.gif" width="675" height="353"></p>
<p>This use case is a proposal of geometry visualization. Its intent is not to be 
a full graphic application. In particular, the color or the selection are not managed 
here.</p>
<p>In the picture above, the CAAGMModelGemBrowser use case displays the result of 
the CAAGMOperatorsJournal use case. This result was saved in the folder:</p>
<p><code>InstallRootFolder\intel_a\CNext\resources\graphic\CAATopJournal.NCGM</code></p>
<p>to allow you to visualize an example without processing any other use case. To 
visualize the model, simply select the menu File and the item Open. Then select 
the file.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAAGMModelGemBrowser</h3>
<p>To launch CAAGMModelGemBrowser, you will need to set up the build time environment, 
then compile CAAGMModelGemBrowser.m along with its prerequisites, set up the run 
time environment, and then execute the use case [<a href="#References">1</a>].</p>
<p>This use case is an interactive application. To visualize a .NCGM document (for 
example, the model saved at the last step of the CAAGMOperatorsJournal, CAAGMOperatorsOverview, 
CAAGMModelCreation, CAAGMModelNurbs, CAAGMOperatorsTesBody, or CAAGMModelIntersect 
use cases ), click the File+Open menu and select the file you want to display.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAAGMModelGemBrowser Code</h3>
<p>The CAAGMModelGemBrowser use case is made of three classes </p>
<ul>
	<li>CAAGemBrowserApplication, defining the application.</li>
	<li>CAAGemBrowserDocument, defining the window.</li>
	<li>CAAGemRep, creating the representations.</li>
</ul>
<p>The sources (CAAGemBrowserApplication.cpp, CAAGemBrowserDocument.cpp, CAAGemRep.cpp) 
are located in the CAAGMModelGemBrowser.m module of the CAAGMModelInterfaces.edu framework.</p>
<p>The corresponding headers (CAAGemBrowserApplication.h, CAAGemBrowserDocument.h, 
CAAGemRep.h) are located in the <code>LocalInterfaces</code> directory of the CAAGMModelGemBrowser.m 
module.</p>
<p><code>InstallRootFolder\CAADoc\CAAGMModelInterfaces.edu\CAAGMModelGemBrowser.m\</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">1</a>] is the folder 
where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>CAAGMModelGemBrowser is divided into the following steps:</p>
<ul>
	<li><a href="#The CAAGemBrowserApplication Class">Creating an Interactive Application 
	to Display the Document</a></li>
	<li><a href="#The CAAGemBrowserDocument Class">Creating Dialog Objects and Setting 
	their Behaviors and Styles</a>
	<ul>
		<li><a href="#Constructor and Build Methods">Constructor and Build methods</a></li>
		<li><a href="#Creation of the Menu Bar">Creating the Menu Bar</a></li>
		<li><a href="#Creation of the Viewer">Creating the Viewer</a></li>
		<li><a href="#Managing the Open Callback">Managing the Open Callback</a></li>
		<li><a href="#Loading the Geometry Factory">Loading the Geometry Factory</a></li>
	</ul>
	</li>
	<li><a href="#Creating the Graphic Representations">Creating the Representations</a>
	<ul>
		<li><a href="#Point">Representation of a Point</a></li>
		<li><a href="#Visualizing a Line">Representation of a Line</a></li>
		<li><a href="#Curve">Representation of a Curve</a></li>
		<li><a href="#Plane">Representation of a Plane</a></li>
		<li><a href="#Surface">Representation of a Surface</a></li>
		<li><a href="#Body">Representation of a Body</a></li>
		<li><a href="#Edge">Representation of a Edge</a></li>
	</ul>
	</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="The CAAGemBrowserApplication Class"></a>Creating an Interactive Application 
to Display the Document</h3>
<p>Thanks to an interactive application, the CAAGemBrowserDocument can be displayed 
and run as a standalone application. This interactive application is made of the 
class CAAGemBrowserApplication that derives from CATInteractiveApplication. Its 
header file is as follows.</p>
<pre class="code">#include &quot;CATInteractiveApplication.h&quot;  // To derive from

class CAAGemBrowserApplication : public CATInteractiveApplication
{
  public:
	
    CAAGemBrowserApplication(const CATString &amp; iApplicationId);
    virtual     ~CAAGemBrowserApplication();
    virtual void BeginApplication();
    virtual int  EndApplication();

private:
    CAAGemBrowserApplication();
    CAAGemBrowserApplication(const CAAGemBrowserApplication &amp;iObjectToCopy);   
};</pre>
<p>In addition to the constructor and destructor, this interactive application class 
redefines two methods of CATInteractiveApplication:</p>
<ul>
	<li><code>BeginApplication</code>, called by the system just after the application 
	constructor. This method is dedicated to create the different objects managed 
	by the application, namely here the document window.</li>
	<li><code>EndApplication</code>, called by the system when the application destruction 
	is requested. This method is dedicated to deallocate objects or close files.</li>
</ul>
<p>The document window is created in the <code>BeginApplication</code> method, and 
in this use case, the <code>EndApplication</code> has nothing to deallocate since 
it is automatically deleted when the application is deleted.</p>
<pre class="code">...
void CAAGemBrowserApplication::BeginApplication()
{
  cout &lt;&lt; &quot;CAAGemBrowserApplication::BeginApplication&quot; &lt;&lt; endl;

  // This window is deleted when the application is deleted.
  // The application is deleted by the Destroy Method called in the 
  // CAAGemBrowserDocument::Exit method.
  //
  CAAGemBrowserDocument * pMainWindow =NULL;
  pMainWindow = new <strong>CAAGemBrowserDocument</strong>(<strong>this</strong>);

  // Constructs all Dialog objects of the window
  pMainWindow-&gt;<strong>Build</strong>();

  pMainWindow-&gt;<strong>SetVisibility</strong>(CATDlgShow);
}

int CAAGemBrowserApplication::EndApplication()
{              
  return 0;
}</pre>
<p>Note that the document window is first instantiated, then initialized using its
<code>Build</code> method, and finally set as visible. The constructor parameter 
is the dialog box parent in the command tree structure, set as the application itself.</p>
<p>The application is simply instantiated as follows.</p>
<pre class="code">...
CAAGemBrowserApplication ApplicationInstance(&quot;CAAGemBrowserApplicationInstance&quot;);</pre>
<p>The main program is created from this instance.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="The CAAGemBrowserDocument Class"></a>Creating Dialog Objects and Setting 
their Behaviors and Styles</h3>
<p>The file CAAGemBrowserDocument.h contains the following:</p>
<pre class="code">#ifndef CAAGemBrowserDocument_h
#define CAAGemBrowserDocument_h

#include &quot;CATDlgDocument.h&quot;      // To derive from

class CATInteractiveApplication; // Application kept in data member
class CATDlgFile;
class CAT3DBagRep ;              // Data member class forward declaration            
class CATNavigation3DViewer;
class CATGeoFactory;

class CAAGemBrowserDocument : public CATDlgDocument
{
  <strong>DeclareResource</strong>(CAAGemBrowserDocument, CATDlgDocument)

  public:
    CAAGemBrowserDocument(CATInteractiveApplication * iParentCommand);
    virtual ~CAAGemBrowserDocument();
    void     Build();

  private:
 ...
    // Creates the model representation, ie _pTheModelToDisplay
    void CreateModelRepresentation();

    // Creates the Menubar which is reduced to a File/Open-Close-Exit option
    void CreateMenuBar();

    // Creates the Dialog object to see the model 
    void CreateViewer();

    // Attaches the model representation in the 3D Viewer to see it and
    // asks a draw model
    void VisualizeModel();

    // Default constructor, not implemented
    // Set as private to prevent from compiler automatic creation as public.
    CAAGemBrowserDocument ();

    // Copy constructor, not implemented
    // Set as private to prevent from compiler automatic creation as public.
    CAAGemBrowserDocument(const CAAGemBrowserDocument &amp;iObjectToCopy);

  private:
    //The parent widget (a CATInteractiveApplication instance)
    CATInteractiveApplication * _pApplication;
    // The Top of the representation tree
    CAT3DBagRep               * _pTheModelToDisplay ;
    // The Dialog object to display the model 
    CATNavigation3DViewer     * _p3DViewer ;    
    // The  &quot;file selection&quot; window
    CATDlgFile                * _pFileSelector;  
    //  The geometry factory that is visualized
    CATGeoFactory             * _piGeomFactory;
};
#endif	</pre>
<p>The <code>DeclareResource</code> macro enables the class and all its dialog objects 
to use the automatic resource assignment. The first parameter is the class name, 
and the resource files must use this class name as file name, such as CAAGemBrowserDocument.CATNls 
for the file containing the texts and messages.</p>
<p>The class has a constructor, a destructor, and a <code>Build</code> method. Additional 
private methods create the menu bar, the dialog object to see the model, the object 
containing all the representations and visualize the model. Pointers to the different 
dialog objects are then declared as data members.</p>
<p>The remaining part of this file deals with the callback method declaration.</p>
<pre class="code">    // Callback on the exit button item of the menubar
    void Exit  (CATCommand           * iSendingCommand, 
                CATNotification      * iSentNotification, 
                CATCommandClientData   iUsefulData);
    // Callback on the open button item of the menubar
    void Open  (CATCommand           * iSendingCommand, 
                CATNotification      * iSentNotification, 
                CATCommandClientData   iUsefulData);
    // Callback on the OK button item of the file window
    void OpenOK  (CATCommand           * iSendingCommand, 
                  CATNotification      * iSentNotification, 
                  CATCommandClientData   iUsefulData);
    // Callback on the cancel button item of the file window
    void Cancel  (CATCommand           * iSendingCommand, 
                  CATNotification      * iSentNotification, 
                  CATCommandClientData   iUsefulData);
    // Callback on the close button item of the menubar
    void Close  (CATCommand           * iSendingCommand, 
                 CATNotification      * iSentNotification, 
                 CATCommandClientData   iUsefulData);</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Constructor and Build Methods"></a>Constructor and Build Methods</h4>
<p>Let&#39;s have a look at the beginning of CAAGemBrowserDocument.cpp:</p>
<pre class="code">CAAGemBrowserDocument::CAAGemBrowserDocument(CATInteractiveApplication * iParentCommand) 
                      : CATDlgDocument(iParentCommand, &quot;CAAGemBrowserRepWindowId&quot;),
	                _pApplication(iParentCommand),_pTheModelToDisplay(NULL),
                        _p3DViewer(NULL),
                        _piGeomFactory(NULL),_pFileSelector(NULL)
{
  cout &lt;&lt; &quot;CAAGemBrowserDocument::CAAGemBrowserDocument&quot; &lt;&lt; endl;

  // Do not construct any Dialog object child in the constructor 
  // Use the Build Method to do this.
}

void CAAGemBrowserDocument::<strong>Build</strong>()
{
  cout &lt;&lt; &quot;CAAGemBrowserDocument::Build&quot; &lt;&lt; endl;

  CreateMenuBar();
  CreateViewer(); 
}</pre>
<p>The constructor is empty, but calls the base class <code>CATDlgDocument</code> 
constructor, and sets the parent command of the window as the interactive application 
itself. The <code>Build</code> method calls for the creation of the menu bar and 
for the creation of the viewer that allows the user to do 3D manipulations.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Creation of the Menu Bar"></a>Creating the Menu Bar</h4>
<pre class="code">void CAAGemBrowserDocument::<strong>CreateMenuBar</strong>()
{
   CATDlgBarMenu* pMainMenu = NULL;
   pMainMenu = new CATDlgBarMenu(this,&quot;MainMenu&quot;);

   CATDlgSubMenu* pFileMenu = NULL;
   pFileMenu = new CATDlgSubMenu(pMainMenu,&quot;File&quot;);

   CATDlgPushItem* pOpenItem = NULL;
   pOpenItem = new CATDlgPushItem(pFileMenu,&quot;Open&quot;);

   <strong>AddAnalyseNotificationCB</strong>(pOpenItem,
                            pOpenItem-&gt;GetMenuIActivateNotification(), 
                            (CATCommandMethod)&amp;CAAGemBrowserDocument::Open, 
                            NULL); 
    
   CATDlgPushItem* pCloseItem=NULL;
   pCloseItem = new CATDlgPushItem(pFileMenu,&quot;Close&quot;);
   <strong>AddAnalyseNotificationCB</strong>(pCloseItem,
                            pCloseItem-&gt;GetMenuIActivateNotification(), 
                            (CATCommandMethod)&amp;CAAGemBrowserDocument::Close, 
                            NULL);

   CATDlgPushItem * pExitItem =NULL;  
   pExitItem = new CATDlgPushItem(pFileMenu,&quot;Exit&quot;);
   <strong>AddAnalyseNotificationCB</strong>(pExitItem,
                            pExitItem-&gt;GetMenuIActivateNotification(), 
                            (CATCommandMethod)&amp;CAAGemBrowserDocument::Exit, 
                            NULL);
   <strong>AddAnalyseNotificationCB</strong>(this,
                            GetWindCloseNotification(), 
                            (CATCommandMethod)&amp;CAAGemBrowserDocument::Exit, 
                            NULL);
}</pre>
<p>The <code>CreateMenuBar</code> method creates the menu and menu items. Since 
the declaration of an external resource file has been made in the header, the items 
will be displayed according to the chosen language.</p>
<p>Moreover, this method sets the callbacks to trigger the appropriate method when 
a specific control is activated.</p>
<ul>
	<li>If the File/Open menu is selected, a file selector window is activated.</li>
	<li>If the File/Close menu is selected, the model visualization disappears.</li>
	<li>If the File/Exit menu is selected, this ends the application.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Creation of the Viewer"></a>Creating the Viewer</h4>
<p>The 3D navigation viewer is an instance of the CATNavigation3DViewer class. It 
is created in the <code>CreateViewer</code> method of the CAAGemBrowserDocument 
class that is called when the application is launched.</p>
<pre class="code">void CAAGemBrowserDocument::CreateViewer()
{
  // The window contains a 3DViewer which allows the user to do 3D Manipulations 
  _p3DViewer = new CATNavigation3DViewer( this, &quot;3DViewerId&quot;,CATDlgFraNoTitle, 800, 450);

  // Changes the color of the background
  _p3DViewer-&gt;SetBackgroundColor(0.2f,0.2f,0.6f);

  // The Viewer is attached to the 4 sides of the Window
Attach4Sides( _p3DViewer);
}</pre>
<p>The <code>_pViewer</code> pointer to the 3D navigation viewer is kept as a data 
member of the CAAGemBrowserDocument class. The <code>Attach4Sides</code> method 
attaches the four sides of the viewer to those of the window. This makes the viewer 
occupy the whole window space.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Managing the Open Callback"></a>Managing the Open Callback</h4>
<p>Once the user clicks on the File/Open item, the following callback is triggered:</p>
<pre class="code">void CAAGemBrowserDocument::Open  (CATCommand           * iSendingCommand, 
                                   CATNotification      * iSentNotification, 
                                   CATCommandClientData   iUsefulData)
{
  // Creates a File box
  _pFileSelector = new CATDlgFile(this,&quot;FileBox&quot;,NULL);
  _pFileSelector-&gt;SetVisibility(CATDlgShow);
  
  // Sets the authorized types
  CATUnicodeString nameExtension = CATUnicodeString(&quot;NCGM files&quot;);
  CATString filterExtension = CATString(&quot;*.NCGM&quot;);
  _pFileSelector-&gt;SetFilterStrings(&amp;nameExtension, &amp;filterExtension, 1);

  // callbacks on the FileBox interactions
  AddAnalyseNotificationCB(_pFileSelector, 
                           _pFileSelector-&gt;GetDiaCANCELNotification(), 
                           (CATCommandMethod)&amp;CAAGemBrowserDocument::Cancel, 
                           NULL);  
  int iTypeOfInput = 0;
  AddAnalyseNotificationCB(_pFileSelector, 
                           _pFileSelector-&gt;GetDiaOKNotification(), 
                           (CATCommandMethod)&amp;CAAGemBrowserDocument::OpenOK, 
                           &amp;iTypeOfInput);   
}</pre>
<p>This method creates a File Box to select the file to display. The authorized 
type of file extension is <code>*NCGM</code>. Once again, callbacks are set to trigger 
methods when a specific control is activated. In particular, the <code>OpenOK</code> 
method opens the file and visualizes the created objects of the CATGeoFactory container.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Loading the Geometry Factory"></a>Loading the Geometry Factory</h4>
<p>The <code>OpenOK</code> callback:</p>
<ul>
	<li>Retrieves the file to open: <code>GetSelection</code>.</li>
	<li>Loads the <code>CATGeoFactory</code>: <code>CATLoadCGMContainer</code>.</li>
	<li>Creates the representations: <code>CreateModelRepresentation</code>.</li>
	<li>Draws the representations: <code>VisualizeModel</code>.</li>
</ul>
<pre class="code">void CAAGemBrowserDocument::OpenOK(CATCommand           * iSendingCommand, 
                                   CATNotification      * iSentNotification, 
                                   CATCommandClientData   iUsefulData)
{
  // Retrieves the file name
  CATUnicodeString fileName;
  _pFileSelector-&gt;<strong>GetSelection</strong>(fileName);
  delete _pFileSelector; 
  _pFileSelector=NULL;
  
  // Closes the precedeeding factory, if any
  Close(iSendingCommand,  iSentNotification,  iUsefulData);

  // Loads the geometry factory
#ifdef _WINDOWS_SOURCE
  ifstream filetoread(fileName, ios::binary ) ;
#else
  ifstream filetoread(fileName,ios::in,filebuf::openprot) ;
#endif

  _piGeomFactory=<strong>::<a name="CATLoadCGMContainer"></a>CATLoadCGMContainer</strong>(filetoread);
  filetoread.close();

  // Creates the  representation
  <strong>CreateModelRepresentation</strong>();

  // Draws
  <strong>VisualizeModel</strong>();  
} 			</pre>
<p>The <code>CreateModelRepresentation</code> method begins by creating the representation 
bag to attach to the viewer.</p>
<pre class="code">void CAAGemBrowserDocument::<strong>CreateModelRepresentation</strong>()
{
  // The Top of the  representation tree
    _pTheModelToDisplay = new <strong>CAT3DBagRep</strong>();

  // <a name="Scans the geometry factory"></a>Scans the geometry factory to retrieve the objects to visualize
  if (NULL != _piGeomFactory) 
  {
    float sag = 0.1f;
    <strong>CAAGemRep</strong> browser(_piGeomFactory,<strong>sag</strong>);
    CATGeometry* piCurrent = NULL ;
    while ( piCurrent = _piGeomFactory-&gt;<strong>Next</strong> ( piCurrent ) )
    {  
      CAT3DRep * pRep =NULL;
      browser.<strong>CreateRep</strong>(piCurrent, pRep);
      if ( NULL != pRep )
      {
        _pTheModelToDisplay-&gt;<strong>AddChild</strong>(*pRep);
      }
    }
  } 
}</pre>
<p>Then, it defines the <code>CAAGemRep</code> object to compute the representations 
of the geometric objects. The <code>CATGeoFactory</code> is scanned by the <code>
Next</code> method in order to retrieve the objects to visualize. The representation 
of an object is created by the <code>CreateRep</code> method of <code>CATGemRep</code>, 
and added (<code>AddChild</code>) to the representation bag.</p>
<p>The visualization is done by the <code>VisualizeModel</code> method.</p>
<pre class="code">void CAAGemBrowserDocument::VisualizeModel()
{
   if ( (NULL != _p3DViewer) &amp;&amp; ( NULL != _pTheModelToDisplay) )
   {    
      // Attaches the bag to the viewer
      _p3DViewer-&gt;<strong>AddRep</strong>((CAT3DRep*)_pTheModelToDisplay);

      // Reframes on the current bounding sphere
      const CAT3DBoundingSphere boundingSphere = _pTheModelToDisplay-&gt;GetBoundingElement(); 
      _p3DViewer-&gt;<strong>ReframeOn</strong>(boundingSphere);

      // Instruction to do at each  representation modification
      _p3DViewer-&gt;<strong>Draw</strong>();
   }
}</pre>
<ul>
	<li>The bag representation is attached to the viewer.</li>
	<li>The visualization is reframed on the bounding box of the model.</li>
	<li>The viewer is drawn.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Creating the Graphic Representations"></a>Creating the Representations</h3>
<p>CAAGemRep is the class dedicated to the creation of the representations.</p>
<pre class="code">... // GeometricObjects forward declarations

... // Tessellation forward declarations
class CAT3DRep;

#include &quot;CATBoolean.h&quot;
 
class CAAGemRep 
{
  public:
    CAAGemRep(CATGeoFactory * ipiGeomFactory, float iSag);
    ~CAAGemRep();

    //  Creates the  representation of a geometric object
    void <strong>CreateRep</strong>(CATGeometry * ipiToView, CAT3DRep *&amp; iopRep);

    //  Creates the  representation of a body
    void <strong>CreateBodyRep</strong>(CATBody * ipiBody, CAT3DRep *&amp; iopRep);  

    //  Creates the  representation of a face
    //  The arguments are the output of the tessellation cell or body operators
    void <strong>CreateSurfaceRep</strong>(CATBoolean          iPlane,
                          CATSide             iSide, 
                          CATTessPointIter  * iPoints,
                          CATTessStripeIter * iStrips,
                          CATTessFanIter    * iFans,
                          CATTessPolyIter   * iPolygons,
                          CATTessTrianIter  * iTriangles,
                          CAT3DRep *&amp; iopRep);

    //  Creates the  representation of a plane
    void <strong>CreatePlaneRep</strong>(CATPlane *piPlane, CAT3DRep *&amp; iopRep);

    //  Creates the  representation of an edge
    //  The arguments are the output of the tessellation cell or body operator
    void <strong>CreateEdgeRep</strong>  (CATEdge * ipiEdge, 
                         long &amp; ioNumOfPoints,
                         float * oaPoints, 
                         CAT3DRep *&amp; iopRep);

    //  Creates the  representation of a curve
    //  The arguments are the output of CATCurveTessellator
    void <strong>CreateCurveRep</strong> (long &amp; ioNumOfPoints,
                         float * oaPoints, 
                         CAT3DRep *&amp; iopRep);

    //  Creates the  representation of a line
    void <strong>CreateLineRep</strong>(CATLine *piLine, CAT3DRep *&amp; iopRep);

    //  Creates the  representation of a point
    void <strong>CreatePointRep</strong>  (CATMathPoint &amp; point,CAT3DRep *&amp; iopRep);

  private:
    CAAGemRep ();
    CAAGemRep(const CAAGemRep &amp;iObjectToCopy);
  
    CATGeoFactory * _piGeomFactory; // The geometry factory that is visualized
    float          _sag;           // The tessellation sag
};</pre>
<ol>
	<li><code>CreateRep</code> directs the creation of different kinds of representations, 
	according to the different types of objects.</li>
	<li><code>CreateBodyRep</code> tessellates a body and creates the corresponding 
	representation.</li>
	<li><code>CreateSurfaceRep</code> creates the representation of a surface from 
	the results of a tessellation operator.</li>
	<li><code>CreateEdgeRep</code> creates the representation of a curve from the 
	results of a tessellation operator.</li>
	<li><code>CreateCurveRep</code> creates the representation of a curve (that 
	is not a line) from the results of a tessellation operator.</li>
	<li><code>CreateLineRep</code> directly creates the representation of a line.</li>
	<li><code>CreatePlaneRep</code> directly creates the representation of a plane.</li>
	<li><code>CreatePointRep</code> directly creates the representation of a point.</li>
</ol>
<p>The private data are the pointer to the <code>CATGeoFactory</code> container 
that is visualized, and the sag used to define the tessellation [<a href="#References">2</a>].</p>
<p>The structure of the <strong>CreateRep</strong> method is as follows:</p>
<pre class="code">void CAAGemRep::<strong>CreateRep</strong>(CATGeometry * ipiToView, CAT3DRep *&amp; iopRep)
{
 
  if (NULL!= ipiToView)
  {
    // ------ <a href="#Body">Body visualization</a>
    if (0!=ipiToView-&gt;<strong>IsATypeOf</strong>(<strong>CATBodyType</strong>)) 
    { 
       CATBody * piBody=(CATBody * )ipiToView;
       CreateBodyRep(piBody,iopRep);
    }
    // ------ Curve visualization
    else if (0!=ipiToView-&gt;IsATypeOf(<strong>CATCurveType</strong>))
    {
       if (0== ipiToView-&gt;<strong>GetUseCount</strong>())      // to only visualize alone curves
       {       
         // ------ <a href="#Visualizing a Line">Line</a>
         if (0!=ipiToView-&gt;IsATypeOf(<strong>CATLineType</strong>))
         {
            CATLine * piLine=(CATLine*)ipiToView;
            CreateLineRep(piLine,iopRep);               
         }
         else
         // ------ <a href="#Curve">other curves</a>         
         {   
            ... --&gt; use a CATCurveTessellator 
         }
       }
    }
    // ------ Surface
    else if (0!=ipiToView-&gt;IsATypeOf(<strong>CATSurfaceType</strong>))
    {
       CATSurface * piSurface = (CATSurface * )ipiToView;
       
        if (0== ipiToView-&gt;<strong>GetUseCount</strong>()) // only visualizes surfaces that are not pointed to
        {     
         // ----- <a href="#Plane">Plane</a>
         if(ipiToView-&gt;IsATypeOf(<strong>CATPlaneType</strong>))
         {
            CATPlane * piPlane=(CATPlane*)ipiToView;
            CreatePlaneRep(piPlane,iopRep);
         }
         else
         // <a href="#Surface">Other surfaces</a>
         {
           ... --&gt; use CATSurfaceTessellator
         } 
       }
    }
    // <a href="#Point">Point</a>
    else if (0!=ipiToView-&gt;IsATypeOf(<strong>CATPointType</strong>))
    {
       if (0== ipiToView-&gt;GetUseCount())
       {
          CATPoint * piPoint = (CATPoint*)ipiToView;
          CATMathPoint point;
          piPoint-&gt;GetMathPoint(point);
          CreatePointRep(point,iopRep);
       }
    }
  }  
}</pre>
<p>The creation of the representations is managed according to the type of the geometric 
object, retrieved with the <code>CATICGMContainer::IsATypeOf</code> method. In case 
of surfaces, curves, or points, the choice of the use case is to visualize only 
objects that are not pointed to by any other object. Hence the <code>CATICGMObject::GetUseCount</code> 
returns if an object is pointed to or not.</p>
<p>We now examine in detail all the type of geometry: point, line, curve, plane, 
surface and body.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Point"></a>Representation of a Point</h4>
<p>The coordinates of the point are directly passed to the constructor of the representation.</p>
<pre class="code">void CAAGemRep::CreatePointRep  (CATMathPoint &amp; point,CAT3DRep *&amp; iopRep)
{
   // Gets the coordinates of the point
   double ioFirstCoord,ioSecondCoord,ioThirdCoord;
   point.<strong>GetCoord</strong>(ioFirstCoord,ioSecondCoord,ioThirdCoord);
   float aCoord[3];
   aCoord[0]= (float)ioFirstCoord;
   aCoord[1]= (float)ioSecondCoord;
   aCoord[2]= (float)ioThirdCoord;
    
   // Creates the rep
   CAT3DPointRep *rep = new <strong>CAT3DPointRep</strong>(aCoord,FULLCIRCLE);

   // Returns the rep
   iopRep = rep;
}</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Visualizing a Line"></a>Representation of a Line</h4>
<p>The lines have a specific treatment: they do not need to be discretized. Two 
cases are considered: finite (or trimmed) and infinite lines. To know if a line 
is infinite, the model size of the <code>CATGeoFactory</code> container is retrieved 
(<code>GetModelSize</code>). The model size defines the maximum bounding box of 
the model [<a href="#References">3</a>] and one tests whether this maximum bounding 
box includes the extremities of the curve.</p>
<pre class="code">void CAAGemRep::CreateLineRep(CATLine *piLine, CAT3DRep *&amp; iopRep)
{
  CAT3DRep *pRep = NULL;

  CATCrvParam startParam, endParam  ;
  piLine-&gt;GetStartLimit(startParam);
  piLine-&gt;GetEndLimit(endParam);

  // The start and end points of the line
  CATMathPoint startPoint =piLine-&gt;EvalPoint(startParam);
  CATMathPoint endPoint =piLine-&gt;EvalPoint(endParam);
  CATMathPointf start, end;
  start.x = (float) startPoint.GetX();
  start.y = (float) startPoint.GetY();
  start.z = (float) startPoint.GetZ();
  end.x   = (float) endPoint.GetX();
  end.y   = (float) endPoint.GetY();
  end.z   = (float) endPoint.GetZ();

  // <a name="Is the line infinite"></a>Is the line infinite?
  double infinity=piLine-&gt;GetContainer()-&gt;<strong>GetModelSize</strong>();
  CATMathBox boxInfinite(-infinity,infinity,-infinity,infinity,-infinity,infinity) ;
  int isFinite = (boxInfinite.IsContaining(startPoint) 
                    &amp;&amp; boxInfinite.IsContaining(endPoint) ) ? 1 : 0;
  
  if ( isFinite )
  {
    // Creates the rep of the finite line 
    CAT3DLineRep* pRepresentation = new <strong>CAT3DLineRep</strong>();
    pRepresentation-&gt;<strong>Modify</strong>(start,end);
    pRep = pRepresentation;
  }
  else
  {
    // Creates a special rep: an arrow 
    CATMathLine line(startPoint,endPoint);
    CATMathPoint origin, projpt;
    line.Project(origin,projpt);
    CATMathVector vect;
    line.GetDirection(vect);
     
    CATMathPointf  ptf((float)projpt.GetX(), (float)projpt.GetY(), (float)projpt.GetZ());
    CATMathVectorf tf(vect);
     
    CAT3DCustomRep  * pBagGP = new CAT3DCustomRep();     
    CAT3DFixedArrowGP* pArrow = new <strong>CAT3DFixedArrowGP</strong>(ptf,tf, 40, 2);
    CATGraphicAttributeSet attribute;  
    pBagGP-&gt;AddGP(pArrow,attribute);  
    pRep = pBagGP;
  }
  // Returns the rep
  iopRep = pRep;
}</pre>
<p>In case of a finite line, a CAT3DLineRep instance is modified to be trimmed by 
the start and end limits of the line, thus defining the representation of the line.</p>
<p>In case of an infinite line, an arrow is visualized: a CAT3DFixedArrowGP is created 
at the origin of the line, along its direction. The total arrow length is 40 millimeters, 
and the head height is 2 millimeters.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Curve"></a>Representation of a Curve</h4>
<p>We are here in the <code>CreateRep</code> method of CAAGemRep. We describe now 
the code under the <em>other curves</em> comment.</p>
<p>In case of a curve, the program first checks that the curve is not degenerated. 
The bounding box of the current limits is first retrieved with the <code>CATCurve::GetBox</code> 
method, the length of its diagonal is then computed. If this length is<span lang="fr">:</span></p>
<ul>
	<li>Less than the factory resolution (<code>CATGeoFactory::GetResolution</code>), 
	the representation of a point is created. The point is evaluated with <code>
	CATCurve::Eval</code>.</li>
	<li>Greater than the factory resolution. The <code>CATICGMCurveTessellator</code> 
	operator computes the data used to create the representation of a curve. The 
	representation itself is created in the <code>CreateCurveRep</code> method that 
	is later detailed.</li>
</ul>
<pre class="code">// piCurve is the pointer to the interface of a curve to visualize
// Is the curve a curve or a point? <a name="Gets the bounding box"></a>Gets the bounding box of its limits.
CATMathBox boundingBox;
CATMathPoint low,high;
CATCrvLimits limits;
piCurve-&gt;GetLimits(limits);
piCurve-&gt;<strong>GetBox</strong>(limits,boundingBox);
boundingBox.GetLow(low);
boundingBox.GetHigh(high);
CATMathVector diagonal=high-low;
double diagonalLength= diagonal.Norm();

// really a curve to visualize
if ( diagonalLength &gt; _piGeomFactory-&gt;<strong><a name="GetResolution"></a>GetResolution</strong>() )
{     
  CATICGMCurveTessellator * pCurveTess = <strong><a name="CATCurveTessellator"></a>CATCGMCreateCurveTessellator</strong>(_sag);
  if (NULL!=pCurveTess)
  {

    pCurveTess -&gt; <strong>AddCurve</strong>(piCurve, limits);
    pCurveTess -&gt; <strong>Run</strong>();
              
    // Retrieves the tessellation results
    long  numOfPoints;
    float * aPoints= NULL;
    pCurveTess-&gt; <strong>GetCurve</strong> (piCurve, numOfPoints, &amp;aPoints);

    // Creates the rep
    <strong>CreateCurveRep</strong> (numOfPoints,aPoints,iopRep);

    pCurveTess-&gt;Release();
    pCurveTess=NULL;
  } 
}
// The curve is a point
else
{
  CATCrvParam crvParam;
  piCurve-&gt;GetStartLimit(crvParam);
  CATMathPoint pt;
  piCurve-&gt;<strong>Eval</strong>(crvParam, CATCrvEvalCommand::EvalPoint, &amp;pt);
  <strong>CreatePointRep</strong>(pt,iopRep);
}</pre>
<p>To use the <code>CATICGMCurveTessellator</code> operator:</p>
<ul>
	<li>Create it<span lang="fr">.</span></li>
	<li>Add the curve(s) to tessellate, and precise their limits<span lang="fr">.</span></li>
	<li>Run it<span lang="fr">.</span></li>
	<li>Get the tessellation results<span lang="fr">.</span></li>
	<li>Release it<span lang="fr">.</span></li>
</ul>
<p>The tessellation results are used by the method <code>CreateCurveRep</code> of
<code>CAAGemRep</code> to create the representation as follows.</p>
<pre class="code">void CAAGemRep::CreateCurveRep  (long &amp; ioNumOfPoints, 
                                 float * oaPoints, 
                                 CAT3DRep *&amp; iopRep)
{
  CAT3DCurveRep*   pCurveRep = NULL;
  
  // Creates the rep
  CAT3DPolylineGP* polylineGP = new <strong>CAT3DPolylineGP</strong>(oaPoints, ioNumOfPoints, 1);
  pCurveRep  = new CAT3DCurveRep();
  pCurveRep-&gt;<strong>AddWireframeLOD</strong>(0,polylineGP, _sag);

  // Defines the bounding box 
  float xmin=1.e+10,ymin=1.e+10,zmin=1.e+10,xmax=-1.e+10,ymax=-1.e+10,zmax=-1.e+10;
  for (int j=0, curj=0; j&lt;ioNumOfPoints; j++, curj+=3)
  {
    if(oaPoints[curj+0] &lt; xmin) xmin=oaPoints[curj+0];
    if(oaPoints[curj+1] &lt; ymin) ymin=oaPoints[curj+1];
    if(oaPoints[curj+2] &lt; zmin) zmin=oaPoints[curj+2];
    if(oaPoints[curj+0] &gt; xmax) xmax=oaPoints[curj+0];
    if(oaPoints[curj+1] &gt; ymax) ymax=oaPoints[curj+1];
    if(oaPoints[curj+2] &gt; zmax) zmax=oaPoints[curj+2];
  }
  CATMathPointf center((float) (xmin+xmax)/2.f, 
                       (float) (ymin+ymax)/2.f, 
                       (float) (zmin+zmax)/2.f);
  double radius= sqrt((xmax-xmin)*(xmax-xmin)+
                      (ymax-ymin)*(ymax-ymin)+
                      (zmax-zmin)*(zmax-zmin))/2.f;
  pCurveRep-&gt;<strong>SetBoundingElement</strong>(CAT3DBoundingSphere(center, (float)radius));
 
  // Returns the rep
  iopRep = pCurveRep;
}</pre>
<p>The representation of a curve is a collection of graphic polylines <code>CAT3DPolylineGP</code>, 
each one representing a level of detail (LOD). Here, one LOD is added to the curve 
representation (<code>AddWireframeLOD</code>), with a level a detail having
<code>_sag</code> as the corresponding sag value. Finally, the bounding box is computed 
from the tessellation results and set to the curve representation.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Plane"></a>Representation of a Plane</h4>
<p>The origin and the axes of the plane are directly passed to the constructor of 
the representation. As the plane is infinite, a given size is fixed. The associated 
bounding sphere is also set to the representation.</p>
<pre class="code">void CAAGemRep::CreatePlaneRep(CATPlane *piPlane, CAT3DRep *&amp; iopRep)
{
  CATMathPlane plane;

  // Gets the mathematical definition
  piPlane-&gt;GetAxis(plane);
  CATMathPoint      center = plane.GetOrigin();
  CATMathDirection  vAxis  = plane.GetSecondDirection();
  CATMathDirection  uAxis  = plane.GetFirstDirection();
  CATMathPointf     origin((float) center.GetX(), 
                           (float) center.GetY(), 
                           (float) center.GetZ());
  CATMathDirectionf u((float) uAxis.GetX(), 
                      (float) uAxis.GetY(), 
                      (float) uAxis.GetZ());
  CATMathDirectionf v((float) vAxis.GetX(), 
                      (float) vAxis.GetY(), 
                      (float) vAxis.GetZ());
  
  float size = 20.f;
  float radius  = 15.f;

  // Creates the rep
  CAT3DPlanRep *pRep = new <strong>CAT3DPlanRep</strong>(origin,u,v,size);
  
  CAT3DBoundingSphere *pBe = new CAT3DBoundingSphere(origin,0.f,radius);
  pRep-&gt;SetBoundingElement(*pBe);
  delete pBe;
  pBe=NULL;

  // Returns the rep
  iopRep = pRep;
}</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Surface"></a>Representation of a Surface</h4>
<p>We are here in the <code>CreateRep</code> method of CAAGemRep. We describe now 
the code under the <em>other surfaces</em> comment.</p>
<p>The surface is first tessellated with <code>CATSurfaceTessellator</code>.</p>
<pre class="code">// piSurface is the pointer to the surface to visualize
CATSurLimits limits;
piSurface-&gt;GetLimits(limits);
CATICGMSurfaceTessellator * pSurfTess = <strong>CATCGMCreateSurfaceTessellator</strong>(_sag);
if (NULL!=pSurfTess)
{
  pSurfTess -&gt; <strong>AddSurface</strong>(piSurface, limits);
  pSurfTess -&gt; <strong>Run</strong>();
              
  CATBoolean isPlanar;
  CATTessPointIter *    pPoints    = NULL;
  CATTessStripeIter *   pStrips    = NULL;
  CATTessFanIter *      pFans      = NULL;
  CATTessPolyIter *     pPolygons  = NULL;
  CATTessTrianIter *    pTriangles = NULL;
     
  pSurfTess -&gt; <strong>GetSurface</strong>(piSurface,isPlanar,
                          &amp;pPoints,&amp;pStrips,&amp;pFans,&amp;pPolygons,&amp;pTriangles);
  CATSide side=CATSideUnknown;
  <strong>CreateSurfaceRep</strong>(isPlanar,side, pPoints, pStrips,pFans, pPolygons, pTriangles,iopRep);
              
  pSurfTess-&gt;Release();
  pSurfTess=NULL;
}</pre>
<p>To use the <code>CATICGMSurfaceTessellator</code> operator:</p>
<ul>
	<li>Create it.</li>
	<li>Add the surface(s) to tessellate, and precise their limits.</li>
	<li>Run it.</li>
	<li>Get the tessellation results.</li>
	<li>Release it.</li>
</ul>
<p>The tessellation results are used by the method <code>CreateSurfaceRep</code> 
of <code>CAAGemRep</code> to create the representation as follows:</p>
<ul>
	<li>Computing the normals and the bounding box: the iterator on the points is 
	used<span lang="fr">.</span></li>
	<li>Retrieving the isolated triangles with <code>CATTessTrianIter</code>.</li>
	<li>Retrieving the triangle strips with <code>CATTessStripeIter</code>.</li>
	<li>Creating the graphic primitives.</li>
</ul>
<p>We now detail the use of the point iterator to retrieve the normals in case of 
a non-planar surface.</p>
<pre class="code">// <a name="allocation of the arrays"></a>allocation of the arrays
  long numberOfPoints = ipPoints-&gt;<strong>GetNbPoint</strong>();
  if (numberOfPoints == 0) return ;
  
  long verticesArraySize = numberOfPoints*3 ;
  float * vertices = new float [verticesArraySize];
  long normalsArraySize = verticesArraySize ;
  float * normals = new float [normalsArraySize];

// iterator on the points 
// ipPoints is the CATTessPointIterator retrieved from the tessellator
  i = 0 ;
  double const  * ptd;   
  while ( ipPoints-&gt;<strong>IsExhausted</strong>()==0 ) 
  {
    ptd = ipPoints-&gt;<strong>GetPointXyz</strong>();
    vertices[i  ] = (float) ptd[0] ;
    vertices[i+1] = (float) ptd[1] ;
    vertices[i+2] = (float) ptd[2] ;
    
    if (xmin &gt; vertices[i  ]) xmin=vertices[i  ];
    if (ymin &gt; vertices[i+1]) ymin=vertices[i+1];
    if (zmin &gt; vertices[i+2]) zmin=vertices[i+2];
    if (xmax &lt; vertices[i  ]) xmax=vertices[i  ];
    if (ymax &lt; vertices[i+1]) ymax=vertices[i+1];
    if (zmax &lt; vertices[i+2]) zmax=vertices[i+2];
    
    if (!iPlane) { // the surface is not a plane
      CATBoolean b = ipPoints-&gt;<strong>GetPointNor</strong>(vector);
      if ( b ) 
      {
        if (ori&lt;0) 
        {// the normal must be inverted
          normals[i+0] = (float) -vector-&gt;GetX() ;
          normals[i+1] = (float) -vector-&gt;GetY() ;
          normals[i+2] = (float) -vector-&gt;GetZ() ;
        } else {
          normals[i+0] = (float) vector-&gt;GetX() ;
          normals[i+1] = (float) vector-&gt;GetY() ;
          normals[i+2] = (float) vector-&gt;GetZ() ;
        }
      } else {
        // default normal: it is not computed by the tessellation
        normals[i+0] = 1.0 ;
        normals[i+1] = 0.0 ;
        normals[i+2] = 0.0 ;
      }
    }
    i +=3  ;
    ipPoints-&gt;<strong>GoToNext</strong>();
  }</pre>
<p><code>CATTessPointIterator::GetNbPoints</code> outputs the number of points computed 
by the tessellation. Now, the iterator is used as follows:</p>
<ul>
	<li>The <code>IsExhauted</code> method declares whether the end is reached. If 
	there is no points anymore, it returns <code>0</code>.</li>
	<li>The <code>GetPointXyz</code> returns the current point. The coordinates of 
	this point are then put in the array that will be passed to the graphic primitive 
	creation.</li>
	<li>The <code>GetPointNor</code> returns the normal to the surface at the current 
	point. The coordinates of this normal are also put in an array to be later used.</li>
	<li>The <code>GoToNext</code> method skips to the next point of the iterator.</li>
</ul>
<p>Now, the isolated triangles are read with the <code>CATTessTrianIter</code> iterator 
created by the tessellator. Its use is similar to the use of a <code>CATTessPointIter</code>.</p>
<pre class="code">  long  numberOfTriangles = ipTriangles-&gt;<strong>GetNbTrian</strong>();
  if ( NULL!= numberOfTriangles ) 
  {
    triangleIndice = new int [3 * numberOfTriangles] ;
    i = 0 ;
    while ( ipTriangles-&gt;<strong>IsExhausted</strong>()==0 ) {
      ipTriangles-&gt;<strong>GetTrianNuPts</strong>(NuPts);
      
      if (ori &lt;0) {
        // triangles must be inverted
        triangleIndice[i]   =  NuPts[2]*3 ;
        triangleIndice[i+1] =  NuPts[1]*3 ;
        triangleIndice[i+2] =  NuPts[0]*3 ;
      } else {
        triangleIndice[i]   = NuPts[0]*3 ;
        triangleIndice[i+1] = NuPts[1]*3 ;
        triangleIndice[i+2] = NuPts[2]*3 ;
      }
      i += 3 ;
      ipTriangles-&gt;<strong>GoToNext</strong>();
    }
  }</pre>
<p>As this method is also used to create the representation of a face, the relative 
orientation of the face and the surface is taken into account here by the <code>
ori</code> value, initialized with the corresponding output of the tessellator. 
In the same way, the strips of triangles are retrieved.</p>
<pre class="code">  long TotalPointNb=0;
  long numberOfStrips = ipStrips-&gt;<strong>GetNbStri</strong>(TotalPointNb) ; 
  if ( numberOfStrips ) {
    nbVertexPerTriangleStrip = new int [numberOfStrips] ;
    triangleStripIndice = new int [TotalPointNb] ;
    i = 0 ;
    j = 0 ;
    while ( ipStrips-&gt;<strong>IsExhausted</strong>()==0 ) {
      nbVertexPerTriangleStrip[i] = ipStrips-&gt;GetStriNbPts(); 
      ipStrips -&gt;<strong>GetStriNuPts</strong>( &amp;(triangleStripIndice[j]) ) ;
      for ( k=0 ; k &lt; nbVertexPerTriangleStrip[i] ; k++ ) {
        triangleStripIndice[j+k] *= 3 ;
      }
      if (ori &lt;0) {
        // Inverts to strip: Swap 2 by 2
        int m=0 ;
        for ( int l=0; l&lt;(nbVertexPerTriangleStrip[i])/2 ;l++) {
          int i1 = triangleStripIndice[j+m];
          triangleStripIndice[j+m] = triangleStripIndice[j+m+1];
          triangleStripIndice[j+m+1] = i1 ;
          m +=2 ;
        }
      }
      j += nbVertexPerTriangleStrip[i] ;
      i += 1;
      ipStrips-&gt;<strong>GoToNext</strong>();
    }
  } </pre>
<p>Now, the representation can be created.</p>
<pre class="code">  CAT3DFaceGP * faceGP = NULL;
  if ( iPlane )
    faceGP = new <strong>CAT3DPlanarFaceGP</strong>(vertices,verticesArraySize,
                                   normals,
                                   triangleIndice,numberOfTriangles,
                                   triangleStripIndice, numberOfStrips, nbVertexPerTriangleStrip,
                                   triangleFanIndice,  numberOfFans,  nbVertexPerTriangleFan);
  
  else
    
    faceGP = new <strong>CAT3DFaceGP</strong>(vertices,verticesArraySize,
                             normals,normalsArraySize,
                             triangleIndice,numberOfTriangles, 
                             triangleStripIndice, numberOfStrips, nbVertexPerTriangleStrip,
                             triangleFanIndice,numberOfFans,nbVertexPerTriangleFan);
  
  if (NULL!=vertices)                 delete [] vertices;
  if (NULL!=normals)                  delete [] normals;
  if (NULL!=triangleIndice)           delete [] triangleIndice ;
  if (NULL!=triangleStripIndice)      delete [] triangleStripIndice ;
  if (NULL!=nbVertexPerTriangleStrip) delete [] nbVertexPerTriangleStrip ;
  if (NULL!=triangleFanIndice )       delete [] triangleFanIndice ;
  if (NULL!=nbVertexPerTriangleFan )  delete [] nbVertexPerTriangleFan ;

  CAT3DCustomRep * pSurfacicRep = new <strong>CAT3DCustomRep</strong>();
  CATGraphicAttributeSet ag ;
  ag.SetType(2);
  pSurfacicRep-&gt;<strong>AddGP</strong>(faceGP,ag);

  // Gets the bounding box
  CATMathPointf Center(float((xmin+xmax)/2.),
                       float((ymin+ymax)/2.),
                       float((zmin+zmax)/2.));
  double BoundingSphereRadius= sqrt((xmax-xmin)*(xmax-xmin)+
                                    (ymax-ymin)*(ymax-ymin)+
                                    (zmax-zmin)*(zmax-zmin))/2.;
  CAT3DBoundingSphere BoundingSphere( Center, float(BoundingSphereRadius));
  pSurfacicRep-&gt;<strong>SetBoundingElement</strong>(BoundingSphere); </pre>
<p>The graphic primitive is first created: it is a CAT3DPlanarFaceGP for a planar 
surface or a CAT3DFaceGP for a non-planar surface. This primitive is added to a 
new CAT3DCustomRep. The computed bounding box is set with the <code>SetBoundingElement</code> 
method, thus ending the construction of the surface representation.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Body"></a>Representation of a Body</h4>
<p>All the previous methods are used to create the representation of a body.
<code>CATICGMCellTessellator</code> is used to create data needed by the <code>CreateSurfaceRep</code> 
and <code>CreateCurveRep</code> methods. The faces, edges of wire domains, and vertices 
in volume are tessellated. In particular, neither the edges of the face, nor the 
vertices of the edges are represented.</p>
<pre class="code">void CAAGemRep::CreateBodyRep(CATBody * ipiBody, CAT3DRep *&amp; iopRep)  
{
 ...
 iopRep=NULL;
 CAT3DBagRep* pBagRep = NULL;
 pBagRep = new CAT3DBagRep();

 CATICGMCellTessellator * pTessellator = <strong>CATCGMCreateCellTessellator</strong>(_sag);

 //-------------------------------------------------- 
 // Tessellates the faces
 //-------------------------------------------------- 
 if (NULL!=pTessellator)
 {
   // Retrieves all the faces
   CATLISTP(CATCell) cells;
   ipiBody-&gt;GetAllCells( cells,2);   // 2 for retrieving the faces
   int numberOfCells = cells.Size();
  
   for (int ifa=1 ; ifa&lt;=numberOfCells ; ifa++)
   {
     pTessellator-&gt;<strong>AddFace</strong>((CATFace *)(cells[ifa]));
   }
   pTessellator -&gt; <strong>Run</strong>();
 
   // for each face, retrieve the tessellation results
  
   for (ifa=1 ; ifa&lt;=numberOfCells ; ifa++)
   {   
     CATFace * piFace = (CATFace*) cells[ifa]; 
    
     // a special visualization for infinite face
     if (TRUE== piFace-&gt;<strong>GetInfinite</strong>())
     {
       CATOrientation ori;
       CATGeometry*    piGeom= piFace-&gt;GetGeometry(&amp;ori);
       if (NULL!= piGeom &amp;&amp; piGeom-&gt;IsATypeOf(CATPlaneType) )
       {
          CATPlane * piPlane = (CATPlane *)piGeom;      
          CAT3DRep* pRep=NULL;
          <strong>CreatePlaneRep</strong>(piPlane,pRep);
          if (NULL!=pRep)
         {
          if (NULL== pBagRep) pBagRep = new CAT3DBagRep();
          pBagRep-&gt;AddChild(*pRep);
         }
       }
     }
     else
     {
       CATBoolean isPlanar;
       CATTessPointIter *    pPoints  = NULL;
       CATTessStripeIter *   pStrips    = NULL;
       CATTessFanIter *      pFans      = NULL;
       CATTessPolyIter *     pPolygons  = NULL;
       CATTessTrianIter *    pTriangles = NULL;
       short side;
     
       pTessellator -&gt; <strong>GetFace</strong>(piFace,isPlanar,&amp;pPoints,&amp;pStrips,&amp;pFans,&amp;pPolygons,&amp;pTriangles,&amp;side);
       CAT3DRep * pRep=NULL;
       <strong>CreateSurfaceRep</strong>(isPlanar, side, pPoints, pStrips,pFans, pPolygons, pTriangles,pRep);
       if (NULL!=pRep)
       {
          if (NULL== pBagRep) pBagRep = new CAT3DBagRep();
          pBagRep-&gt;AddChild(*pRep);
       }
     }
   }
   pTessellator-&gt;Release();
   pTessellator = NULL;
 }

 //-------------------------------------------------- 
 // Now tessellate the wire domains (not the edges of faces)
 //-------------------------------------------------- 
 // ......
  
 // Returns the rep
 iopRep=pBagRep;
}</pre>
<p>All the faces of the body are retrieved in one shot with the <code>GetAllCells</code> 
method of the CATTopology interface from which the body derives. The 2 value is 
the dimension for the faces. All these faces are <code>Add</code>ed to <code>CATICGMCellTessellator</code>, 
that is then <code>Run</code>. Now, for each face, the results are retrieved:</p>
<ul>
	<li>If the face is infinite, the representation of a plane is created, if the 
	associated geometry is a plane.</li>
	<li>Otherwise, the <code>GetFace</code> method of the <code>CATICGMCellTessellator</code> 
	returns all the data that is needed to create the representation of a surface.</li>
</ul>
<p>The tessellator is released after use.</p>
<p>The way to create the representation of the vertices in volume and the edges 
of the wires is very similar.</p>
<pre class="code">// <a name="the number of domains"></a>the number of domains
 long nbDomains= ipiBody-&gt;<strong>GetNbDomains</strong>();
 CATLISTP(CATCell)  cells;
 int numberOfCells =0;

 for (int dom = 1;dom&lt;=nbDomains;dom++)
 {
   CATDomain * piDomain = ipiBody-&gt;<strong>GetDomain</strong>( dom );
    
   // ------ Wire
   if (NULL!=piDomain &amp;&amp; 1==(piDomain-&gt;IsATypeOf(<strong>CATWireType</strong>)) )
   {
     // Creates a cell tessellator
     pTessellator = CATCGMCreateCellTessellator(_sag); 
     if (pTessellator!=NULL)
     {
       // Retrieves the number of edges of the wire
       cells.RemoveAll();
       piDomain-&gt;<strong>GetAllCells</strong>(cells,1);
       numberOfCells = cells.Size();
       
       // Adds the edges to tessellate
       for  (int i=1 ; i&lt;=numberOfCells ; i++)
       { 
         CATEdge * piEdge = (CATEdge*) cells[i];
         pTessellator -&gt; <strong>AddEdge</strong>(piEdge);
       }

       // Runs it
       pTessellator-&gt;<strong>Run</strong>();
    
       // for each each edge 
       for  ( i=1 ; i&lt;=numberOfCells ; i++)
       { 
         CATEdge * piEdge = (CATEdge*) cells[i];
         long  numOfPoints;
         float   * aPoints= NULL;
         
         // Retrieves the tessellation results
         pTessellator -&gt; <strong>GetEdge</strong>(piEdge,numOfPoints,&amp;aPoints);

         CAT3DRep * pRep=NULL;

         // Creates the rep
         <strong>CreateEdgeRep</strong> (piEdge, numOfPoints,aPoints,pRep);
         if (NULL!=pRep)
         {
          if (NULL== pBagRep) pBagRep = new CAT3DBagRep();
          pBagRep-&gt;AddChild(*pRep);
         }
       }
       pTessellator-&gt;Release();
       pTessellator = NULL;
     }
   }

   //  ----- and the points
   else if(NULL!=piDomain &amp;&amp; 1==(piDomain-&gt;IsATypeOf(<strong>CATVertexInVolumeType</strong>)))
   {
     
     CATCell * piCell = piDomain-&gt;<strong>GetCell</strong>(1);
     if (NULL!=piCell) 
     {
       CATVertex * piVertex=(CATVertex * )piCell;

       // Gets the geometry of the vertex
       CATPoint * piPoint = piVertex-&gt;GetPoint();

       // Creates the rep
       CAT3DRep * pRep=NULL;
       CATMathPoint point;
       piPoint-&gt;GetMathPoint(point);
       <strong>CreatePointRep</strong>  (point,pRep);
       if (NULL!=pRep)
       {
          if (NULL== pBagRep) pBagRep = new CAT3DBagRep();
          pBagRep-&gt;AddChild(*pRep);
       }

     }	
   }
 }</pre>
<p>We first loop on all the domains of the body. <code>GetDomain</code> returns 
the pointer to the i-th domain.</p>
<ul>
	<li>If the domain is a wire:
	<ul>
		<li><span lang="fr">A</span>ll the edges of this wire are retrieved: <code>GetAllCells</code> is 
		called with 1.</li>
		<li>They are <code>Add</code>ed to the created <code>CATICGMCellTessellator</code>.</li>
		<li>The tessellator is <code>Run</code>.</li>
		<li>For each edge, the tessellation results are retrieved: <code>GetEdge</code>.</li>
		<li>These results are passed to <code>CreateEdgeRep</code> that created 
		the representation.</li>
		<li>The tessellator is released after use.</li>
	</ul>
	</li>
	<li>If the domain is a vertex in volume:
	<ul>
		<li>The unique cell of this domain is retrieved.</li>
		<li>The representation of the corresponding point is created.</li>
	</ul>
	</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Edge"></a>Representation of an Edge</h4>
<p>The representation is created in a very similar way as in the curve case. They 
only differ by the process of the degenerated elements</p>
<pre class="code">void CAAGemRep::CreateEdgeRep  (CATEdge * ipiEdge, 
                                long &amp; ioNumOfPoints, 
                                float * oaPoints, 
                                CAT3DRep *&amp; iopRep)
{
  CAT3DRep *pRep = NULL;
  	   
  CATMathBox boundingBox;
  CATMathPoint low,high;
  
  ipiEdge-&gt;GetBoundingBox(boundingBox);
  boundingBox.GetLow(low);
  boundingBox.GetHigh(high);
  CATMathVector diagonal=high-low;
  double diagonalLength= diagonal.Norm();
  
  if ( diagonalLength &gt; _piGeomFactory-&gt;<strong>GetResolution</strong>() )
  {		     		
     <strong>CreateCurveRep</strong> (ioNumOfPoints,oaPoints,pRep);
  }
  // The edge is a point
  else
  {
    //Gets the coordinates of a point
    CATPointOnEdgeCurve *piStartPoec=NULL;
    ipiEdge-&gt;<strong>GetVerticesPointsOnEdgeCurve</strong>(&amp;piStartPoec,NULL );
    CATMathPoint pt;
    piStartPoec-&gt;GetMathPoint(pt);
    <strong>CreatePointRep</strong>(pt,pRep);
  }

  // Returns the rep
  iopRep = pRep;
}</pre>
<p>If the edge has a length greater than the factory resolution, the representation 
of a curve is created.</p>
<p>Otherwise, one point of the edge is recovered, and a representation of this point 
is created. Notice that to get the points extremities of an edge, the <code>CATEdge::GetVerticesPointsOnEdgeCurve</code> 
method can be used.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This use case offers the programmer a way to visualize the geometry and topology 
created by the CATGeoFactory. Meanwhile, it illustrates how to tessellate geometric 
objects.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAACgmUcTesBody.htm">Using a Tessellation Operator</a></td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1.1</strong> [Nov 2000]</td>
		<td>Use of CAT3DCustomRep for the graphic representation of a surface representation.</td>
	</tr>
	<tr>
		<td>Version: <strong>1</strong> [Jun 2000]</td>
		<td>Document created</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
