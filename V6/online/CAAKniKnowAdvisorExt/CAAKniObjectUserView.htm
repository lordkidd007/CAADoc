<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Test Your Integration with the Knowledge Language</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Test Your Integration with the Knowledge Language</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article discusses the <code>CAALifTestIntegrateKnowledge</code> 
		use case. If you have done what is necessary to integrate some of your applicative 
		types, object and functions [<a href="#References">1</a>], you will be able 
		to use them in the Knowledge language and, <em>in a near future</em>, to 
		look at them in the Search functionality.</p>
		<p>But at first time, you may want to test your integration. This is what 
		illustrates this use case: how to manipulate your applicative objects and 
		user functions.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAALifTestIntegrateKnowledge Use Case</a>
				<ul>
					<li><a href="#What">What Does CAALifTestIntegrateKnowledge Do</a></li>
					<li><a href="#How">How to Launch CAALifTestIntegrateKnowledge</a></li>
					<li><a href="#Where">Where to Find the CAALifTestIntegrateKnowledge 
						Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case is intended to show you how to manage user types, objects and functions 
in order to test that your integration to Knowledge language is correct.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAALifTestIntegrateKnowledge Use Case</h2>
<p><code>CAALifTestIntegrateKnowledge</code> is a use case of the <code>CAALiteralFeaturesExtend.edu</code> 
framework that illustrates <code>KnowledgeInterfaces</code> framework capabilities.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAALifTestIntegrateKnowledge Do</h3>
<p><code>CAALifTestIntegrateKnowledge</code> gives you a feel of how to define a 
Knowledge Package (which has Knowledge types in it). It further defines a late type
<code>CAALifFeatureScrew</code>, implementing <em>CATIExposeObject</em> to expose 
our object to Knowledge Language, in other words to allow Knowledgeware access to 
our objects.</p>
<p>Then it instanciates a feature from a startup <em>CAALifFeatureScrew</em> and 
valuates its three parameters length attributes. Then from this feature, we get 
a handler on the interface <em>CATIExposeObject</em> in order to manipulate this 
object through the user view which has been defined in the context of the technical 
article [<a href="#References">1</a>].</p>
<p>The implementation of the object user view is located in the <em>CAALifIntegrateKnowledge</em> 
library. It contains a package <em>DotItYourself</em>, two types <em>Screw</em> 
and <em>Bolt</em> with their attributes and a user method calculating the volume 
of a screw.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAALifTestIntegrateKnowledge </h3>
<p>To launch <code>CAALifTestIntegrateKnowledge</code>, you will need to set up 
the build time environment, then compile <code>CAALifTestIntegrateKnowledge</code> 
along with its prerequisites, set up the run time environment, and then execute 
the use case [<a href="#References">2</a>]. To launch the use case execute the command:</p>
<pre class="code">mkrun -c &quot;CAALifTestIntegrateKnowledge <em>repository</em> <em>server_name:port_number user</em> <em>password</em> <em>role environment modeler</em>&quot;</pre>
<p>Where</p>
<table class="fill">
	<tr>
		<th>Repository</th>
		<td>
		<script type="text/javascript">insertRepository();</script>
		</td>
	</tr>
	<tr>
		<th>Server</th>
		<td>The server as <em>Host:Port_number/RootURI</em></td>
	</tr>
	<tr>
		<th>User</th>
		<td>The user name</td>
	</tr>
	<tr>
		<th>Password</th>
		<td>The user password to authenticate the user</td>
	</tr>
	<tr>
		<th>SecurityCtx</th>
		<td>A string representing the security context (Role.Organization.Project). 
		Choose Role as Designer(Since use case modifies PLM Data)</td>
	</tr>
	<tr>
		<th>Environment</th>
		<td>A PLM environment containing PLMProductDS (a PRODUCT's custo)</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAALifTestIntegrateKnowledge Code</h3>
<p>TThe <code>CAALifTestIntegrateKnowledge</code> use case is made of a source file 
named <code>CAALifTestIntegrateKnowledge.cpp</code> located in the <code>CAALifTestIntegrateKnowledge.m</code> 
module of the <code>CAALiteralFeaturesExtend.edu</code> framework:</p>
<p><code>InstallRootFolder\CAADoc\CAALiteralFeaturesExtend.edu\CAALifTestIntegrateKnowledge.m\</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">2</a>] is the folder 
where the API CD-ROM is installed.</p>
<p>The use case is running thanks to the library <code>CAALifIntegrateKnowledge</code>, 
which code is located in the <code>CAALifIntegrateKnowledge.m</code> module of the
<code>CAALiteralFeaturesExtend.edu </code>framework.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>The main steps in <code>CAALifTestIntegrateKnowledge</code> are:</p>
<ol>
	<li><a href="#Step1">Prolog</a></li>
	<li><a href="#Step2">Creating and Integrating a Knowledge Type (Screw) and User 
		Function in CATIA</a></li>
	<li><a href="#Step3">Loading a Package and Getting Types</a></li>
	<li><a href="#Step4">Listing Methods in a Package</a></li>
	<li><a href="#Step5">A LateType equivalent for our Knowledge Type (a CATIExposeObject 
		Implementation)</a></li>
	<li><a href="#Step6">Working with Knowledge Types</a>
		<ol>
			<li><a href="#Step61">Creating a Feature exposed to Knowledge</a></li>
			<li><a href="#Step62">Set and Retrieve Feature Attributes exposed to 
				Knowledge</a></li>
			<li><a href="#Step63">Executing a User Function through a Formula on 
				that Object</a></li>
		</ol>
	</li>
	<li><a href="#Step7">Epilog</a><br />
	</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Prolog</h3>
<p>Before going any further in literal programming, you must initialize your environment.</p>
<pre class="code">int <strong>main</strong> (int argc, char** argv)
{
  <strong>CAALifServices services</strong>;

  // Initialize the PLM session
  int rc = 0;
  rc = <strong>services.</strong><strong>CAALifInitSession</strong> (argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7]);
  ...
  rc =<strong> (CAALifObjectUserView0() == CATCke::True) ? 0 : 1;</strong>
  ...</pre>
<p>The environment is initialized in the <strong>main</strong> routine, which simply 
involves a call to <code>CAALifInitSession</code>() routine of the <em>CAALifServices</em> 
class.</p>
<p>The rest of the execution is implemented completely in the <code>CAALifObjectUserView0</code>() 
routine, which is the next invocation. </p>
<p>Before we proceed with the main, we detail the steps involved in implementing 
a Late Type, an equivalent for the Knowledge Type we intend to work on (access) 
through the Knowledge UI. </p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Creating and Integrating a Knowledge Type (Screw) and User 
Function in CATIA</h3>
<p>The Technical Article &quot;<strong>Integrating the Knowledge Language</strong>&quot; 
[<a href="#References">1</a>] details the steps involved to create and integrate 
a knowledge type in <strong>CATIA</strong>. In the current case, we integrate a &quot;<strong>Screw</strong>&quot; 
type with associated parameters and a user function to evaluate its Volume. This 
is accomplished essentially by implementing the <em>CATIAddLibrary</em> Interface, 
which is realized by the <strong>CAALifAddLibrary</strong> component, in the
<code>CAALifIntegrateKnowledge</code> library.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Loading a Package and Getting Types</h3>
<p>To manage packages and types use the <em>CATITypeDictionary</em><strong>
</strong>interface which is dedicated to accessing the unique dictionary of types 
shown to the user. To retrieve a smart pointer on it, you can use the static
<code>GetTypeDictionary</code> method of the <em>CATGlobalFunctions</em> class of 
KnowledgeInterfaces.</p>
<p>The method <code>LoadPackage</code> load the package which name is given in argument 
if it isn't already done. The loading process is described in the corresponding 
technical article [<a href="#References">1</a>].</p>
<pre class="code">  ...
  <strong>CATITypeDictionary_var dico</strong> = <strong>CATGlobalFunctions::GetTypeDictionary()</strong>;<a name="dico"></a>
  CATUnicodeString package_name = &quot;DoItYourself&quot;;<a name="Package"></a>
  rc = <strong>dico-&gt;LoadPackage(package_name)</strong>;
  ...</pre>
<p>You can access types from different manners: </p>
<pre class="code">    ...
  CATListValCATIType_var listTypes;
  <strong>dico-&gt;ListTypesForPackage(package_name,listTypes,0)</strong>;
  ...</pre>
<p>The above call retrieves the list of types, given a package name. We may also 
retrieve a single type, if user is aware of the name of the type to be retrieved.</p>
<pre class="code">    ...
  <strong>CATIType_var ScrewType</strong>;
  rc = <strong>dico-&gt;FindType(&quot;Screw&quot;,ScrewType)</strong>;
  ...</pre>
<p>or alternatively, </p>
<pre class="code">    ...
  CATIType_var ScrewType;
  rc = <strong>dico-&gt;FindTypeSafe(&quot;Screw&quot;,&quot;DoItYourself&quot;,ScrewType)</strong>;
  ...</pre>
<p>The call to <code>FindTypeSafe</code>() not only retrieves the type but also 
loads the corresponding package, if required.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>Listing Methods in a Package </h3>
<p>Let's check the existence of the user function which has been defined in the 
package <strong>CATPackageMethodDoItYourself</strong> in the library <code>CAALifIntegrateKnowledge</code> 
[<a href="#References">1</a>].</p>
<p>First, we list the user functions and methods of the package.</p>
<pre class="code">  CATListValCATBaseUnknown_var listOfSignatures;
  rc = <strong>dico-&gt;ListMethodsForPackage</strong>(&quot;<strong>CATPackageMethodDoItYourself</strong>&quot;, listOfSignatures);
  if (SUCCEEDED(rc))
  {

    int nbOfMethods = listOfSignatures.Size();
    ...
<strong>    CATICkeSignature_var aSignature</strong>;
    CATUnicodeString name;
    for (i=1;i&lt;=nbOfMethods ;i++)
    {
    	aSignature = listOfSignatures[i];
    	<strong>name = aSignature-&gt;Name()</strong>;
	...</pre>
<p>The method <code>ListMethodsForPackage</code>() of the <em>CATITypeDictionary</em> 
Interface lists the methods inside a package. A list of signatures is output, each 
a <em>CATICkeSignature_var</em> type.</p>
<p>The function is identified by its name, returned by the <code>Name</code>() routine 
of the <em>CATICkeSignature</em> Interface.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>A LateType equivalent for our Knowledge Type (a CATIExposeObject 
Implementation)</h3>
<p>A LateType &quot;<strong>CAALifFeatureScrew</strong>&quot; is defined which implements 
the <em>CATIExposeObject</em> interface. It is realized with the component
<strong>CAALifExposeObjectScrewExt</strong>.</p>
<p>Primarily we implement the <code>TypeInternal</code>() to retrieve the Knowledge 
type, <code>SetValueInternal</code>() and <code>GetValueInternal</code>() APIs called 
by Knowledge to set and retrieve the feature attribute values. The details of these 
implementations is a subject of the technical article &quot;<strong>Knowledge Language 
Integration</strong>&quot; [<a href="#References">1</a>].</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step6"></a>Working with Knowledge Types</h3>
<p>We now proceed with the implementation inside the <strong>main. </strong>In the 
last section that dealt with the main, we had proceeded till the step where we had 
invoked the routing <code>CAALifObjectUserView0</code>. The routine follows and 
we explain the steps involved further ahead.</p>
<h4><a name="Step61"></a>Creating a Feature exposed to Knowledge</h4>
<pre class="code"><strong>CAALifServicesExtend CAAliteralFeaturesServicesExtend</strong>;

CATCke::Boolean <strong>CAALifObjectUserView0</strong>()
{
    <strong> CATIMmiPrtContainer * pContainer = NULL</strong>;
     HRESULT rc = <strong>CAAliteralFeaturesServices.CAALifCreateInstanceContainer(&amp;pContainer)</strong>;
     ...
<strong>     CATICkeParmFactory_var spContainer = pContainer</strong>;
     ...
     <strong>CATICkeObject_var iCAAFeature</strong>;
     rc = <strong>CAAliteralFeaturesServicesExtend.CreateCAAFeature(spContainer,iCAAFeature)</strong>;
     ...</pre>
<p>The <code>CAALifObjectUserView0</code>() routine begins with creating a document 
of type &quot;<strong>CATPart</strong>&quot;, by invoking the <code>CAALifCreateInstanceContainer</code>() 
method of the <em>CAALifServices</em> class. The container is returned as a <em>
CATIMmiPrtContainer</em>* type. (<code>pContainer</code>).</p>
<p>Subsequently we retrieve its root container, as a literal factory Interface. 
The Container is retrieved as a <em>CATICkeParmFactory</em> type (<code>spContainer</code>).</p>
<p>Next we instantiate the feature <strong>CAALifFeatureScrew</strong> and valuate 
its attributes with a call to <code>CreateCAAFeature</code>() of the <code>CAALifServicesExtend</code> 
class (<code>CAAliteralFeaturesServicesExtend</code> object).</p>
<pre class="code">HRESULT <strong>CAALifServicesExtend::CreateCAAFeature (const CATICkeParmFactory_var &amp;spFact,CATICkeObject_var &amp;oCreatedObject)</strong>
{
    HRESULT hr = E_FAIL;
    oCreatedObject=NULL_var;
    if (!!spFact)
    {
    <strong>     CATFmCredentials* oCreds = NULL</strong>;
         hr = <strong>CreateCredentialsObjectForKnowledge(oCreds)</strong>;
         CATFmFeatureFacade FeatFacadeOnScrew(*oCreds);
	       
         if (SUCCEEDED(hr))
         {
<strong>              CATFmStartUpFacade SUFacadeForScrew(*oCreds,&quot;CAALifFeatureScrew&quot;)</strong>;
              CATFmContainerFacade MyContFacade(*oCreds,(CATBaseUnknown*)spFact);
              hr =  <strong>SUFacadeForScrew.InstantiateIn(MyContFacade,FeatFacadeOnScrew)</strong>;
              if (SUCCEEDED(hr))
<strong>                   oCreatedObject = FeatFacadeOnScrew.GetFeature()</strong>;
         }
     ...
}</pre>
<p>The feature is available at the end as a <em>CATFmFeatureFacade</em> type (<code>FeatFacadeOnScrew</code>). 
It is further retrieved as a <em>CATICkeObject_var</em> type (<code>oCreatedObject</code>).</p>
<p>Next we valuate its attributes &quot;<strong>ScrewLength</strong>&quot;, &quot;<strong>HeadDiam</strong>&quot; 
and &quot;<strong>StemDiam</strong>&quot;.</p>
<pre class="code">HRESULT <strong>CAALifServicesExtend::CreateCAAFeature (const CATICkeParmFactory_var &amp;spFact,CATICkeObject_var &amp;oCreatedObject)</strong>
{
        ...
        if (SUCCEEDED(hr))
        {
<strong>             CATICkeParm_var length_parm   = spFact-&gt;CreateLength (&quot;Length&quot;,0.1)</strong>;

<strong>             CATFmAttributeName AttrNameForScrewLength(&quot;ScrewLength&quot;)</strong>;
                        
             CATFmFeatureFacade FeatFacadeOnScrewLength;
             <strong>FeatFacadeOnScrewLength = (CATBaseUnknown*)length_parm</strong>;

             CATFmAttributeValue AttrValueForScrewLength;
             <strong>AttrValueForScrewLength.SetFeature(FeatFacadeOnScrewLength)</strong>;

             hr = <strong>FeatFacadeOnScrew.SetValue(AttrNameForScrewLength,AttrValueForScrewLength)</strong>;
             ...
 <strong>  	    CATICkeParm_var headdiam_parm = spFact-&gt;CreateLength (&quot;HeadDiam&quot;,0.05)</strong>;
             hr = <strong>FeatFacadeOnScrew.SetValue(AttrNameForHeadDia,AttrValueForHeadDia)</strong>;
             ...
<strong>         	    CATICkeParm_var stemdiam_parm = spFact-&gt;CreateLength (&quot;StemDiam&quot;,0.02)</strong>;
             hr = <strong>FeatFacadeOnScrew.SetValue(AttrNameForStemDia,AttrValueForStemDia)</strong>;
     ...
}</pre>
<p>The feature is characterized by attributes of type <strong>component</strong>. 
So, we simply create the <strong>Knowledge Parameter</strong> objects (of type
<strong>Length</strong>) and assign those to the feature attributes. This creation 
is possible with the Parameter Factory Interface (spFact, a <em>CATICkeParmFactory_var</em> 
type) on the applicative container, which is input to this routine.</p>
<p>Thus, we have set the Length to 0.1m, Head diameter to 0.05m and Stem Diameter 
is set to 0.02. </p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step62"></a>Set and Retrieve Feature Attributes exposed to Knowledge</h4>
<p>There are different ways of setting and retrieving attribute values of a feature 
exposed to Knowledge.</p>
<ul>
	<li><strong>If you are a CAA feature, you may simply use the services exposed 
		by the <em>CATIExposeObject</em> Interface</strong>. Now that we have a 
		knowledge type integrated in CATIA User view, in order to work on it, it 
		will be required to create a Late Type (which may be a feature or a simple 
		C++ object) implementing the <em>CATIExposeObject</em> Interface.
		<pre class="code"><strong>CATIExposeObject_var spExposeObject = iCAAFeature</strong>;
...
<strong>CATIType_var TypeInDico = spExposeObject-&gt;Type()</strong>;  
...
CATUnicodeString TypeName = TypeInDico-&gt;Name();</pre>
		<p>It simply involves retrieving a <em>CATIExposeObject</em> Interface on 
		our feature, by a call to <code>QueryInterface</code>(). We further invoke 
		the <code>Type</code>() routine of this Interface which returns the underlying 
		object type.</p>
		<p>To <strong>Get</strong> an attribute &quot;<strong>ScrewLength</strong>&quot; 
		containing a length value do it this way:</p>
		<pre class="code"><strong>  CATIValue_var value = piExposeObject-&gt;GetValue(&quot;ScrewLength&quot;)</strong>;
  ...
  if (<strong>value-&gt;AsReal()</strong> != 5.0)
  ...
</pre>
		<p>The method <code>GetValue</code> of <em>CATIExposeObject</em> takes in 
		argument the name of the wanted attribute which has been defined in the 
		object user user view. It returns a <em>CATIValue</em>*. In this example, 
		the value of the attribute is a parameter length and it can be directly 
		accessed with the method <em>AsReal</em> of <em>CATIValue</em>. </p>
		<p>To <strong>Get</strong> an attribute &quot;<strong>CenterPoint</strong>&quot; 
		containing a feature point do it this way:</p>
		<pre class="code">  ...
<strong>  value = piExposeObject-&gt;GetValue(&quot;CenterPoint&quot;)</strong>;
  ...
  <strong>CATIGSMPointCoord_var point = NULL_var</strong>;
 <strong> point = value-&gt;AsObject()</strong>;
  ...</pre>
		<p>In the following example, the <em>CATIValue</em> is a feature which we 
		access with the method <code>AsObject</code> of <em>CATIValue</em>.</p>
		<p>To <strong>Set</strong> an attribute &quot;<strong>ScrewLength</strong>&quot; 
		with a length value do it this way:</p>
		<pre class="code">  ...
  <strong>CATICkeParmFactory_var VolFactory = CATCkeGlobalFunctions::GetVolatileFactory()</strong>;<a name="volatilefact"></a>
  ...
  rc = <strong>piExposeObject-&gt;SetValue</strong>(&quot;ScrewLength&quot;, <strong>VolFactory-&gt;CreateLength(&quot;L1&quot;,15.23)</strong>);
  ...</pre>
		<p>To <strong>Set</strong> an attribute &quot;<strong>CenterPoint</strong>&quot; 
		with a feature point do it this way:</p>
		<pre class="code">  ...
  <strong>piExposeObject-&gt;SetValue</strong>(&quot;CenterPoint&quot;, <strong>VolFactory-&gt;CreateObjectReference(GSMPt)</strong>);
  ...</pre>
		<p>The methods <code>CreateObjectReference</code> or <code>CreateLength</code> 
		of the volatile factory <strong><code>VolFactory</code></strong>, create 
		a temporary <em>CATIValue</em> handle on your feature point or on a numerical 
		value, just to give it in argument to the <code>SetValue</code> method.</p>
	</li>
	<li>If you are an internal DS feature, they implement an internal Interface
	</li>
	<li>More generic services like those exposed by <em>CATCkeObjectAttrReadServices</em> 
		/ <em>CATCkeObjectAttrWriteServices</em>
		<pre class="code">double V = 0.0;
if (S_OK == <strong>CATCkeObjectAttrReadServices::GetValueAsReal(iCAAFeature, &quot;ScrewLength&quot;, V)</strong>)</pre>
		<p>The <code>GetValueAsReal</code>() routine of the <em>CATCkeObjectAttrReadServices</em> 
		class, retrieves the attribute value of the feature.</p>
		<pre class="code">if (FAILED(<strong>CATCkeObjectAttrWriteServices::SetValueWithReal(iCAAFeature, &quot;ScrewLength&quot;, 0.25)</strong>))</pre>
		<p>The <code>SetValueAsReal</code>() routine of the <em>CATCkeObjectAttrReadServices</em> 
		class, sets the attribute value of the feature.</p>
	</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step63"></a>Executing a User Function through a Formula on that Object</h4>
<p>A Formulae has already been defined on the Screw type. It evaluates the Volume 
of the screw. This was done in the module <code>CAALifIntegrateKnowledge</code>, 
responsible for defining the Knowledge Types (Screw), its attributes and a user 
function to evaluate Volume. In main, we simply have to invoke this volume routine 
to retrieve the screw volume. It is realized as depicted in the implementation that 
follows.</p>
<pre class="code"><strong>CATIParmDictionary_var spParmDictionary = CATCkeGlobalFunctions::GetParmDictionary()</strong>;
<strong>CATICkeRelationFactory_var spRelFact = spContainer</strong>;

<strong>CATICkeMagnitude_var spVolumeMagnitude = spParmDictionary-&gt;FindMagnitude(&quot;VOLUME&quot;)</strong>;
if (NULL_var != spVolumeMagnitude)
{      
     CATUnicodeString VolumeName(&quot;ScrewVolume&quot;);
     double VolumeValue = 0.0;
     <strong>CATICkeParm_var spVolume = spFact-&gt;CreateDimension(spVolumeMagnitude,VolumeName,VolumeValue)</strong>;

<strong>     CATICkeParmFactory_var VolFactory = CATCkeGlobalFunctions::GetVolatileFactory()</strong>;
<strong>     CATICkeParm_var ScrewParm = VolFactory-&gt;CreateObjectReference(iCAAFeature)</strong>;

<strong>     CATCkeListOf(Parm) pParamList</strong>;
<strong>     pParamList.Append (ScrewParm)</strong>;

     <strong>CATICkeRelation_var spFormula</strong> = <strong>spRelFact-&gt;CreateFormula</strong> (&quot;<strong>VolumeFormula</strong>&quot;,
	               		                          &quot;&quot;,
                                                              &quot;&quot;, 
                                     		       <strong>spVolume</strong>, 
			<strong>                                  &amp;pParamList</strong>,
			                                  &quot;<strong>EvaluateScrewVolume(a1)</strong>&quot;,
			                                   NULL_var,
			                                   CATCke::False);
     ...</pre>
<p>The crux of this step simply involves to evaluate a formulae of the kind &quot;<strong>Volume</strong> 
= <strong>EvaluateScrewVolume</strong>() routine&quot;. So, it primarily involves 
creating a formulae, building an arguments list, an input to the routine and a return 
type, for storing the evaluated volume.</p>
<p>The volume returned is stored in a <em>CATICkeParm</em> type. The <code>CreateDimension</code>() 
call of the <em>CATICkeParmFactory</em> (spFact) creates a <strong>Knowledge Parameter</strong>. 
In the current case, we create one of type Volume (specified by the <em>CATICkeMagnitude</em> 
type, <code>spVolumeMagnitude</code>), identified as &quot;<strong>ScrewVolume</strong>&quot;, 
and its value being stored as a double type (<strong>VolumeValue</strong>).</p>
<p>The input argument for the routine is just our screw object, which is available 
to us as a <em>CATICkeObject</em> type (iCAAFeature). The routine for evaluating 
volume, though, requires this input as a <em>CATICkeParm</em> type. This is realized 
with a call to CreateObjectReference() of the <em>CATICkeParmFactory</em> Interface, 
of the Volatile Factory. The factory interface is retrieved with the function GetVolatileFactory() 
of the <em>CATCkeGlobalFunctions</em> class.</p>
<p>The formulae is built with the CreateFormula() call of the <em>CATICkeRelationFactory</em> 
Interface, on the Container. It is significant to note that the formulae is evaluated 
at the time of creation. An explicit call for its evaluation is not required initially.</p>
<p>Of course, if the screw parameters are modified, then on screw update this formulae 
will have to re-evaluated as depicted in the code that follows.</p>
<pre class="code">     ...
     if (spFormula != NULL_var)
     {
          cout &lt;&lt; &quot;The old screw volume calculated from the VolumeFormula is &quot; ;
	 cout &lt;&lt; <strong>spVolume-&gt;Show().ConvertToChar()</strong> &lt;&lt; endl;

	rc = <strong>CATCkeObjectAttrWriteServices::SetValueWithReal(iCAAFeature, &quot;ScrewLength&quot;, 0.19)</strong>;
         ...			
         {
	     <strong>spFormula-&gt;SetNotUpdated(ScrewParm)</strong>;
<strong>	     spFormula-&gt;Evaluate()</strong>;
	     cout &lt;&lt; &quot;The new screw volume calculated from the VolumeFormula is &quot; ;
	     cout &lt;&lt; <strong>spVolume-&gt;Show().ConvertToChar()</strong> &lt;&lt; endl;
	}
        ...</pre>
<p>The volume evaluated is displayed with a call to Show() of the <em>CATICkeParm</em> 
Interface. This displays the parameter in the current unit. </p>
<p>Next, we modify the Screw parameters. Its length is modified to 0.19m. </p>
<p>This calls for setting the formulae in &quot;<strong>Not Updated</strong>&quot; 
mode. This is accomplished with a call to SetNotUpdated() of the <em>CATICkeParm</em> 
class.</p>
<p>Subsequent to this when the call to Evaluate() happens, this recalculates the 
Volume, having taken into account the updated screw parameters.</p>
<p>The new Volume is again displayed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step7"></a>Epilog</h3>
<pre class="code">  ...
  rc = services.<strong>CAALifCloseSession</strong>();
  return rc;
</pre>
<p>The <code>CAALifCloseSession</code> method of the <em><strong>CAALifServices</strong></em> 
class defined in the <code>CAALifBasis.m</code> module deletes the session.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>The Knowledgeware allows to integrate your own types, objects, functions or method 
in oder to create a simplified user view of your data.</p>
<p>For that, you have to create a few ressources files and to implement the interfaces
<em><strong>CATIAddTypeLibrary</strong>, <strong>CATICreateInstance</strong>
</em>and<em> <strong>CATIExposeObject</strong>.</em></p>
<p>Afterwards, your object user view will be accessible in the Search functionality 
and understood in the Knowledge language.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td><a href="CAAKniObjectUserViewArticle.htm">Integrating the Knowledge 
		Language</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [Nov 2003]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
