<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Publishing Literals</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Publishing Literals</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article discusses the <code>CAALifPublish</code> use case. This 
		use case explains how to display parameters and relations in the <em>f(x)</em> 
		dialog box and benefit from the capabilities provided by the <em>f(x)</em> 
		dialog.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAALifPublish Use Case</a>
				<ul>
					<li><a href="#What">What Does CAALifPublish Do</a></li>
					<li><a href="#How">How to Launch CAALifPublish</a></li>
					<li><a href="#Where">Where to Find the CAALifPublish Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case is intended to show you how to create a length and an angle type 
parameters as the children of a given feature and make them display in <em>f(x)</em> 
when the parent feature is selected either in the specification tree or in the geometry 
area.</p>
<p>Throughout this article, the word 'published' qualifies a feature whose parameters 
and relations are designed to be displayed in <em>f(x)</em> as well as the displayed 
parameters and relations.</p>
<p>The example which is developed in this use case can be extended to other types 
of parameters and to relations as the principles illustrated in the use case are 
quite general.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAALifPublish Use Case</h2>
<p><code>CAALifPublish</code> is a use case of the <code>CAALiteralFeaturesExtend.edu</code> 
framework that illustrates <code>KnowledgeInterfaces</code> framework capabilities.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAALifPublish Do</h3>
<p><code>CAALifPublish</code> explains the steps involved to publish parameters 
of an object to f(x). It involves defining a feature <strong>CAALifSimpleFeature</strong> 
(late type), as depicted below in the <strong>CAA2_CAALifFeatCatalog.osm</strong> 
file.</p>
<pre class="code">feature <strong>`CAALifFeature1`</strong>#2 #startup #<strong>isa</strong>(<strong>`CAALifSimpleFeature`</strong>) 
     {
<strong>          component `LifFeatureLength`</strong>
<strong>	 component `components` #list</strong>
     }</pre>
<p>This feature for publish, is typically characterized by attributes of type '<strong>component</strong>', 
which realizes aggregating the Knowledge Parameters for publish. <strong>CAALifSimpleFeature</strong> 
is characterized by two attributes namely. <strong>'LifFeatureLength'</strong>, 
of type <strong>component</strong>&nbsp; and <strong>'components'</strong> of type &quot;<strong>list 
component</strong>&quot;.</p>
<p>The feature implements the <em>CATIParmPublisher</em> on the feature. This Interface 
is responsible for publishing an object parameters to F(x). It exposes the services 
which are invoked by Knowledge to set and retrieve the Knowledge Parameters.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAALifPublish</h3>
<p>To launch <code>CAALifPublish</code>, you will need to set up the build time 
environment, then compile <code>CAALifPublishMain</code> along with its prerequisites, 
set up the run time environment, and then execute the use case which main program 
is <code>CAALifPublishMain</code> [<a href="#References">1</a>].</p>
<pre class="code">mkrun -c &quot;CAALifPublishMain <em>repository</em> <em>server_name:port_number user</em> <em>password</em> <em>role environment modeler</em>&quot;</pre>
<p>Where:</p>
<table class="fill">
	<tr>
		<th>Repository</th>
		<td>
		<script type="text/javascript">insertRepository();</script>
		</td>
	</tr>
	<tr>
		<th>Server</th>
		<td>The server as <em>Host:Port_number/RootURI</em></td>
	</tr>
	<tr>
		<th>User</th>
		<td>The user name</td>
	</tr>
	<tr>
		<th>Password</th>
		<td>The user password to authenticate the user</td>
	</tr>
	<tr>
		<th>SecurityCtx</th>
		<td>A string representing the security context (Role.Organization.Project). 
		Choose Role as Designer(Since use case modifies PLM Data)</td>
	</tr>
	<tr>
		<th>Environment</th>
		<td>A PLM environment containing PLMProductDS (a PRODUCT's custo)</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where0"></a><a name="Where"></a>Where to Find the CAALifPublish Code</h3>
<p>The <code>CAALifPublish</code> use case is made up of:</p>
<ul>
	<li>The <code>CAALifMyPublisher.cpp</code> source file located in the <code>
		CAALifBasisExtend</code> module which defines an implementation of <em>CATIParmPublisher</em></li>
	<li>A main source file named <code>CAALifPublishMain.cpp</code> located in the
		<code>CAALifPublish</code> module which initializes the environment and 
		creates features intended to publish parameters and relations.</li>
</ul>
<p>The location of these modules follows:</p>
<p><code>InstallRootFolder\CAADoc\CAALiteralFeaturesExtend.edu\CAALifBasisExtend.m\</code></p>
<p><code>InstallRootFolder\CAADoc\CAALiteralFeaturesExtend.edu\CAALifPublish.m\</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">1</a>] is the folder 
where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>Here are the main steps followed in this use case to create parameters to be 
displayed in the <strong>f(x)</strong> dialog box:</p>
<ol>
	<li><a href="#Step1">Prolog</a> </li>
	<li><a href="#Step2">Publishing a Feature</a>
		<ol>
			<li><a href="#Step21">Creating Credentials 
				and Instantiate Root Feature</a></li>
			<li><a href="#Step22">Appending Knowledge Parameters</a></li>
			<li><a href="#Step23">Retrieving Direct Children (Parameters/Relations) 
				under the Root Feature</a></li>
		</ol>
	</li>
	<li><a href="#Step3">Implementing CATIParmPublisher</a>
		<ol>
			<li><a href="#Step31">Implementing AppendElement()</a></li>
			<li><a href="#Step32">Implementing RemoveElement()</a></li>
			<li><a href="#Step33">Implementing VisitChildren()</a></li>
		</ol>
	</li>
	<li><a href="#Step4">Implementing CATIParmDirectAccess</a></li>
	<li><a href="#Step5">Epilog</a></li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Prolog</h3>
<p>Before going any further in literal programming, you must initialize your environment.
</p>
<pre class="code">int <strong>main</strong> (int argc, char** argv)
{
  <strong>CAALifServices services</strong>;

  if (argc != 8) return CAALifKO;

  // Initialize the PLM session
  int rc = 0;
  rc = <strong>services.</strong><strong>CAALifInitSession</strong> (argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7]);
  if( rc != CAALifOk ) return rc;

  <strong>CAALifPublish0()</strong>;
...</pre>
<p>The environment is initialized in the <strong>main</strong> routine, which simply 
involves a call to <code>CAALifInitSession</code>() routine of the <em>CAALifServices</em> 
class.</p>
<p>The rest of the execution is implemented completely in the <code>CAALifPublish0</code>() 
routine. It is called next.</p>
<pre class="code">CATCke::Boolean <strong>CAALifPublish0</strong>()
{
     <strong>CAALifServices CAAliteralFeaturesServices</strong>;
        
     // First create a document and get the root container.
     CATIMmiPrtContainer* piCBUOnContainer = NULL;
     HRESULT rc = <strong>CAAliteralFeaturesServices.CAALifCreateInstanceContainer(&amp;piCBUOnContainer)</strong>;
     ...
     //Retrieves the parameters factory
     CATICkeParmFactory* piFact = NULL;
     rc = <strong>piCBUOnContainer-&gt;QueryInterface(IID_CATICkeParmFactory, (void**) &amp;piFact)</strong>;
     ...

     <strong>CATICkeRelationFactory_var spRelFact (piFact)</strong>;
</pre>
<p>The <code>CAALibPublish0</code>() routine begins with creating a document of 
type &quot;<strong>CATPart</strong>&quot; and subsequently to retrieve its root 
container, as a literal factory Interface.</p>
<p>This is accomplished with a call to <code>CAALifCreateInstanceContainer</code>() 
method of the <em>CAALifServices</em> class. The container is returned as a <em>
CATIMmiPrtContainer</em>* type. (<code>piCBUOnContainer</code>). </p>
<p>The Container is retrieved as a <em>CATICkeParmFactory</em> type (<code>piFact</code>), 
its <strong>Parameters Factory Interface</strong>.</p>
<p>It is also retrieved as a <em>CATICkeRelationsFactory_var</em> type (<code>spRelFact</code>), 
its <strong>Relations Factory Interface</strong>.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Publishing a Feature</h3>
<p>This step involves instantiating a Feature and valuating its attributes with 
Knowledge Parameters. Our feature is then exposed in Knowledgeware (<strong>Knowledge 
Expert</strong>).</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step21"></a>Creating Credentials and Instantiate Root Feature</h4>
<p>The Credentials object is next created. Next the &quot;<strong>CAALifSimpleFeature</strong>&quot; 
StartUp is instantiated.</p>
<pre class="code"><strong>CAALifServicesExtend CAAliteralFeaturesServicesExtend;
CATFmCredentials* oCreds</strong>;
HRESULT hr = <strong>CAAliteralFeaturesServicesExtend.CreateCredentialsObjectForKnowledge(oCreds)</strong>;
if (FAILED(hr)) return CAALifEventsExit( piCBUOnContainer, CAALifKO );

<strong>CATFmFeatureFacade FeatFacadeOnSimpleFeat0(*oCreds)</strong>;
<strong>CATFmStartUpFacade SUFacadeOnSimpleFeat(*oCreds,&quot;CAALifSimpleFeature&quot;)</strong>;
CATFmContainerFacade MyContFacade(*oCreds);
<strong>MyContFacade = piCBUOnContainer</strong>; 
hr =  <strong>SUFacadeOnSimpleFeat.InstantiateIn(MyContFacade,FeatFacadeOnSimpleFeat0)</strong>;</pre>
<p>The Credentials is created to authorized working with the <strong>CAA2_CAALifFeatCatalog 
catalog</strong>. It also registers our application to be based on <strong>Feature 
Modeler</strong> which in turn authorizes working with the Applicative Containers 
built on Feature Modeler.</p>
<p>The &quot;<strong>CAALifSimpleFeature</strong>&quot; feature is a <em>CATFmFeatureFacade</em> 
type (<code>FeatFacadeOnSimpleFeat0</code>).</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step22"></a>Appending Knowledge Parameters</h4>
<p>Next, we proceed to valuate the feature attributes. All attributes are of type
<strong>component</strong>. These are valuated with the Knowledge Parameter objects, 
which are fundamentally features.&nbsp; </p>
<pre class="code"><strong>CATFmAttributeName AttrName_LifFeatLength(&quot;LifFeatureLength&quot;)</strong>;
CATFmAttributeValue AttrValue;
if (SUCCEEDED(hr))
{
     // Create a Length parameter of length type - its initial value is  1 meter 	
     // Create the parameter to be published
     // It is a Length type parameter and its value is assigned to &quot;LifFeatureLength&quot; attribute.
<strong>     CATICkeParm_var spLength = piFact-&gt;CreateLength (&quot;Height&quot;,2.3)</strong>;
     CATBaseUnknown* piCBUOnLength = NULL;
     hr = <strong>spLength-&gt;QueryInterface(IID_CATBaseUnknown,(void**)&amp;piCBUOnLength)</strong>;
     if (SUCCEEDED(hr))
     {
<strong>     	AttrValue.SetFeature(piCBUOnLength);</strong>
     }

     hr = <strong>FeatFacadeOnSimpleFeat0.SetValue(AttrName_LifFeatLength,AttrValue)</strong>;</pre>
<p>A Length Parameter is created. The call to <code>CreateLength</code>() of the
<em>CATICkeParmFactory</em> Interface (piFact) returns the Length Parameter, named &quot;<strong>Height</strong>&quot; 
and valuated to <strong>2.3</strong>. It is returned as a <em>CATICkeParm_var</em> 
type (spLength). We further retrieve it as a <em>CATBaseUnknown</em> type, by call 
to <code>QueryInterface</code>.</p>
<p>The <em>CATFmAttributeName</em> object equivalent for the &quot;<strong>LifFeatureLength</strong>&quot; 
attribute is created.</p>
<p>TThe call to <code>SetFeature</code>() of the <em>CATFmAttributeValue</em> class 
updates our AttributeValue with the Length Parameter<code>.</code></p>
<p>We finally valuate the &quot;<strong>LifFeatureLength</strong>&quot; attribute 
with this Length Parameter, by calling <code>SetValue</code>() of the <em>CATFmFeatureFacade</em> 
class (<code>FeatFacadeOnSimpleFeat0</code>).</p>
<p>Next we create two more Length Parameters with the <code>CreateLength</code>() 
call as we have done above. </p>
<pre class="code"><strong>CATICkeParm_var spLength2 = piFact-&gt;CreateLength (&quot;Height2&quot;,222)</strong>;
<strong>CATICkeParm_var spLength3 = piFact-&gt;CreateLength (&quot;Height3&quot;,333)</strong>;</pre>
<p>A Length Parameter called <strong>Height2</strong> valuated to <strong>222</strong> 
is retrieved as a <em>CATICkeParm_var</em> type (spLength2).</p>
<p>A Length Parameter called <strong>Height3</strong> valuated to <strong>333</strong> 
is retrieved as a <em>CATICkeParm_var</em> type (spLength3).</p>
<p>NNext we proceed to valuate the 'components' attribute of type component list. 
This is accomplished by using the <em>CATIParmPublisher</em> Interface of our Feature.
</p>
<pre class="code">CATFmFeatureFacade FeatFacadeOnSimpleFeat1(*oCreds);CATIParmPublisher* piPub = NULL;
hr = <strong>FeatFacadeOnSimpleFeat0.QueryInterfaceOnFeature(IID_CATIParmPublisher, (void**) &amp;piPub)</strong>;</pre>
<p>We retrieve the <em>CATIParmPublisher</em> Interface type (piPub) on our feature 
with a call to QI.&nbsp; </p>
<pre class="code"><strong>piPub-&gt;AppendElement( spLength2 )</strong>;
<strong>piPub-&gt;AppendElement( spLength3 )</strong>;</pre>
<p>TThe <code>AppendElement</code>() call of the <em>CATIParmPublisher</em> Interface 
of our feature valuates its component list attribute (component).</p>
<p>We proceed to append further the component list attribute (component) with another 
'<strong>CAALifSimpleFeature</strong>'. The feature instantiated as depicted in 
the code extract that follows.</p>
<pre class="code">hr =  <strong>SUFacadeOnSimpleFeat.InstantiateIn(MyContFacade,FeatFacadeOnSimpleFeat1)</strong>;
if (SUCCEEDED(hr))
{
     <strong>CATBaseUnknown_var spCBUOnFeat1 = FeatFacadeOnSimpleFeat1.GetFeature()</strong>;
     // Add the current feature to the previous one.
     <strong>piPub-&gt;AppendElement(spCBUOnFeat1)</strong>;
}</pre>
<p class="code">This second feature is initially retrieved as a <em>CACATFmFeatureFacade</em> 
type (<code>FeatFacadeOnSimpleFeat1</code>).</p>
<p>We further retrieve it as a <em>CATBaseUnknown_var</em> type (<code>spCBUOnFeat1</code>) 
by calling <code>GetFeature</code>() of the <em>CATFmFeatureFacade</em> class.</p>
<p>OOur first feature 'components' attribute (type component list) is further appended 
with this second feature by invoking <code>AppendElement</code> of the <em>CATIParmPublisher</em> 
Interface ().</p>
<p>We further proceed to valuate the attributes of this second feature. </p>
<pre class="code"><strong>CATICkeParm_var spLength1 = piFact-&gt;CreateLength(&quot;Height1&quot;,111);
CATBaseUnknown* piCBUOnLength1 = NULL;</strong>
hr = <strong>spLength1-&gt;QueryInterface(IID_CATBaseUnknown,(void**)&amp;piCBUOnLength1)</strong>;
if (SUCCEEDED(hr))
      <strong>AttrValue.SetFeature(piCBUOnLength1)</strong>;

hr = <strong>FeatFacadeOnSimpleFeat1.SetValue(AttrName_LifFeatLength,AttrValue)</strong>;</pre>
<p>AA Length Parameter is created, on similar lines as done previously. It is retrieved 
as <code>spLength1</code>, a <em>CATICkeParm_var</em> type. </p>
<p>It is further retrieved as a <em>CATBaseUnknown</em> type (spCBUOnLength1), by 
calling QI. </p>
<p>A <em>CATFmAttributeValue</em> type is updated with this Length Parameter.</p>
<p>Finally the &quot;<strong>LifFeatureLength</strong>&quot; attribute of the second 
feature is valuated with this Length Parameter. The call to <code>SetValue</code>() 
of the <em>CATFmFeatureFacade</em> class accomplishes this.</p>
<p>We further valuate the '<strong>components</strong>' attribute (type <strong>
component list</strong>) with the Knowledge Parameters created below.</p>
<pre class="code"><strong>CATICkeParm_var spReal1 = piFact-&gt;CreateReal (&quot;Real1&quot;,0.1)</strong>;
<strong>CATICkeParm_var spLength4 = piFact-&gt;CreateLength (&quot;Height4&quot;,444)</strong>;</pre>
<p>A Real Parameter of type <em>CATICkeParm_var</em> (spReal1) is created, named
<strong>Real1</strong>, valuated to <strong>0.1</strong>. </p>
<p>Another Length Parameter of type <em>CATICkeParm_var</em> (spLength4) is created, 
named Height4, valuated to 444.</p>
<p>WWe next valuate the '<strong>components</strong>' attribute of the second feature 
with these two Knowledge Parameters.</p>
<pre class="code">CATIParmPublisher* piPub1 = NULL;hr = <strong>FeatFacadeOnSimpleFeat1.QueryInterfaceOnFeature(IID_CATIParmPublisher, (void**) &amp;piPub1)</strong>;
if (SUCCEEDED(hr))
{
     cout &lt;&lt; &quot;   Success in retrieving a CATIParmPublisher from second feat&quot; &lt;&lt; endl;
     <strong>piPub1-&gt;AppendElement( spReal1 )</strong>;
<strong>     piPub1-&gt;AppendElement( spLength4 )</strong>;
}</pre>
<p>We retrieve the <em>CATIParmPublisher</em> Interface type (piPub1) on the second 
feature with a call to QI.&nbsp; </p>
<p>The AppendElement() call of the <em>CATIParmPublisher</em> Interface of our feature 
valuates its component list attribute (component).</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step23"></a>Retrieving Direct Children (Parameters/Relations) 
under the Root Feature </h4>
<p>Now we proceed to retrieve the list of direct children (level one) under our 
root (first) feature. The <em>CATIParmDirectAccess</em> Interface of a feature exposes 
the services to retrieve the parameters directly under it&nbsp; (level one).</p>
<pre class="code">CATLISTV(CATBaseUnknown_var) spLst;
<strong>CATIParmDirectAccess_var spPDA (piPub)</strong>;
hr = <strong>spPDA-&gt;RetrieveDirectChildren (CATICkeParm::ClassName(),spLst)</strong>; 

if (SUCCEEDED(hr))
{
     // Display the number of parameters as well as the parameter values
<strong>     cout &lt;&lt; &quot; The number of parameters is (3 expected): &quot; &lt;&lt; spLst.Size() &lt;&lt; </strong>endl;
<strong>     CATICkeParm_var spFirstParam = spLst[1]</strong>;
<strong>     </strong>cout &lt;&lt; &quot;<strong> The first parameter value is (2.3 expected): &quot; &lt;&lt; spFirstParam-&gt;Value()-&gt;AsReal()</strong> &lt;&lt; endl;
}</pre>
<p>The <em>CATIParmDirectAccess</em> type on our root feature is retrieved (spPDA).</p>
<p>ThThe call to <code>RetrieveDirectChildren</code>() of the <em>CATIParmDirectAccesse</em> 
Interface returns a list of direct children. The children type is specified by its 
class type. It is <em>CATICkeParm</em> in the current case, which implies we intend 
to retrieve only Knowledge Parameters at level one. </p>
<p>There are three Knowledge Parameters aggregated under our feature. The first 
one in the list is valuated to 2.3.</p>
<p>We next proceed to retrieve the direct relations under our root feature.</p>
<pre class="code">hr = <strong>spPDA-&gt;RetrieveDirectChildren (CATICkeRelation::ClassName(),spLst)</strong>;
if (SUCCEEDED(hr)) cout &lt;&lt; &quot; <strong>The number of relations is (0 expected):</strong>&quot; &lt;&lt; <strong>spLst.Size()</strong> &lt;&lt; endl;</pre>
<p>The call is the same as before. Except, the class name input this time is <em>
CATICkeRelation</em>, the type for relations (formulae).</p>
<p>There are currently no relations aggregated under our root feature.</p>
<p>We now aggregate a new Angle Parameter under the Root feature.</p>
<pre><strong>CATICkeParm_var spPp2 = piFact-&gt;CreateAngle (&quot;a&quot;,0)</strong>;
<strong>piPub-&gt;AppendElement(spPp2)</strong>;</pre>
<p>The call to <code>CreateAngle</code>() of the <em>CATICkeParmFactory</em> class 
creates an Angle Parameter. It is named as &quot;<strong>a</strong>&quot;, and it 
is valuated to <strong>0</strong>.</p>
<p>This new parameter is aggregated under our root feature.&nbsp; </p>
<pre class="code">hr = <strong>spPDA-&gt;RetrieveDirectChildren (CATICkeParm::ClassName(),spLst)</strong>;
if (SUCCEEDED(hr))
{
     cout &lt;&lt; &quot; <strong>The number of direct children supporting CATICkeParm is (4 expected)</strong> &quot; ;
     cout &lt;&lt; <strong>spLst.Size()</strong> &lt;&lt; endl;
}</pre>
<p>This time when we retrieve the direct children (Parameters) under our root feature, 
it returns <strong>four</strong>.</p>
<p>We create a new Relation (Formula) in the step that follows. </p>
<pre class="code"><strong>CATCkeListOf(Parm) spLi</strong>;
<strong>CATICkeRelation_var spRel = spRelFact-&gt;CreateFormula(&quot;&quot;,&quot;&quot;,&quot;&quot;,spPp2,&amp;spLi,
                                            &quot;3deg&quot;,NULL_var,CATCke::False)</strong>;
<strong>piPub-&gt;AppendElement(spRel)</strong>;
</pre>
<p>The call to <code>CreateFormula</code>() of the <em>CATICkeRelationFactory</em> 
class creates a new Relation. The formulae is &quot;<strong>a=3deg</strong>&quot;.</p>
<p>We append this new relation to our root feature.</p>
<p>We proceed to retrieve the direct children (relations) under root feature.</p>
<pre class="code"><strong>spPDA-&gt;RetrieveDirectChildren (CATICkeRelation::ClassName(),spLst)</strong>;
cout &lt;&lt; &quot; <strong>The number of direct children supporting CATICkeRelation is (1 expected)</strong> &quot; ;
cout &lt;&lt; <strong>spLst.Size()</strong> &lt;&lt; endl;</pre>
<p>It outputs one relation, as expected.</p>
<p>We next proceed to remove the aggregated parameters under our root feature. We 
remove one Parameter and one Relation.</p>
<pre class="code"><strong>piPub-&gt;RemoveElement(spPp2)</strong>;
<strong>piPub-&gt;RemoveElement(spRel)</strong>;</pre>
<p>ThThis is accomplished with the <code>RemoveElement</code>() implementation on 
our root feature. This is an API exposed by the <em>CATIParmPublishere</em> Interface 
on our root feature.</p>
<p>We next retrieve the direct children under root.</p>
<pre class="code"><strong>spPDA-&gt;RetrieveDirectChildren (CATICkeParm::ClassName(),spLst)</strong>;
cout &lt;&lt; &quot; <strong>The number of direct children supporting CATICkeParm is (3 expected)</strong> &quot; ;
cout &lt;&lt; <strong>spLst.Size()</strong> &lt;&lt; endl;</pre>
<p>The number of direct children (Parameters) under root is <strong>three</strong>.
</p>
<pre class="code"><strong>spPDA-&gt;RetrieveDirectChildren (CATICkeRelation::ClassName(),spLst)</strong>;
cout &lt;&lt; &quot; <strong>The number of direct children supporting CATICkeRelation is (0 expected)</strong> &quot; ;
cout &lt;&lt; <strong>spLst.Size()</strong> &lt;&lt; endl;</pre>
<p>The number of direct relations under Root is <strong>zero</strong>.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Implementing CATIParmPublisher</h3>
<p>The <em>CATIParmPublisher</em> In Interface is dedicated to Parameter publishing. 
It is typically implemented by those objects which want to publish their own parameters 
for F(x) and Knowledge Advisor. The Interface has two goals</p>
<ul>
	<li><code>AppendElement</code> and <code>RemoveElement</code> used by Knowledgeware 
		to add/remove KBware features to the root (example: user parameters or relations)</li>
	<li><code>VisitChildren</code> used to find from the Root Object, objects that 
		are relevant from the Knowledge point of view namely. Parameters and Relations. 
		These objects are typically those which implement <em>CATIParmPublisherm</em>.&nbsp; 
		This Interface must atleast be implemented by the root features (ex: Part). 
		Other application features may implement this Interface to answer more locally 
		(in other words, be filtered by) the VisitChildren call. </li>
</ul>
<p>The KnowledgeInterfaces framework provides you with the <em>CATParmPublisherAdapter</em> 
adapter. You redefine the <code>GetDirectChildren</code>, <code>GetAllChildren</code>,
<code>Append</code> and <code>RemoveChild</code> methods by deriving this adapter.</p>
<p>As depicted by the code extract below, we create a component <em>CAALifMyPublisher</em>, 
a Code Extension for the <strong>CAALifSimpleFeature</strong> Late Type. </p>
<pre class="code">#include &quot;TIE_CATIParmPublisher.h&quot;
<strong>TIE_CATIParmPublisher(CAALifMyPublisher)</strong>;

#include &quot;TIE_CATIParmDirectAccess.h&quot;
<strong>TIE_CATIParmDirectAccess(CAALifMyPublisher)</strong>;

<strong>CATImplementClass</strong>(<strong>CAALifMyPublisher</strong>,<strong>CodeExtension</strong>,CATBaseUnknown,<strong>CAALifSimpleFeature</strong>);
</pre>
<p>The KnowledgeInterfaces framework provides us with the <em>CATParmPublisherAdapter</em> 
adapter class. So our component derives from it, as depicted in the code below.</p>
<pre class="code"><strong>class  CAALifMyPublisher : public CATParmPublisherAdapter</strong></pre>
<p>In this component we will be redefining the methods <code>GetDirectChildren</code>,
<code>GetAllChildren</code>, <code>Append</code> and <code>RemoveChild</code>.</p>
<p>You can implement the <em>CATIParmPublisher</em> me methods in several ways. 
Nevertheless, it is is recommended to gather all the objects (parameters and relations) 
to be published in a tk_list(tk_component) attribute added to the parent feature. 
Implementing the <code>GetDirectChildren</code> and <code>Append</code> methods 
will be made easy thanks to the use of the services provided by the FeatureModeler 
framework to manipulate list(component) attributes. Please take a look at the OSM 
file contents in an earlier section&nbsp; which depicts the feature definition (<a href="#What">contents 
of the catalog OSM</a>)</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step31"></a>Implementing AppendElement()</h4>
<p>We begin with the <code>AppendElement</code> implementation. It simply involves 
aggregating a Knowledge Parameter under the invoking feature.&nbsp; </p>
<pre class="code">void <strong>CAALifMyPublisher::AppendElement  (const CATBaseUnknown_var &amp; iKBwareObject )</strong>
{
    <strong>Append(iKBwareObject)</strong>;
}
</pre>
<p>It simply calls the <code>Append</code>() method. The KBware object is simply 
redirected (passed) to the <code>Append</code> method. </p>
<p>The real implementation is the <code>Append</code> method that follows.</p>
<pre class="code">void <strong>CAALifMyPublisher::Append  (const CATBaseUnknown_var &amp; spKBwareObject )</strong> 
{
    HRESULT hr = E_FAIL;

    <strong>CATFmFeatureFacade FeatFacadeOnThis(*oCreds,this)</strong>;

    <strong>CATFmAttributeName AttrName(&quot;components&quot;)</strong>;
        
    CATFmFeatureFacade FeatFacadeOnInputFeat;
    <strong>FeatFacadeOnInputFeat = (CATBaseUnknown*)spKBwareObject</strong>;

    CATFmAttributeValue AttrValue;
<strong>    AttrValue.SetFeature(FeatFacadeOnInputFeat)</strong>;

    hr = <strong>FeatFacadeOnThis.AppendValue(AttrName,AttrValue)</strong>;
}</pre>
<p>A <em>CATCATFmFeatureFacade</em> type on the current object is created (<code>FeatFacadeOnThis</code>).</p>
<p>Next, a Feature Facade is created with the Knowledge Parameter input, as an underlying 
feature. (FeatFacadeOnInputFeat)</p>
<p>A <em>CATFmAttributeValue</em> ty type is updated with this Knowledge Parameter 
feature, with a call to <code>SetFeature</code>() of the <em>CATFmAttributeValuem</em> 
class.</p>
<p>FinFinally the call to <code>AppendValue</code>() of the <em>CATFmFeatureFacadem</em> 
class, valuates the 'components' attribute with this attribute value. This effectively 
aggregates the input Knowledge Parameter under the invoking feature.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step32"></a>Implementing RemoveElement()</h4>
<p>In contrast to this, we have the RemoveElement() implementation that follows. 
It simply removes a parameter aggregated under the invoking feature. </p>
<pre class="code">void <strong>CAALifMyPublisher::RemoveElement  (const CATBaseUnknown_var &amp; iKBwareObject )</strong> 
{
	<strong>RemoveChild(iKBwareObject)</strong>;
}
</pre>
<p>It It simply calls the <code>RemoveChild</code>() method. The KWware object is 
simply redirected (passed) to the <code>RemoveChild</code>() routine. </p>
<p>The real implementation is the <code>RemoveChild</code>() method that follows.
</p>
<pre class="code">void <strong>CAALifMyPublisher::RemoveChild  (const CATBaseUnknown_var&amp; spKBwareObject )</strong> 
{
    <strong>CATFmFeatureFacade FeatFacadeOnThis(*oCreds,this)</strong>;
 
    <strong>CATFmAttributeName AttrName(&quot;components&quot;)</strong>;
    
    CATFmFeatureFacade FeatFacadeOnInputFeat;
    <strong>FeatFacadeOnInputFeat = (CATBaseUnknown*)spKBwareObject</strong>;

    CATFmAttributeValue AttrValue;
    <strong>AttrValue.SetFeature(FeatFacadeOnInputFeat)</strong>;

    int oIndex = 0;
    HRESULT hr =  <strong>FeatFacadeOnThis.LocateValue(AttrName,AttrValue,oIndex)</strong>;
    if (S_OK == hr)
        hr = <strong>FeatFacadeOnThis.DetachComponent(AttrName,oIndex)</strong>;
}
</pre>
<p>A <em>CATCATFmFeatureFacade</em> type on the current object is created (<code>FeatFacadeOnThis</code>).</p>
<p>Next, a Feature Facade is created with the Knowledge Parameter input, as an underlying 
feature. (<code>FeatFacadeOnInputFeat</code>)</p>
<p>A <em>CATFmAttributeValue</em> ty type is updated with this Knowledge Parameter 
feature, with a call to <code>SetFeature</code>() of the <em>CATFmAttributeValue</em> 
class.</p>
<p>TheThe call to <code>LocateValue</code>() of the <em>CATFmFeatureFacadem</em> 
cl class (<code>FeatFacadeOnThis</code>) retrieves the index (first occurrence) 
at which the feature to be removed is found.</p>
<p>The next call to <code>DetachComponent</code>() of the <em>CATFmFeatureFacad</em> 
c class (<code>FeatFacadeOnThis</code>) removes the aggregation of the input Knowledge 
Parameter, without actually deleting it. </p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step33"></a>Implementing VisitChildren()</h4>
<p>This method is the one to browse the publisher's hierarchy (recursively or not). 
The choice of good instances is delegated to the given visitor. It can put good 
instances in a list, or keep only one, depending on the goal of the visit.&nbsp; 
The principle is to visit each published instance and if the visit is recursive, 
to call VistChildren() on each instance implementing <em>CATIParmPublisher</em>.</p>
<pre class="code">void <strong>CAALifMyPublisher::VisitChildren( CATIVisitor* iVisitor, const int iRecursively)</strong>
{
    HRESULT hr = E_FAIL;
    if (!iVisitor) return;

<strong>    CATFmFeatureFacade FeatFacadeOnThis(*oCreds,this)</strong>;

    // Trigger the visitor on the parameter under the attribute &quot;LifFeatureLength&quot;
    <strong>CATFmAttributeName AttrName(&quot;LifFeatureLength&quot;)</strong>;
    CATFmAttributeValue AttrValue;
    hr = <strong>FeatFacadeOnThis.GetValue(AttrName,AttrValue)</strong>;
    if (S_OK == hr)
    {
        CATFmFeatureFacade FeatFacadeOnFeatStored;
        hr = <strong>AttrValue.GetFeature(FeatFacadeOnFeatStored)</strong>;
        if (S_OK == hr)
        {
            <strong>CATBaseUnknown_var spCBUOnFeatStored = FeatFacadeOnFeatStored.GetFeature()</strong>;
            <strong>iVisitor-&gt;Visit((CATBaseUnknown*)spCBUOnFeatStored)</strong>;
        }
    }

    ...
}
</pre>
<p>A <em>CATCATFmFeatureFacade</em> type on the current object is created (<code>FeatFacadeOnThis</code>).</p>
<p>We simply retrieve the component aggregated (by valuating the &quot;<strong>LifFeatureLength</strong>&quot; 
attribute) under our root feature. The feature is retrieved as a <em>CATFmFeatureFacade</em> 
ty type (<code>FeatFacadeOnFeatStored</code>). </p>
<p>Finally, this aggregated feature is input to the Visit() call of the <em>CATIVisitor</em> 
class (iVisitor input)</p>
<p>On similar lines, we retrieve each component aggregated (by valuating the '<strong>components</strong>' 
attribute) under our root feature. Next, we invoke Visit() on each of those features, 
as depicted by the code that follows. </p>
<pre class="code">void <strong>CAALifMyPublisher::VisitChildren( CATIVisitor* iVisitor, const int iRecursively)</strong>
{
    ...
    
    //Next trigger the visitor on each member of the list &quot;components&quot;
<strong>    CATFmAttributeName AttrName_components(&quot;components&quot;);
</strong>    hr = <strong>FeatFacadeOnThis.GetValue(AttrName_components,AttrValue)</strong>;
    if (S_OK == hr)
    {
        CATListValCATBaseUnknown_var oListOfFeat;
        hr = <strong>AttrValue.ConvertToListOfFeatures(oListOfFeat)</strong>;
        int size = oListOfFeat.Size();
        if (S_OK == hr)
        {
            <strong>for (int i=1; i&lt;=size;i++)</strong>
            {
                <strong>CATBaseUnknown_var spCBUOnFeatStored = oListOfFeat[i]</strong>;
                <strong>iVisitor-&gt;Visit((CATBaseUnknown*)spCBUOnFeatStored)</strong>;
            }
        }
        
     ...
}
</pre>
<p>FinFinally, if a recursive option is set to TRUE, the call to <code>VisitChildren</code>() 
is invoked on each aggregated instance recursively.</p>
<pre class="code">void <strong>CAALifMyPublisher::VisitChildren( CATIVisitor* iVisitor, const int iRecursively)</strong>
{
        ...

<strong>        if (iRecursively)</strong>
        {
<strong>            for (int j=1; j&lt;=size; j++)</strong>
            {
                // Check if the feat implements CATIParmPublisher (an equivalent of that after migration) 
<strong>                CATIParmPublisher_var publisher = oListOfFeat[j]</strong>;
                //useless test but mkscc will produce an error here.
                if(publisher != NULL_var)
<strong>                    publisher-&gt;VisitChildren( iVisitor, iRecursively )</strong>;
             }
         }
         
        ...
}
</pre>
<p>For each component aggregated, the <em>CATIParmPublisher</em> I Interface is 
retrieved. The call to <code>VisitChildren</code>() is then invoked on each component.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>Implementing CATIParmDirectAccess</h3>
<p>We saw in the earlier section that a feature which publishes parameters implements
<em>CATIParmPublisher</em>. Now, normally there is a need to retrieve these 
parameters as well from the publishing feature. Hence, the published feature also 
implements the <em>CATIParmDirectAccess</em> Interface, which is primarily responsible 
for retrieving its direct children (either Parameters or Relations).</p>
<pre class="code">...
#include &quot;TIE_CATIParmDirectAccess.h&quot;
<strong>TIE_CATIParmDirectAccess(CAALifMyPublisher)</strong>;

<strong>CATImplementClass</strong>(<strong>CAALifMyPublisher</strong>,<strong>CodeExtension</strong>,CATBaseUnknown,<strong>CAALifSimpleFeature</strong>);</pre>
<p>Our <em>CAALifPublisher</em> component also implements the <em>CATIParmDirectAccess</em> 
Interface as depicted in the code above. This involves implementing the <code>RetrieveDirectChildren</code>() 
API as depicted below. </p>
<pre class="code">HRESULT <strong>CAALifMyPublisher::RetrieveDirectChildren (CATClassId iIntfName,CATLISTV(CATBaseUnknown_var) &amp;iListToFill)</strong>   const 
{
<strong>    if (CATICkeParm::ClassName() == iIntfName)</strong>
<strong>	    ((CAALifMyPublisher*)this)-&gt;GetDirectChildren (IID_CATICkeParm,iListToFill)</strong>;
    else <strong>if (CATICkeRelation::ClassName() == iIntfName)</strong>
<strong>        ((CAALifMyPublisher*)this)-&gt;GetDirectChildren (IID_CATICkeRelation,iListToFill)</strong>;

    return S_OK;
}</pre>
<p>One may either seek for Parameters or Relations aggregated under a feature. A 
Parameter implements <em>CATICkeParm</em> while a Relation implements <em>CATICkeRelation</em>. 
W. We simply invoke the <code>GetDirectChildren</code>() method further which infact 
retrieves the appropriate children. Its implementation follows.</p>
<pre class="code">void <strong>CAALifMyPublisher::GetDirectChildren (const IID &amp; iIID,CATLISTV(CATBaseUnknown_var) &amp; oListToFill)</strong> 
{
    HRESULT hr = E_FAIL;

<strong>    CATFmFeatureFacade FeatFacadeOnThis(*oCreds,this)</strong>;

<strong>    CATFmAttributeName AttrName(&quot;LifFeatureLength&quot;)</strong>;
    CATFmAttributeValue AttrValue;
    hr = <strong>FeatFacadeOnThis.GetValue(AttrName,AttrValue)</strong>;

    if (S_OK == hr)
    {
        CATFmFeatureFacade FeatFacadeOnFeatStored;
        hr = <strong>AttrValue.GetFeature(FeatFacadeOnFeatStored)</strong>;  
        if (S_OK == hr)
        {
            CATBaseUnknown* pAsked = NULL;
            hr = <strong>FeatFacadeOnFeatStored.QueryInterfaceOnFeature(iIID,(void**)&amp;pAsked)</strong>;
            if (SUCCEEDED(hr))
            {
                <strong>oListToFill.Append(pAsked)</strong>;
            }
        }
    }
   <strong> </strong>
    ...
}
</pre>
<p>We append to the input list the component aggregated by the attribute &quot;<strong>LifFeatureLength</strong>&quot; 
(type <strong>component</strong>). The objects retrieved are of the type specified 
by the Interface type input (<strong>IID</strong>). </p>
<pre class="code">void <strong>CAALifMyPublisher::GetDirectChildren (const IID &amp; iIID,CATLISTV(CATBaseUnknown_var) &amp; oListToFill)</strong> 
{
    ...  
              
<strong>    CATFmAttributeName AttrName_components(&quot;components&quot;)</strong>;
    hr = <strong>FeatFacadeOnThis.GetValue(AttrName_components,AttrValue)</strong>;
    if (S_OK == hr)
    {
        CATListValCATBaseUnknown_var oListOfFeat;
        hr = <strong>AttrValue.ConvertToListOfFeatures(oListOfFeat)</strong>;
        if (S_OK == hr)
        {
           int size = oListOfFeat.Size();
           for (int i=1; i&lt;=size; i++)
           {
               <strong>CATBaseUnknown_var spCBUOnFeat = oListOfFeat[i]</strong>;
               CATBaseUnknown* pAsked_1 = NULL;
               hr = <strong>spCBUOnFeat-&gt;QueryInterface(iIID,(void**)&amp;pAsked_1)</strong>;
               if (SUCCEEDED(hr))
               {
                   <strong>oListToFill.Append(oListOfFeat[i])</strong>;
      ...
}
</pre>
<p>We then proceed to append the input list, the objects aggregated by the attribute &quot;components&quot; 
(type <strong>component</strong> <strong>list</strong>). The objects retrieved are 
those of the type specified by the Interface type input (<strong>IID</strong>).</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>Epilog</h3>
<pre class="code">int main (int argc, char** argv)
{
  ...
  rc = services.<strong>CAALifCloseSession</strong>();
  return rc;
};</pre>
<p>The <code>CAALifCloseSession</code> method of the <em>CAALifServices</em> class 
defined in the <code>CAALifBasis.m</code> module deletes the session.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This use case shows how to publish the attributes of a feature and illustrates 
how to implement the <em>CATIParmPublisher</em> and <em>CATIParmDirectAccess</em> 
on any feature to be published.</p>
<p>The recommended implementation requires a <strong>tk_component</strong> or/and 
a<strong> tk_list</strong>(<strong>tk_component</strong>) added to the feature to 
be published.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td>
		<a href="../CAAKniKnowledgeAdvisor/CAALifFirstApplication.htm">
		Getting Started with Knowledge Interfaces Programming</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td>
		<a href="../CAAKniKnowledgeAdvisor/CAALifFormulas.htm">
		Creating and Managing Formulas</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [Jun 2000]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
