<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>How to Describe State Dialog Commands Using UML</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>How to Describe State Dialog Commands Using UML</h1>
		</td>
	</tr>
	<tr>
		<td class="tech">Technical Article</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>State dialog commands can be easily designed using state machines, and 
		described using statechart diagrams expressed using the Unified Modeling 
		Language (UML) as a dialog description tool. This article introduces the 
		sate machines and the graphical formalism of the UML.</p>
		<ul>
			<li><a href="#100000">State Machines</a></li>
			<li><a href="#200000">Statechart Diagrams</a>
				<ul>
					<li><a href="#210000">Example of the Line Command</a></li>
					<li><a href="#220000">Graphical Notation Standard</a></li>
					<li><a href="#230000">Simple and Composite States</a></li>
				</ul>
			</li>
			<li><a href="#300000">Dialog Agents</a>
				<ul>
					<li><a href="#310000">Dialog Agents and Input-Driven Transitions</a></li>
					<li><a href="#320000">Dialog Agents Enable Straightforward Statechart 
						Diagrams</a></li>
					<li><a href="#330000">Dialog Agents and Conditions</a></li>
				</ul>
			</li>
			<li><a href="#400000">An Artificial Interlocutor</a>
				<ul>
					<li><a href="#410000">Interacting with the Line Command</a></li>
					<li><a href="#420000">One-Shot Input</a></li>
					<li><a href="#430000">Repeated Input</a></li>
				</ul>
			</li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="100000"></a>State Machines</h2>
<p>A <em>state machine</em> reacts to events applied to it by external objects, 
according to the Unified Modeling Language (UML) semantics [<a href="#References">1</a>]. 
Dialog state commands are modeled as state machines. A state machine describes an 
object's behavior as a graph made of <em>states</em> linked between them using incoming 
and outgoing <em>transitions</em>. A transition is usually triggered thanks to an
<em>event</em>, and usually checks that a <em>guard condition</em> evaluates to 
true before executing the <em>action</em> associated with the state. The transition
<em>source state</em> becomes <em>inactive</em> and the transition <em>target state</em> 
becomes <em>active</em>. The <em>initial state</em> and the <em>final state</em> 
are <em>pseudo states</em> between which the state machine states range.</p>
<p>A state machine is divided into <em>steps</em>, and the fundamental assumption 
is that events are processed in sequence. Each event stimulates a <em>run-to-completion</em> 
step. This simplifies transitions in a state machine, since any incoming event is 
processed only after the state machine has reached a stable <em>state configuration</em>.</p>
<p>Transitions can be triggered not only by events, but also by conditions, or both. 
They can be also automatically triggered, or automatically triggered with respect 
to a guard condition.</p>
<p>A state can be decomposed into substates, and is there called a <em>composite 
state</em>. Two refinement ways are possible: sequential substates, that is substates 
that are linked with transitions in sequence, one being active at a given instant, 
and concurrent substates that are mutually exclusive substates that are active at 
the same time. Each substate can be in turn refined.</p>
<p>Transitions can be assembled in clusters of transitions named <em>compound</em> 
transitions, or <em>complex</em> transitions by UML notation.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="200000"></a>Statechart Diagrams</h2>
<p>A statechart diagram is intended to graphically represent a state machine.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="210000"></a>Example of the Line Command</h3>
<p>UML provides a means to describe and graphically represent state machines using 
statechart diagrams, that prove useful when designing dialog state commands. Let's 
take the example of the Line command [<a href="#References">2</a>]. The Line command, 
as any state dialog command, could be described as a state machine and represented 
using the UML notation [<a href="#References">3</a>] as shown in Fig. 1.</p>
<table>
	<caption>Fig. 1: The Line Command Statechart Diagram</caption>
	<tr>
		<td>
		<img alt="Line Command Statechart Diagram" height="271" src="images/CAADegStateChart1.gif" width="569"/></td>
	</tr>
</table>
<p>The state machine progresses from the initial state to the final state. The dialog 
flow starts with the initial state, which is a pseudo state that has no incoming 
transition. The command is never in the initial state that automatically skips to 
the first state. This first state is dedicated to the start point input and is shown 
as a state vertex using a round corner box that displays the state name. A prompt 
linked to the first state can invite the end user to indicate this start point. 
The transition between the first state and the second state is triggered as soon 
as the end user indicates a valid point. This happens when the expected event is 
detected (the mouse left key is pressed), and when the guard condition is satisfied. 
The transition action, that is create a temporary point, is executed. A prompt linked 
to the second state can then invite the end user to indicate the end point. The 
transition to the final state is triggered as soon as the end user indicates a valid 
point. This creates the line. The final state is reached, and the command completes.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="220000"></a>Graphical Notation Standard</h3>
<p>We use the UML notation [<a href="#References">3</a>]</p>
<table>
	<tr>
		<td><em>State vertices</em></td>
		<td>Round corner boxes showing the state name</td>
		<td style="text-align:center">
		<img alt="State Machine State" height="42" src="images/CAADegSMState.jpg" width="122"/></td>
	</tr>
	<tr>
		<td><em>Transitions</em></td>
		<td>Arrows between state vertices</td>
		<td style="text-align:center">
		<img alt="State Machine Transition" height="54" src="images/CAADegSMTransition.jpg" width="12"/></td>
	</tr>
	<tr>
		<td><em>Initial state</em></td>
		<td>A small solid filled circle</td>
		<td style="text-align:center">
		<img alt="State Machine Initial State" height="20" src="images/CAADegSMInitialState.jpg" width="21"/></td>
	</tr>
	<tr>
		<td><em>Final state</em></td>
		<td>A circle surrounding a small solid filled circle</td>
		<td style="text-align:center">
		<img alt="State Machine Final State" height="27" src="images/CAADegSMFinalState.jpg" width="29"/></td>
	</tr>
	<tr>
		<td><em>Events</em></td>
		<td>Text</td>
		<td>left-mouse-down</td>
	</tr>
	<tr>
		<td><em>Guard conditions</em></td>
		<td>Text between square brackets</td>
		<td>[point indicated &amp;&amp; point valid]</td>
	</tr>
	<tr>
		<td><em>Actions</em></td>
		<td>Text beginning with a slash</td>
		<td>/ create line</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="230000"></a>Simple and Composite States</h3>
<p>Command input can be a bit more complex than the one of the Line command shown 
above. A composite input can be necessary when an applicative task requires at least 
two input without taking care of the order in which they are provided by the user. 
This is a common situation as illustrated by a Sphere creation dialog:</p>
<ul>
	<li>&quot;<em>A sphere is created when the user has provided a center
		<strong>and</strong> a radius</em>&quot;.</li>
</ul>
<p>With simple states, the statechart diagram could be as shown in Fig. 2.</p>
<table>
	<caption>Fig. 2: The Sphere Command Statechart Diagram with Simple States</caption>
	<tr>
		<td>
		<img alt="Sphere Command Statechart Diagram with Simple States" height="322" src="images/CAADegSphereSimpleStatechart.gif" width="345"/></td>
	</tr>
</table>
<p>But composite input can be also described thanks to concurrent composite states. 
A composite state is the result of a state decomposed into substates. It is said 
to be concurrent if the decomposition results in substates that are all active, 
or non-concurrent if one only is active. Each substate can in turn be refined into 
its own substates.</p>
<p>Using a concurrent composite state, the sphere dialog statechart diagram is simplified, 
as shown in Fig. 3. It is made of a single concurrent composite state between the 
initiaml and the final states, that includes two concurrent substates. These two 
substates are active when the state machine transitions from the initial state to 
the concurrent composite state. Each substate is shown as a nested statechart diagram, 
including its own initial state, and its own final state. Both final states must 
have been reached to trigger the transition that creates the sphere.</p>
<table>
	<caption>The Sphere Command Statechart Diagram with a Concurrent Composite State</caption>
	<tr>
		<td>
		<img alt="Sphere Command Statechart Diagram with a Concurrent Composite State" height="170" src="images/CAADegSphereCompositeState.gif" width="566"/></td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="300000"></a>Dialog Agents</h2>
<p>A <em>dialog agent</em> translates a user interaction into a user input. This 
translation is managed by a state machine that is encapsulated by the dialog agent. 
As an example, the indication agent interprets a left button mouse click as a 2D-coordinate 
input.</p>
<p>
<img alt="Dialog Agent State Machine" height="103" src="images/CAADegDialogAgentStateMachine1.gif" width="398"/></p>
<p>The dialog agent hides the details of how a user interaction, here a mouse click 
in a 2D viewer, is translated as a user input, that is 2D coordinates.</p>
<p>The keypoint is that dialog agents strenghtens the MVC model by shifting from 
an <em>event-driven</em> dialog to an <em>input-driven </em>dialog: using a indication 
agent allows a dialog command to read 2D coordinates without taking care of how 
the end user provides them, for example by keying numeric values or by clicking 
the left button of the mouse in a 2D viewer.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="310000"></a>Dialog Agents and Input-Driven Transitions</h3>
<p>The new representation highlights event encapsulation by using <em>input-driven</em> 
transitions instead of <em>event-driven</em> transitions.</p>
<p>An <em>input-driven</em> transition is a kind of condition-driven transition 
which requires a user input. The condition has a validation responsibility toward 
the end user input: the input may be constrained. For example, the position should 
be within the drawing sheet ([position within sheet?]), or elsewhere ([position?]).</p>
<p>
<img alt="Dialog Agent State Machine" height="202" src="images/CAADegDialogAgentStateMachine2.gif" width="418"/></p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="320000"></a>Dialog Agents Enable Straightforward Statechart Diagrams</h3>
<p>Using dialog agents simplifies further the Sphere dialog:</p>
<p>
<img alt="Dialog Agent State Machine" height="208" src="images/CAADegDialogAgentStateMachine3.gif" width="592"/></p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="330000"></a>Dialog Agents and Conditions</h3>
<p>Statechart diagrams representing state dialog commands are often input-driven. 
This characteristic impacts the test of conditions:</p>
<ul>
	<li>In a traditional state machine, condition-driven transitions are tested 
		as soon as a state becomes active.</li>
	<li>In a statechart of a state dialog command, the input-driven transitions 
		are tested only after an end user input. This makes sense because a condition 
		may become true only if new input has been provided.</li>
</ul>
<p>Some dialogs contain ambiguous conditions. In this case the transition order 
is crucial: the first transition which matches the user interaction wins while the 
others are not even warned.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="400000"></a>An Artificial Interlocutor</h2>
<p>A state dialog command embodies a part of the developer's know-how to interact 
with the end user like an alter-ego. This section shows how this interactivity takes 
place.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="410000"></a>Interacting with the Line Command</h3>
<p>From the user's point of view, the Line dialog follows a step by step scenario:</p>
<p>
<img alt="Line Command State Chart" height="332" src="images/CAADegLineCmdStatechart.gif" width="446"/></p>
<p>In the case of the Line command, the dialog agent to acquire points is recycled 
after the first transition to be reused in the second transition as if it were a 
new one.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="420000"></a>One-Shot Input</h3>
<p>Once a valid input has been provided, the agent becomes inactive (this is shown 
by the checkmark): the user is no more prompted to provide an input.</p>
<p><strong>Graphical Representation:</strong>
<img alt="Check Mark" height="12" src="images/CAADegdepg0a10.gif" width="12"/> 
The <em>checkmark</em> symbolizes a valid input.</p>
<p>The one-shot input behavior doesn't make a difference in the Line command dialog 
but it is not the case with the Sphere command dialog:</p>
<p>
<img alt="Sphere State Chart" height="275" src="images/CAADegSphereStatechart.gif" width="333"/></p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="430000"></a>Repeated Input</h3>
<p>A <em>repeater</em> agent is not deactivated by a user input as opposed to a
<em>one-shot</em> agent (default mode). If we set the radius agent as a repeater 
in the Sphere dialog, the user will be able to modify the radius as long as the 
center is not provided.</p>
<p><strong>Graphical Representation</strong>:
<img alt="Repeated Input" height="12" src="images/CAADegdepg0aa2.gif" width="12"/> 
The repeat mark symbolizes a repeater agent.</p>
<p>The repeated input behavior for the radius input of the Sphere command dialog 
enables the end user to modify the radius value after it was input, as long as the 
center is not input.</p>
<p>
<img alt="Sphere State Chart Repeat" height="274" src="images/CAADegSphereStatechartRepeat.gif" width="332"/></p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>A state dialog command is modeled as a state machine and can be graphically represented 
using a statechart diagram expressed using the Unified Modeling Language (UML).</p>
<p>Dialog agents are specific encapsulated state machines that simplifies the dialog 
by replacing several states and event-driven transitions by a composite state and 
a simple input-driven transition. Dialog agents can be valued in one shot, or proposed 
again for input value modification. They can also be recycled.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td>Unified Modeling Language - UML Semantics version 1.1</td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAADegTaGettingStarted.htm">Getting Started with State Dialog 
		Commands</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td>Unified Modeling Language - UML Notation Guide version 1.1</td>
	</tr>
</table>
<hr />
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [Jan 2000]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
