<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 12.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="Stylesheet" type="text/css" href="../CAADocStyleSheets/caav5.css">
<script language="JavaScript" src="../CAADocJavaScript/submit.js"></script>
<title>PLM Glossary</title>
</head>

<body>
<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>PLM Glossary</h1>
		</td>
	</tr>
	<tr>
		<td class="tech">Documentation Glossary</td>
	</tr>
</table>

<hr>
<!---------------------------------comment------------------------------------->

<table class="abstract">
  <tr>
    <td>
      [<a href="#LetterA"><strong>A</strong></a>|<strong>B</strong>|<a
  href="#LetterC"><strong>C</strong></a>|<a href="#LetterD"><strong>D</strong></a>|<a
  href="#LetterE"><strong>E</strong></a>|<strong>F</strong>|<strong>G</strong>|<strong>H</strong>|<a
  href="#LetterI"><strong>I</strong></a>|<strong>J</strong>|<strong>K</strong>|<a
  href="#LetterL"><strong>L</strong></a>|<a href="#LetterM"><strong>M</strong></a>|<strong>N</strong>|<strong><a href="#O">O</a></strong>|<strong><a href="#LetterP">P</a></strong>|<strong><a href="#LetterQ">Q</a></strong>|<strong><a href="#LetterR">R</a></strong>|<a
  href="#LetterS"><strong>S</strong></a>|<a href="#LetterT"><strong>T</strong></a>|<strong>U</strong>|<strong><a href="#LetterV">V</a></strong>|<strong>W</strong>|<strong>X</strong>|<strong>Y</strong>|<strong>Z</strong>]</font></td>
  </tr>
</table>
<!---------------------------------comment------------------------------------->
<hr>
<!---------------------------------comment------------------------------------->


<body>

<h1><span lang="en-us"><a name="LetterA">A</a></span></h1>
<h2><span lang="en-us"><a name="(PLM)_Application_">(PLM) Application</a></span></h2>
<p><span lang="en-us">A PLM Application fulfills requirement of a precise 
applicative domain. It is made of:</span></p>
<ul>
	<li><span lang="en-us">Application code in the client authoring editor. It 
	implements the User Interface. It uses the services of the PLM modeler that 
	the application is build upon. It may enforce application logic, 
	complementary to business rules of the PLM Modeler, and compatible with 
	them.</span></li>
	<li><span lang="en-us">&nbsp;If needed, additional applicative attributes if the 
	PLM Modeler does not offer them. These attributes are stored in a dedicated 
	PLM Extension of the PLM Component. </span></li>
</ul>
<p><span lang="en-us">Several applications can be built upon the same PLM 
Modeler.</span></p>
<p>main article :
</p>
<h2><span lang="en-us"><a name="(PLM)_Attributes_">(PLM) Attributes</a></span></h2>
<p><span lang="en-us">This is what the PLM Classes are made of. They are 
described in the PLM Dictionary. They are of one of the following kinds:</span></p>
<ol>
	<li><span lang="en-us">Simple: of type integer, double, string, boolean</span></li>
	<li><span lang="en-us">List of them: A list is ordered and allows several 
	same values.</span></li>
	<li><span lang="en-us">Set of them: A set in unordered. Value uniqueness is 
	enforced. This is why set of Boolean are of no interest and are not 
	supported. </span></li>
</ol>
<p><span lang="en-us">They compose without transformation the static structure 
of the PLM Component in session and in persistency. They are persistently stored 
in the Vault Data Base and can be used for query purpose.</span></p>
<p>main article : <a href="CAAPLMTaAllAttributes.htm">Understanding PLM 
Attributes</a></p>
<h1><span lang="en-us"><a name="LetterC">C</a></span></h1>
<h2>(PLM) Class </h2>
<p>It is logical representation of an element defining a PLM Modeler. A PLM 
Modeler is defined by several PLM Classes (not more 6). A PLM Class contains PLM 
Attributes, PLM relations and PLM Behaviors. A PLM Class has a name, its type, 
and an use which can be:</p>
<ul>
  <li>Instantiation : Concrete class which can only used to be instantiated</li>
   <li>Customization : Abstract class which is a base class to create an instantiation class</li>

 <li>Internal: Abstract class which is a base class to create a PLM class having one of the three uses: Instantiable , Customization, Internal</li>

</ul>
<p>main article : <a href="CAAPLMTaAllPLMDictionary.htm">Understanding PLM 
Dictionary</a></p>
<h2><span lang="en-us"><a name="(PLM)_Component_">(PLM) Component</a></span></h2>
<p><span lang="en-us">The PLM Component is the &quot;session&quot; view of a PLM Object.</span></p>
<p>main article :</p>
<h2><span lang="en-us"><a name="(PLM)_Connection_">(PLM) Connection</a></span></h2>
<p><span lang="en-us">One of the six PLM Core types.</span></p>
<p><span lang="en-us">PLM Connection aim is to materialize relationships with 
Semantic information between PLM entities in a context of a Reference object. 
Those relationships can be IN or OUT; so a Connection can also be viewed as a 
flow.</span></p>
<p><span lang="en-us">Connections do reference PLM Entities inside the same 
context reference, or one, or several levels below</span></p>
<p><span lang="en-us">Those referenced PLM Entities can be Instances, 
RepInstances or Ports.</span></p>
<p>main article : <a href="CAAPLMTaAllCoreModelerReference.htm">PLM Core Modeler 
Reference</a></p>
<h2><span lang="en-us"><a name="CRUD_">CRUD</a></span></h2>
<p><span lang="en-us">Acronym for</span></p>
<blockquote>
	<p><span lang="en-us">CReate<br>Update<br>Delete</span></p>
</blockquote>
<p><span lang="en-us">These are the only operations that a PLM Save Message 
contains 
</span> </p>
<h2><span lang="en-us">(PLM) <a name="Customization_">Customization</a></span></h2>
<p><span lang="en-us">A PLM customization is a customization of a PLM Modeler Type. 
It is achieved by</span></p>
<ul>
	<li><span lang="en-us">adding it attributes: simples, lists or sets.</span></li>
	<li><span lang="en-us">defining its Identification Set.</span></li>
</ul>
<p><span lang="en-us">Customer IT department needs to customize all the PLM 
Modeler Types that have been declared Customizable. They can be customized only 
one time per customization. But multiple customizations may exist. One 
customization is typically associated to a customer project.</span></p>
<p><span lang="en-us">Each customization is stored in a separate metadata. 
Customizations are then packaged in Environments.</span></p>
<p><span lang="en-us">When creating a PLM Component, its customization is chosen 
from the PLM Environment definition, and not be changed later. </span> </p>
<p>main article : <a href="CAAPLMTaAllCusto.htm">Understanding PLM Modeler and 
Customization</a></p>
<h1><span lang="en-us"><a name="LetterD">D</a></span></h1>
<h2><span lang="en-us"><a name="(PLM)_Dictionary_">(PLM) Dictionary</a></span></h2>
<p>PLM Dictionary: describes the vault data structure through PLM Metadata</p>
<ul>
  <li>PLM Metadata: XML File containing a set of PLM Classes </li>
  <li> </li>
PLM Class: XML Definition of the prototype of a PLM Object</li>

</li>
</ul>
<p>main article : <a href="CAAPLMTaAllPLMDictionary.htm">Understanding PLM 
Dictionary</a></p>
<h1><span lang="en-us"><a name="LetterE">E</a></span></h1>
<h2><span lang="en-us">(PLM) <a name="Environment_">Environment</a></span></h2>
<p><span lang="en-us">It is a pre-defined package of consistent Modelers and 
Modeler Customizations that the user is choosing in his authoring session. It is 
made of:</span></p>
<ul>
	<li><span lang="en-us">A maximum of 1 authoring PLM Instantiable Set per modeler. 
	The Authoring customization defines the type of new PLM Components created 
	in the authoring session (except for instances that inherit their 
	customization type from their reference). It does however not prevent 
	authoring of PLM Entities of other customizations.</span></li>
	<li><span lang="en-us">N browse-able customizations per modeler. They define 
	which types of PLM Component the user is able to query for. </span></li>
</ul>
<p><span lang="en-us">However PLM Components of other customizations may enter 
the authoring edition. This when the user reaches them by expand operation. 
These entities can even be edited. These 2 possibilities (reachable by 
navigation and edit ability) depend on the user declared privileges.</span></p>
<p>main article : <a href="CAAPLMTaAllEnvironment.htm">Understanding PLM 
Environment</a></p>
<h1><span lang="en-us"><a name="LetterI">I</a></span></h1>
<h2><span lang="en-us"><a name="Identifier_set_">Identifier set</a></span></h2>
<p><span lang="en-us">User defined set of simple PLM Attributes. It provides 
unique user identification to the PLM Reference and PLM Representation 
Reference. It acts as its external identification.</span></p>
<p><span lang="en-us">External Identification is mandatory for Reference and 
Representation References class. It is not supported for other PLM types.</span></p>
<p><span lang="en-us">Rules apply on those attributes contributing to 
identification set ; e.g. one attribute at least of the identifier set needs to 
editable to the authoring end-user.</span></p>
<p>main article : <a href="CAAPLMTaAllAttributes.htm">Understanding PLM 
Attributes</a></p>
<h2><span lang="en-us"><a name="(PLM)_Instance_">(PLM) Instance</a></span></h2>
<p><span lang="en-us">One of the six PLM Core meta types.</span></p>
<p><span lang="en-us">PLM Instance is the result of the usage of a Reference in 
the context of another Reference.</span></p>
<p><span lang="en-us">Multi-instantiation of a same Reference is supported.</span></p>
<p>main article : <a href="CAAPLMTaAllCoreModelerReference.htm">PLM Core Modeler 
Reference</a></p>
<h2><a name="(PLM)_Instantiation_Set">(PLM) Instantiation Set</a></h2>
<p>A PLM Instantiable set is an exhaustive set of PLM Instantiable class types. It can be: </p>
<ul>
<li>A set of PLM Customization classes</li>,&nbsp; if
the PLM Modeler contains only customizable PLM classes</li>

  <li>
A set of PLM Modeler classes, if
the PLM Modeler contains only Instantiable PLM classes</li>
  <li>A mix between PLM Customization and PLM Modeler Instantiable classes</li>
</ul>
<h1>
<p>main articles : <a href="CAAPLMTaAllCusto.htm">Understanding PLM Modeler and 
Customization</a> , <a href="CAAPLMTaAllEnvironment.htm">Understanding PLM 
Environment</a></p>
<h1><span lang="en-us"><a name="LetterL">L</a></span></h1>
</h1>
<h2><span lang="en-us"><a name="Locking_">Locking</a></span></h2>
<ul>
	<li><span lang="en-us"><b>Explicit user locking</b>. The user may chose to 
	explicitly lock a PLM Component before starting editing it. He is then 
	guaranteed to be able to save it when finishing editing. But he will prevent 
	another user from editing the same entity while it is locked.<br>
&nbsp;</span></li>
	<li><span lang="en-us"><b>Automatic optimistic locking</b>. The user may 
	choose to edit PLM Components without prior explicit locking. But at save 
	time, the system will control and forbid the save if there has been a 
	concurrent edition of a same PLM Component.
	</span></li>
</ul>
<h2><span lang="en-us"><a name="Link_">Link</a></span></h2>
<p><span lang="en-us">A runtime reference to internal information of a PLM 
Component is done through a link. For example, an offset constraint between 2 
solids references their constraint faces by 2 links.</span></p>
<p><span lang="en-us">A link is persisted in 2 pieces:</span></p>
<ul>
	<li><span lang="en-us">A semantic relations that defines the &#8220;public&#8221; path 
	between the referencing and the referenced PLMComponents</span></li>
	<li><span lang="en-us">The path internal to the referenced element that is 
	stored in the referencing element.</span></li>
</ul>
<p><span lang="en-us">On Open these 2 pieces are recomposed to recreate the 
link.</span></p>
<p><span lang="en-us">A semantic relation can hosts several links between 2 PLM 
Components. By analogy, a Semantic Relation hosts a link between 2 PLMComponents 
like a raceway routes a cable between 2 pieces of equipment.</span></p>
<h1><span lang="en-us"><a name="LetterM">M</a></span></h1>
<h2><span lang="en-us"><a name="Masked_view_">Masked view</a></span></h2>
<p><span lang="en-us">PLM Dictionary describe for a given class and a given 
operation (Browse, Create, Modify, Query, &#8230;), taking security into account.</span></p>
<p>main article : <a href="CAAPLMTaAllMask.htm">PLM Mask</a></p>
<h2><span lang="en-us"><a name="(PLM)_Modeler_">(PLM) Modeler</a></span></h2>
<p><span lang="en-us">A PLM Modeler is made of</span></p>
<ul>
	<li><span lang="en-us">Definition of PLM Modeler Types.<br>
&nbsp;</span></li>
	<li><span lang="en-us">Definition in the meta data of the attributes that 
	each PLM Modeler Types contains.<br>&nbsp;</span></li>
	<li><span lang="en-us">Client authoring code.&nbsp;
	It handles the creations / editions / deletions of the entities in the 
	authoring session, enforcing the Business rules of the Modeler.<br>
	&nbsp;</span></li>
</ul>
<p>main article: <a href="CAAPLMTaAllCusto.htm">Understanding PLM Modeler and 
Customization</a></p>
<h1><a name="O">O</a></h1>
<h2>(PLM) Object</h2>
<p>It is an instantiation of a instantiable PLM Class from PLM Dictionary. The PLM Object are stored 
within the vault database.</p>
<h1><span lang="en-us"><a name="LetterP">P</a></span></h1>
<h2><span lang="en-us"><a name="(PLM)_Port_">(PLM) Port</a></span></h2>
<p><span lang="en-us">One of the six PLM Core meta types.</span></p>
<p><span lang="en-us">PLM Port is a stable abstraction of an Entity: a Contract 
on object that is defined by name &amp; specifications. It insures stable access to 
object Public data.</span></p>
<p><span lang="en-us">Port enables architecture Modeling and can be defined even 
before Detailed objects exist.</span></p>
<p><span lang="en-us">Ports can expose data from the same context Reference, or 
from a Reference one or several levels below. Ports can be referenced by objects 
one or several level above.</span></p>
<p>main article : <a href="CAAPLMTaAllCoreModelerReference.htm">PLM Core Modeler 
Reference</a></p>
<h1><span lang="en-us"><a name="LetterQ">Q</a></span></h1>
<h2><span lang="en-us"><a name="QEOPS_">QEOPS</a></span></h2>
<p><span lang="en-us">Acronym for the four basic PLM Operations:</span></p>
<blockquote>
	<blockquote>
		<p><span lang="en-us">Query<br>Expand<br>Open<br>Save</span></p>
	</blockquote>
</blockquote>
<h1><span lang="en-us"><a name="LetterR">R</a></span></h1>
<h2><span lang="en-us"><a name="Repository_">Repository</a></span></h2>
<p><span lang="en-us">Where the data are persistently stored</span></p>
<h2><span lang="en-us"><a name="(PLM)_Reference_">(PLM) Reference</a></span></h2>
<p><span lang="en-us">One of the six PLM Core meta types.</span></p>
<p><span lang="en-us">PLM Reference is the smallest atom of distribution and of 
maturity. Reference is separable (i.e. non aggregated) and supports reuse.</span></p>
<p><span lang="en-us">Reference is versionable, and carries a maturity.</span></p>
<h2><span lang="en-us"><a name="(PLM)_Representation_Instance_">(PLM) 
Representation Instance</a></span></h2>
<p><span lang="en-us">One of the six PLM Core meta types.</span></p>
<p><span lang="en-us">PLM Representation Instance (or RepInstance) is the result 
of the usage of a Representation in the context of a Reference.</span></p>
<p><span lang="en-us">Multi-instantiation of a same Representation is supported.</span></p>
<p>main article : <a href="CAAPLMTaAllCoreModelerReference.htm">PLM Core Modeler 
Reference</a></p>
<h2><span lang="en-us"><a name="(PLM)_Representation_Reference_">(PLM) 
Representation Reference</a></span></h2>
<p><span lang="en-us">One of the six PLM Core meta types.</span></p>
<p><span lang="en-us">PLM Representation is supporting attachment of Vault 
Items. Representation is separable (i.e. non aggregated) and supports reuse.</span></p>
<p><span lang="en-us">Representation is versionable, and carries a maturity.</span></p>
<p>main article : <a href="CAAPLMTaAllCoreModelerReference.htm">PLM Core Modeler 
Reference</a></p>
<h1><span lang="en-us"><a name="LetterS">S</a></span></h1>
<h2><span lang="en-us"><a name="Semantic_Relationship_">Semantic Relationship</a></span></h2>
<p><span lang="en-us">A PLM Component stores persistently a reference to another 
via a semantic relationship. It is made of:</span></p>
<ul>
	<li><span lang="en-us">Behavior description of the relationship, by its 
	Category</span></li>
	<li><span lang="en-us">A description, by its Role</span></li>
	<li><span lang="en-us">A Path to the referenced element, defined by a list 
	of PLMId.</span></li>
</ul>
<p><span lang="en-us">This could be as simple as the PLMId of a directly pointed 
PLM reference. 
</span></p>
<p><span lang="en-us">But when the pointed element is an instance, that is part 
of sub (sub) assembly, the persistent path has multiple legs. From the 
referencing context, each of them is the PLMId of the (sub) assembly instance. 
This until reaching the targeted instance.</span></p>
<h2><span lang="en-us"><a name="Store">Store</a></span></h2>
<p>set of Streams</p>
<h2><span lang="en-us"><a name="Stream">Stream</a></span></h2>
<p>A Stream is a long binary information attached to a
<a href="#(PLM)_Representation_Reference_">PLM Representation Reference</a> 
component, this attachment being implemented via an entity named
<a href="#Stream_Descriptor0">PLM Stream Descriptor</a>. There are two kinds of 
streams:</p>
<ul>
	<li>(main) <b>authoring</b> stream : containing the authoring data.</li>
	<li><b>secondary</b> stream: containing data computed from the authoring 
	data. Their access is not CAA opened. </li>
</ul>
<p>A PLM Representation has always one and only one authoring stream, but can 
have 0 to N secondary streams.&nbsp; Conversely to the PLM component saved in 
PLM database, streams are saved in the vault database. </p>
<h2><span lang="en-us">(PLM) <a name="Stream_Descriptor0">Stream Descriptor</a></span></h2>
<p>A PLM Stream Descriptor (SD) is a non-separable pure internal entity attached 
to a PLM Representation Reference component that acts as the glue between this 
PLM Representation Reference and a Stream.<br>
But in some articles, the Stream Descriptor (SD) is used in place of the
<a href="#Stream">Stream</a> word.</p>
<h1><span lang="en-us"><a name="LetterT">T</a></span></h1>
<h2><span lang="en-us"><a name="(PLM_Long)_Transaction_">(PLM Long) Transaction</a></span></h2>
<p><span lang="en-us">Paradigm of data exchange between the PLM Repository and 
the client authoring editor.</span></p>
<p><span lang="en-us">A PLM Long Transaction decomposes into:</span></p>
<ul>
	<li><span lang="en-us">The PLM Open Transaction: The PLM Components are sent 
	from the PLM repository to the DS Application authoring client session.</span></li>
	<li><span lang="en-us">The PLM Edition Session: The PLM Components are 
	edited under control of the client authoring tools. This PLM Edition Session 
	decomposes into successive CATIA Edition Transactions such to allow 
	Undo/Redo, and relievable milestone for warm start. At that time, there is 
	no communication with the repository.</span></li>
	<li><span lang="en-us">The PLM Save Transaction. On user decision, the 
	edited PLM Components are sent back to the PLM repository and are persisted.</span></li>
</ul>
<p><span lang="en-us">A limited set of operations are short transaction however: 
Lock, New Version, and Change Maturity. They involve an immediate communication 
with the server and commit in the repository.</span></p>
<h2><span lang="en-us"><a name="(PLM)_Type_">(PLM) Class Type</a></span></h2>
<p><span lang="en-us">They are of 3 kinds, corresponding to an abstract 
definition and 2 levels of specialization:</span></p>
<table border="1" width="100%" id="table1">
	<tr>
		<td width="151"><span lang="en-us">PLM Core Type</span></td>
		<td><span lang="en-us">One of the six: Reference, Instance, Connection, 
		Port, Representation and Representation Instance.<br>
		These are abstract types: They are not instantiated. All the 
		PLMComponents are of a derivate type.</span></td>
	</tr>
	<tr>
		<td width="151"><span lang="en-us">PLM Modeler Type</span></td>
		<td><span lang="en-us">Defined by a couple (Modeler, Core Type), it&#8217;s 
		the specialization of one PLM Core Types to a particular modeler. <br>
		This specialization requires client authoring code (the modeler).<br>
		A PLM Modeler Type is declared customizable or not.</span></td>
	</tr>
	<tr>
		<td width="151"><span lang="en-us">PLM Customized Type</span></td>
		<td><span lang="en-us">Defined by a triplet (Custo, Modeler, Core Type), 
		it is the specialization of a PLM Modeler Type. <br>
		This specialization is done by adding attributes to the type. No code is 
		involved. It is typically done by customer IT department </span></td>
	</tr>
</table>
<p>main article : <a href="CAAPLMTaAllPLMDictionary.htm">Understanding PLM 
Dictionary</a></p>
<h1><a name="LetterV"><span lang="en-us">V</span></a></h1>
<h2><a name="Vault">Vault</a></h2>
<p>Data base containing a set of PLM Objects</p>
</body>

</html>

