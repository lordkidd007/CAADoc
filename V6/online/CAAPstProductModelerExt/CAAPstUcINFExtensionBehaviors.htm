<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Defining Feature Extension Behaviors</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Defining Feature Extension Behaviors</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>A feature can be associated with specific behavior by implementing dedicated 
		Interfaces on it. The article &quot;<strong>Managing Feature Extensions</strong>&quot; 
		[<a href="#References">1</a>] lists and details these Interfaces.</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAAPstINFFeatExtBehaviors Use Case</a>
				<ul>
					<li><a href="#What">What Does CAAPstINFFeatExtBehaviors Do</a></li>
					<li><a href="#How">How to Launch CAAPstINFFeatExtBehaviors</a></li>
					<li><a href="#Where">Where to Find the CAAPstINFFeatExtBehaviors 
						Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case teaches an end-user the steps involved to associate various behaviors 
with feature extensions. The Interfaces and the behaviors they are responsible for 
are listed below categorized suitably</p>
<p><strong>Model</strong>:</p>
<ul>
	<li><em>CAAIPstINFRelimitedLine</em>, for introspecting (retrieve and set attribute 
		values) of our RelimitedLine.</li>
	<li><em>CATIAlias</em>, to persist the <strong>name</strong> of the feature 
		extension.</li>
	<li><em>CATIFmFeatureBehaviorCustomization</em>, to customize the delete command, 
		implement the Build method called on feature Update.</li>
</ul>
<p><strong>Visualization</strong>:</p>
<ul>
	<li><em>CATIModelEvents</em>, to <strong>update</strong> the <strong>3D visualization</strong>.</li>
	<li><em>CATI3DGeoVisu</em>, to <strong>visualize</strong> the <code>CAAPstINFRelimitedLine</code>.</li>
	<li><em>CATIVisProperties</em>, to be able to change the <strong>graphic properties</strong>.</li>
	<li><em>CATISelectShow</em>, to be able to <strong>hide/show</strong> the
		<code>CAAPstINFRelimitedLine</code>.</li>
	<li><em>CATINavigateObject</em>, to be able to navigate for our object in the 
		spec tree in V6 session.</li>
</ul>
<p><strong>Interactive Command</strong>:</p>
<ul>
	<li><em>CATIEdit</em>, to <strong>edit</strong> the <code>CAAPstINFRelimitedLine</code>.</li>
	<li><em>CATICSOFilter</em>, to <strong>filter</strong> the command in the contextual 
		menu.</li>
</ul>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAAPstINFFeatExtBehaviors Use Case</h2>
<p>CAAPstINFFeatExtBehaviors is a use case of the CAAProductStructureExtend.edu 
framework that illustrates FeatureModelerExt framework capabilities.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does CAAPstINFFeatExtBehaviors Do</h3>
<p>CAAPstINFFeatExtBehaviors explains the relevance of implementation of various 
Interfaces on a feature extension.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch CAAPstINFFeatExtBehaviors</h3>
<p>See the section entitled &quot;&gt;How to Launch the CAAPstINFRelimitedLine Use 
Case&quot; in the &quot;Integrating Applicative Features&quot; use case [<a href="#References">2</a>] 
for a detailed description of how this use case should be launched.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAAPstINFFeatExtBehaviors Code</h3>
<p>The CAAPstINFFeatExtBehaviors use case is made of several classes listed below, 
categorized suitably.</p>
<p><strong>Model</strong>:</p>
<ul>
	<li><strong>CAAEPstINFRelimitedLine.cpp</strong>, <em>CAAIPstINFRelimitedLine</em> 
		implementation.</li>
	<li><strong>CAAEPstINFAliasRelimitedLine.cpp</strong>, <em>CATIAlias</em> implementation.</li>
	<li><strong>CAAEPstINFRelimitedLineBehavior.cpp</strong>, <em>CATIFmFeatureBehaviorCustomization</em> 
		implementation.</li>
</ul>
<p><strong>Visualization</strong>:</p>
<ul>
	<li><strong>CAAEPstINFModelEventsRelimitedLine.cpp</strong>, <em>CATIModelEvents</em> 
		implementation.</li>
	<li><strong>CAAEPstINFVisuRelimitedLine.cpp</strong>, <em>CATI3DGeoVisu</em> 
		implementation.</li>
	<li><strong>CAAEPstINFSelectShowRelimitedLine.cpp</strong>, <em>CATISelectShow</em> 
		implementation.</li>
	<li><strong>CAAEPstINFVisPropertiesRelimitedLine.cpp</strong>, <em>CATIVisProperties</em> 
		implementation.</li>
	<li><strong>CAAEPstINFNavigateRelimitedLine.cpp</strong>, a <em>CATINavigateObject</em> 
		implementation.</li>
</ul>
<p>All existing in the <strong>CAAPstINFLineExtension.m</strong> model, while</p>
<p><strong>Interactive Command</strong>:</p>
<ul>
	<li><strong>CAAEPstINFEditRelimitedLine.cpp</strong>, the <em>CATIEdit</em> 
		implementation.</li>
	<li><strong>CAAEPstINFCSORelimitedLine.cpp</strong>, <em>CATICSOFilter</em> 
		implementation.</li>
</ul>
<p>Which exist in the <strong>CAAPstINFLineExtensionCmd.m</strong> module.</p>
<p>These modules exists at the location:</p>
<p><code>InstallRootFolder\CAADoc\CAAProductStructureExtend.edu\</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">3</a>] is the folder 
where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>The CAAPstINFFeatExtBehaviors UC fundamentally is all about implementing various 
Interfaces, each responsible for associating a specific behavior with our feature 
extension (RelimitedLine). Hence, we split the UC in steps dedicated to each Interface, 
as listed below, categorized exactly as we did above:</p>
<ul>
	<li><a href="#Step1">General purpose</a></li>
</ul>
<p><strong>Model</strong>:</p>
<ul>
	<li><a href="#Step2">Implementing CAAIPstINFRelimitedLine</a></li>
	<li><a href="#Step3">Implementing CATIAlias</a></li>
	<li><a href="#Step4">Implementing CATIFmFeatureBehaviorCustomization</a></li>
</ul>
<p><strong>Visualization</strong>:</p>
<ul>
	<li><a href="#Step5">Implementing CATIModelEvents</a></li>
	<li><a href="#Step6">Implementing CATI3DGeoVisu</a></li>
	<li><a href="#Step7">Implementing CATIVisProperties</a></li>
	<li><a href="#Step8">Implementing CATISelectShow</a></li>
	<li><a href="#Step9">Implementing CATINavigateObject</a></li>
</ul>
<p><strong>Interactive Commands</strong>:</p>
<ul>
	<li><a href="#Step10">Implementing CATIEdit</a></li>
	<li><a href="#Step11">Implementing CATICSOFilter</a></li>
</ul>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>General Purpose</h3>
<p>There is an Interface responsible for associating spefic behaviors with our feature 
extension. This is realized by simply implementing these Interfaces on our feature 
extension.</p>
<p>Each Interface implementation has an entry as listed below in the <strong>CAAProductStructureExtend.edu.dico</strong> 
file, which exists in the <strong>CNext/code/dictionary</strong> folder under the
<strong>CAAProductStructureExtend.edu</strong> framework.</p>
<pre class="code"><strong>CAAPstINFRelimitedLine  MyInterface libCAAPstINFLineExtension</strong> 
<strong>CAAPstINFRelimitedLine  MyInterface libCAAPstINFLineExtensionCmd</strong> 
</pre>
<p>The entries in the dico file are in the format &quot;<strong>Component Interface &quot;lib&quot;+Library</strong>&quot;.</p>
<p>It is important to note that all the Interace implementations for our RelimitedLine 
are done in the <strong>CAAPstINFLineExtension</strong> library except <em>CATIEdit</em>, 
which occurs in the <strong>CAAPstINFLineExtensionCmd</strong> library, since it 
is primarily associated with the Interactive V6 session.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Implementing CAAIPstINFRelimitedLine</h3>
<p>The <em>CAAIPstINFRelimitedLine</em> Interface declaration follows. You'll notice 
that it fundamentally exposes the services to retrieve and set our RelimitedLine 
attribute values. In other words, this Interface is primarily responsible for introspecting 
our RelimitedLine feature extension.</p>
<pre class="code"><strong>class</strong> ExportedByCAAPstINFLineExtension <strong>CAAIPstINFRelimitedLine</strong>: public CATBaseUnknown
{
  CATDeclareInterface;

  public:

     // The first parameter on the line
     virtual HRESULT <strong>SetParam1</strong>(const float iParamValue)=0;

     //  The second parameter on the line
     virtual HRESULT <strong>SetParam2</strong>(const float iParamValue)=0;

     // The first parameter on the line
     virtual HRESULT <strong>GetParam1</strong>(float &amp; ioParamValue)=0;

     //  The second parameter on the line
     virtual HRESULT <strong>GetParam2</strong>(float &amp; ioParamValue)=0;

     // The first parameter on the line
     virtual HRESULT <strong>GetParameter1</strong>(CATICkeParm *&amp; opParam)=0;

     //  The second parameter on the line
     virtual HRESULT <strong>GetParameter2</strong>(CATICkeParm *&amp; opParam)=0;

     // Retrieving the 2 end points of the base feat, which indirectly define the relimited line
     virtual HRESULT <strong>GetDefiningPtsFromBaseFeat</strong>(CAAIPstINFPoint *&amp; opiPstINFOnStartPt, CAAIPstINFPoint *&amp; opiPstINFOnEndPt)=0;
     
     // Retrieving the base feature
     virtual HRESULT <strong>GetExtendedLine</strong>(CAAIPstINFLine *&amp; opiPstINFOnLine)=0;
};</pre>
<p>The RelimitedLine is characterized by two attributes namely. <strong>Param1</strong> 
and <strong>Param2</strong>, of type <strong>component</strong>, which aggregate 
Knowledge Parameters, as features. These Knowledge Parameters are of type
<strong>float</strong> in the current case.</p>
<p>The <code>SetParam1</code> [<a href="#Step21">SetParam1 Implementation</a>] and
<code>SetParam2</code> [<a href="#Step22">SetParam2 Implementation</a>] routines 
are responsible for setting these two attributes, with the float value input. These 
internally invoke the <code>SetParam</code>() [<a href="#Step23">SetParam Implementation</a>] 
routine, which is a generic routine and local to our implementation.</p>
<p>The <code>GetParam1</code>() [<a href="#Step24">GetParam1 Implementation</a>] 
and <code>GetParam2</code>() [<a href="#Step25">GetParam2 Implementation</a>] routines 
are responsible for retrieving these attribute values, as type <strong>float</strong>. 
These internally invoke the <code>GetParam</code>() [<a href="#Step26">GetParam 
Implementation</a>] routine, a generic routine local to our implementation.</p>
<p>Alternatively one could also retrieve those as features, or more precisely as 
Knowledge Parameters, of type <em>CATICkeParm</em> with the calls to <code>GetParamer1</code>() 
[<a href="#Step27">GetParameter1 Implementation</a>] and <code>GetParameter2</code>() 
[<a href="#Step28">GetParameter2 Implementation</a>]. These internally invoke the
<code>GetParameter</code>() [<a href="#Step29">GetParameter Implementation</a>] 
routine, a generic routine local to our implementation.</p>
<p>The base feature, Line extended by our RelimitedLine, is retrieved by the
<code>GetExtendedLine</code>() routine. [<a href="#Step2A">GetExtendedLine Implementation</a>]</p>
<p>The defining points of the RelimitedLine, which are the <strong>Start</strong> 
and <strong>End</strong> points of the base feature, the Line that is extended by 
our RelimitedLine, is retrieved with the call to <code>GetDefiningPtsFromBaseFeat</code>() 
routine. [<a href="#Step2B">GetDefiningPtsFromBaseFeat Implementation</a>]</p>
<p>We detail each of those implementations below and also the routines they internally 
invoke (local to our implementations)</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step21"></a>SetParam1 Implementation</h4>
<p>The SetParam1() routine sets the attribute &quot;<strong>Param1</strong>&quot;, 
of the RelimitedLine with the float value input. Since this attribute is of 
type component, the valuation effectively involves aggregation of a Knowledge Parameter, 
equivalent to the float value input.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::SetParam1</strong>(const <strong>float</strong> <strong>iParamValue</strong>)
{
   if ( iParamValue &gt;= 0.0f &amp;&amp; iParamValue &lt; 0.5f )
      rc = <strong>SetParam</strong>("<strong>Param1</strong>",<strong>iParamValue</strong>,0.0f,3,0.5f,4);

   return rc ;
}</pre>
<p>This simply involves an underlying call to <code>SetParam</code>() routine, local 
to our <em>CAAEPstINFRelimitedLine</em> implementation. Its inputs are:</p>
<ul>
	<li>Param1, a string type, which is received as a <em>CATUnicodeString</em> 
		type in the invoked routine.</li>
	<li><code>iParamValue</code>, a float type. The value to be set to the attribute.</li>
	<li>0.0f, is the lower limit of the attribute value.</li>
	<li>3, is the lower bound signifying defined, can be reached and modifiable 
		by the final user.</li>
	<li>0.5f, is the upper limit.</li>
	<li>4, is the upper bound, signifying defined, cannot be reached and unmodifiable 
		by the final user.</li>
</ul>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step22"></a>SetParam2 Implementation</h4>
<p>On similar lines, as the <code>SetParam1</code>() routine, the <code>SetParam2</code>() 
routine sets the attribute &quot;<strong>Param2</strong>&quot;, of the RelimitedLine 
with the float value input. Since this attribute is of type component, the 
valuation effectively involves aggregation of a Knowledge Parameter, equivalent 
to the float value input.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::SetParam2</strong>(const <strong>float</strong> <strong>iParamValue</strong>)
{
    if ( iParamValue &gt;= 0.5f &amp;&amp; iParamValue &lt;= 1.0f )
 	rc= <strong>SetParam</strong>("<strong>Param2</strong>",<strong>iParamValue</strong>,0.5f,3,1.0f,3);
    return rc ;
}</pre>
<p>A significant point to note is that the lower and upper limits and bound specifications 
at both ends, are different this time.</p>
<p>The <code>SetParam</code>() routine internally invoked by both the above 
routines, local to our implementation, is described ahead.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step23"></a>SetParam Implementation</h4>
<p>The <code>SetParam()</code> implementation, local to our <em>CAAEPstINFRelimitedLine</em> 
implementation (<strong>NOT DECLARED by the</strong> <em>CAAIPstINFRelimitedLine</em> 
Interface, implemented by our RelimitedLine) is a generic routine to set 
the Knowledge Parameter to our RelimitedLine attribute.</p>
<p>A significant point to note here is that since the attribute value being assigned 
is a <strong>Knowledge Parameter</strong>, which is distinctly different from other 
attribute values, the steps involved to set it, does not involve simply a call to 
the <code>SetValue</code>() of the <em>CATFmFeatureFacade</em> class, as it the 
general case. You'll notice in the <code>SetParam</code>() implementation that follows 
that setting the attribute value is not simply a call to <code>SetValue</code>(), 
but infact involves initially a call to <code>GetValue</code>(). Further details 
are provided in the explanation that follows the implementation below.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::SetParam(const CATUnicodeString iParamName</strong>,<strong> const float iParamValue</strong>, const float iLimit_low, 
				  const int iBound_low, const float iLimit_high, const int iBound_high)
{
	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsExtension(MyCredential)</strong>;
	...
	<strong>CATFmFeatureFacade FmFeatFacadeOnRelimitedLine</strong>(*MyCredential,this);

	// Use Key to access the attribute of the feature
	CATFmAttributeName FtrNameAttrKey(iParamName);
	CATFmAttributeValue FtrNameAttrValue;
	
	rc = <strong>FmFeatFacadeOnRelimitedLine.GetValue</strong>(FtrNameAttrKey,<strong>FtrNameAttrValue</strong>);
</pre>
<p>The first step is to retrieve the <strong>Credentials</strong> object which authorizes 
access to the feature extension (<strong>RelimitedLine</strong>) catalog. This is 
realized by calling the <code>CAAPstINFRetrieveCredentialsExtension</code>() global 
routine, detailed in the article &quot;<strong>Defining Feature Extension</strong>&quot;[<a href="#References">5</a>].</p>
<p>We next create a feature facade, a <em>CATFmFeatureFacade</em> type on 
the RelimitedLine, associated with the <strong>Credentials</strong>, retrieved above.
</p>
<p>We next retrieve the attribute value for the feature, with the <code>GetValue</code>() 
call of the <em>CATFmFeatureFacade</em> class.&nbsp;The attribute value is retrieved 
as a <em>CATFmAttributeValue</em> type, <code>FtrNameAttrValue</code>.</p>
<p>We proceed to retrieve the Knowledge Parameter from the Attribute Value. There 
are <strong>two</strong> <strong>possibilities</strong>. Either the attribute is 
valuated and a Knowledge Parameter is retrieved, in the discussing that immediately 
follows. Or the attribute is not yet valuated, dealt with after the following case.</p>
<pre class="code">// Retrieve the parameter of the current attribute as a knowledge parameter
<strong>CATICkeParm_var spCkeParmOnLinkedFeat = FtrNameAttrValue.GetFeature()</strong>;
if (spCkeParmOnLinkedFeat != NULL_var)
{
	// Valuate the Parameter
	<strong>spCkeParmOnLinkedFeat-&gt;Valuate(iParamValue)</strong>;
}
</pre>
<p>For the scenario where the attribute is valuated, the <code>GetFeature</code>() 
call of the <em>CATFmAttributeValue</em> class retrieves the aggregated Knowledge 
Parameter as a <em>CATICkeParm_var</em> type (<code>spCkeParmOnLinkedFeat</code>).
</p>
<p>The <code>Valuate</code>() call of the <em>CATICkeParm</em> class valuates this 
knowledge parameter, with <code>iParamValue</code>, the float type input to the 
routine.</p>
<p>We next proceed to the <strong>second</strong> <strong>case</strong>, if the 
attribute is not valuated, as yet. In that case, the Knowledge Parameter is created 
and subsequently valuated to our feature attribute.</p>
<pre class="code">else  // the parameter has never been created. So create it
{
	// create and aggregate 
<strong>	</strong>CATCkeGlobalFunctions::InitializeLiteralsEnvironment();

	CATFmContainerFacade ContainerFacade ;
	<strong>FmFeatFacadeOnRelimitedLine.GetContainerFacade</strong>(ContainerFacade);
	
	<strong>CATICkeParmFactory_var spContainerAsParmFact = ContainerFacade.GetContainer()</strong>;
	if ( NULL_var != spContainerAsParmFact )
	{
	      spContainerAsParmFact -&gt; InitStartUps();
	      <strong>CATICkeParm_var CreatedParm = spContainerAsParmFact-&gt;CreateReal(iParamName,iParamValue)</strong>;
								
	      //-----SetRange of CATICkeParam using maniplator 
	      CATIParmManipulator_var spPersitentManipulator = CreatedParm-&gt;CreateManipulator();
	      CreatedParm-&gt;SetManipulator(spPersitentManipulator);
	      spPersitentManipulator -&gt; SetAccurateRange(iLimit_low,iBound_low,iLimit_high,iBound_high);
	
	      // valuation of the attribute with the new parameter 
	      <strong>FtrNameAttrValue.SetFeature(CreatedParm)</strong>;

	      rc = <strong>FmFeatFacadeOnRelimitedLine.SetValue(FtrNameAttrKey,FtrNameAttrValue)</strong>;
	      ...
</pre>
<p>It is significant to note that an Applicative Container also serves as a Parameter 
Factory. This factory is responsible for creating a Knowledge Parameter of type 
Real, which is subsequently assigned to our feature attribute.</p>
<p>Since we are working with Knowledge, an essential prerequisite is a call to
<code>InitializeLiteralsEnvironment</code>(), which as the name suggests, initializes 
the Knowledge environment.</p>
<p>The <code>GetContainerFacade</code>() call of the <em>CATFmFeatureFacade</em> 
class, invoked on our RelimitedLine, retrieves its Container, as a <em>CATFmContainerFacade</em> 
type (<code>ContainerFacade</code>).</p>
<p>The Container underlying the Container Facade is retrieved as a <em>CATICkeParmFactory_var</em> 
type (<code>spContainerAsParmFact</code>) with a call to <code>GetContainer</code>() 
of the <em>CATFmContainerFacade</em> class.</p>
<p>The <code>CreateReal</code>() call of the <em>CATICkeParmFactory</em> Interface 
creates the Knowledge Parameter of type Real, in the current case. This is retrieved 
as a <em>CATICkeParm_var</em> type (<code>CreatedParm</code>).</p>
<p>The <code>CreateManipulator</code>() call of the <em>CATICkeParm</em> class, 
returns the Manipulator as a <em>CATIParmManipulator_var</em> type. The <code>SetAccurateRange</code>() 
call of the <em>CATICkeParmManipulator</em> sets the range (lower, upper) of values 
that could be assigned to our Knowledge Parameter.</p>
<p>The <code>SetFeature</code>() call of the <em>CATFmAttributeValue</em> class, 
updates it with the Knowledge Parameter, created above, viewed as a feature.</p>
<p>Finally there is a call to <code>SetValue</code>() of the <em>CATFmFeatureFacade</em> 
class which sets this Attribute Value to the RelimitedLine attribute.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step24"></a>GetParam1 Implementation</h4>
<p>The <code>GetParam1</code>() routine retrieves our RelimitedLine attribute &quot;<strong>Param1</strong>&quot;, 
as a float type.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetParam1</strong>(<strong>float</strong> &amp; <strong>ioParamValue</strong>)
{
    HRESULT rc = E_FAIL ;
    rc= <strong>GetParam("Param1",ioParamValue)</strong>;
    return rc ;
}</pre>
<p>The implementation simply involves a call to a more generic <code>GetParam</code> 
routine, local to our implementation. The inputs to this routine are:</p>
<ul>
	<li>&quot;<strong>Param1</strong>&quot;, a string type, which is received as 
		a <em>CATUnicodeString</em> type, in the invoked routine.</li>
	<li><code>ioParamValue</code>, a float type. The attribute value is retrieved 
		in this variable.</li>
</ul>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step25"></a>GetParam2 Implementation</h4>
<p>On similar lines as <code>GetParam1</code>(), the <code>GetParam2</code>() routine 
retrieves our RelimitedLine attribute &quot;<strong>Param2</strong>&quot;, as a 
float type.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetParam2</strong>(<strong>float</strong> &amp; <strong>ioParamValue</strong>)
{
    HRESULT rc = E_FAIL ;
    rc= <strong>GetParam("Param2",ioParamValue)</strong>;
    return rc ;
}</pre>
<p>The implementation is the same as the previous, except that we retrieve the attribute 
value of &quot;<strong>Param2</strong>&quot;, this time.</p>
<p>The <code>GetParam()</code> method invoked in both the above routines, is detailed 
in the section that follows.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step26"></a>GetParam Implementation</h4>
<p>The <code>GetParam</code>() routine, local to our <em>CAAEPstINFRelimitedLine</em> 
implementation, is a generic routine which retrieves an attribute value for our 
RelimitedLine as a float type. Its implementation follows and its further detailed.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetParam</strong>(const CATUnicodeString iParamName, float &amp; ioParamValue)
{
	...
	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsExtension(MyCredential)</strong>;

<strong>	CATFmFeatureFacade FmFeatFacadeOnRelimitedLine</strong>(*MyCredential,this);

	// Use Key to access the attribute of the feature
	CATFmAttributeName FtrNameAttrKey(iParamName);

	// Is the parameter already created and aggregated by the extension?
   	CATFmAttributeValue FtrNameAttrValue;
	rc = <strong>FmFeatFacadeOnRelimitedLine.GetValue</strong>(FtrNameAttrKey,FtrNameAttrValue);
</pre>
<p>The first step is to retrieve the <strong>Credentials</strong> object which authorizes 
access to the feature extension (RelimitedLine) catalog. This is realized by calling 
the <code>CAAPstINFRetrieveCredentialsExtension</code>() global routine, detailed 
in the article &quot;<strong>Defining Feature Extension</strong>&quot;[<a href="#References"><span class="style1">5</span></a>].</p>
<p>We next create a feature facade, a <em>CATFmFeatureFacade</em> type on 
the RelimitedLine, associated with the <strong>Credentials</strong>, retrieved above.</p>
<p>We next retrieve the attribute value for the feature, with the <code>GetValue</code>() 
call of the <em>CATFmFeatureFacade</em> class.&nbsp;The attribute value is retrieved 
as a <em>CATFmAttributeValue</em> type, <code>FtrNameAttrValue</code>.</p>
<p>Since the RelimitedLine attribute aggregates a Knowledge Parameter, as a feature, 
we proceed to retrieve it from the AttributeValue, returned by the previous step. 
There could be two possible cases. One if the Knowledge Parameter is set and Two 
if it is not set, as yet.</p>
<p>We begin with the first case, where the Knowledge Parameter is assigned to the
<strong>RelimitedLine</strong> attribute.</p>
<pre class="code"><strong>CATICkeParm_var spCkeParmOnLinkedFeat = FtrNameAttrValue.GetFeature()</strong>;
<strong>if (spCkeParmOnLinkedFeat != NULL_var)</strong>
{
	// Retrieve the parameter value
<strong>	CATICkeInst_var Value = spCkeParmOnLinkedFeat-&gt;Value()</strong>;
	<strong>ioParamValue= Value-&gt;AsReal()</strong>;
}</pre>
<p>The <code>GetFeature</code>() call of the <em>CATFmAttributeValue</em> class 
retrieves the associated feature, a Knowledge Parameter, as a <em>CATICkeParm_var</em> 
type (<code>spCkeParmOnLinkedFeat</code>).</p>
<p>Further the call to <code>Value</code>() of the <em>CATICkeParm</em> class, retrieves 
the value as a <em>CATICkeInst_var</em> type, whose <code>AsReal</code>() call retrieves 
the value as a <strong>Real</strong> type (<code>ioParamValue</code>).</p>
<p>The other case is if the attribute value is not set, as yet. In this case, the 
attribute is assigned a default value which is eventually returned.</p>
<pre class="code">else
{
	 // if no parameter ,we create the default value
	 <strong>if (0 == strcmp(iParamName.ConvertToChar(),"Param1") )</strong>
	 {
		  rc = <strong>SetParam1(0.0f)</strong>;
         		  if ( SUCCEEDED(rc) ) <strong>ioParamValue = 0.0f</strong> ;

	 } else 
	 {
		  rc = <strong>SetParam2(1.0f)</strong>;
		  if ( SUCCEEDED(rc) ) <strong>ioParamValue = 1.0f</strong>;
	 }
}</pre>
<p>If the Knowledge Parameter is not yet valuated, we set with a default value and 
return the value set. The call to <code>SetParam1</code>() and <code>SetParam2</code>() 
sets the values, based on if the attribute to be set is &quot;<strong>Param1</strong>&quot; 
or &quot;<strong>Param2</strong>&quot;.</p>
<p>The attribute values above were retrieved as a float type. They could also be 
retrieved as features, more precisely <strong>Knowledge</strong> <strong>Parameters</strong> 
of <em>CATICkeParm</em> type. This is realized by the <code>GetParameter1</code>() 
and <code>GetParameter2</code>() routines, whose implementation is detailed in the 
following sections.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step27"></a>GetParameter1 Implementation</h4>
<p>The <code>GetParameter1</code>() routine simply retrieves the &quot;<strong>Param1</strong>&quot; 
attribute value of our RelimitedLine. It is retrieved as a <em>CATICkeParm</em> 
type.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetParameter1</strong>(<strong>CATICkeParm</strong> *&amp; <strong>opParam</strong>)
{
    HRESULT rc = E_FAIL ;
    rc= <strong>GetParameter</strong>("<strong>Param1</strong>",<strong>opParam</strong>);
    return rc ;
}</pre>
<p>The implementation simply involves a call to the more generic routine, <code>GetParameter</code>(),
local to our implementation, and the arguments passed are:</p>
<ul>
	<li>&quot;<strong>Param1</strong>&quot;, a string type which is received as a <em>CATUnicodeString</em> type, in the invoked routine.</li>
	<li><code>opParam</code>, a <em>CATICkeParm</em>* &amp; type, which contains 
		the knowledge Parameter retrieved.</li>
</ul>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step28"></a>GetParameter2 Implementation</h4>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetParameter2</strong>(<strong>CATICkeParm</strong> *&amp; <strong>opParam</strong>)
{
    HRESULT rc = E_FAIL ;
    rc= <strong>GetParameter</strong>("<strong>Param2</strong>",<strong>opParam</strong>);
    return rc ;
}</pre>
<p>On similar lines as <code>GetParameter1</code>(), the <code>GetParameter2</code>() 
routine retrieves the &quot;<strong>Param2</strong>&quot; attribute of our RelimitedLine. 
It also fundamentally invokes the <code>GetParameter</code>() routine which is described 
in the section that follows.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step29"></a>GetParameter Implementation</h4>
<p>The <code>GetParameter</code>() routine, is a more generic routine, local to 
our <em>CAAEPstINFRelimitedLine</em> implementation, which retrieves the Knowledge 
Parameters aggregated our RelimitedLine feature extension (realized by valuating 
the &quot;<strong>Param1</strong>&quot; and &quot;<strong>Param2</strong>&quot; 
attributes, which are of type <strong>component</strong>).</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetParameter</strong>(const CATUnicodeString iParamName, <strong>CATICkeParm</strong> *&amp; <strong>opParam</strong>)
{
    HRESULT rc = E_FAIL ;
	 
	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsExtension(MyCredential)</strong>;
	if ( FAILED(rc) ) return rc ;

	<strong>CATFmFeatureFacade FmFeatFacadeOnRelimitedLine(*MyCredential,this)</strong>;

	// Use Key to access the attribute of the feature
	CATFmAttributeName FtrNameAttrKey(iParamName);

    CATFmAttributeValue FtrNameAttrValue;
	rc = <strong>FmFeatFacadeOnRelimitedLine.GetValue</strong>(FtrNameAttrKey,<strong>FtrNameAttrValue</strong>);
	if (SUCCEEDED(rc))
	{
<strong>	   CATBaseUnknown_var spCBUOnLinkedFeat = FtrNameAttrValue.GetFeature()</strong>;
	   if ( NULL_var != spCBUOnLinkedFeat )
	   {
	      rc = <strong>spCBUOnLinkedFeat-&gt;QueryInterface</strong>(<strong>IID_CATICkeParm</strong>,(void**)&amp;<strong>opParam</strong>);
	   }else rc = E_FAIL ;
	 }

	return rc;
}</pre>
<p>The first step is to retrieve the <strong>Credentials</strong> object which authorizes 
access to the feature extension (RelimitedLine) catalog. This is realized by calling 
the <code>CAAPstINFRetrieveCredentialsExtension</code>() global routine, detailed 
in the article &quot;<strong>Defining Feature Extension</strong>&quot;[<a href="#References"><span class="style1">5</span></a>].</p>
<p>We next create a feature facade, a <em>CATFmFeatureFacade</em> type on 
the RelimitedLine, associated with the <strong>Credentials</strong>, retrieved above.</p>
<p>We next retrieve the attribute value for the feature, with the <code>GetValue</code>() 
call of the <em>CATFmFeatureFacade</em> class. The attribute value is retrieved 
as a <em>CATFmAttributeValue</em> type, <code>FtrNameAttrValue</code>.</p>
<p>Since the RelimitedLine attribute aggregates a Knowledge Parameter, as a feature, 
we proceed to retrieve it from the AttributeValue. This is realized with the call 
to GetFeature() of the <em>CATFmAttributeValue</em> class. The Knowledge Parameter 
is finally retrieved as a <em>CATICkeParm</em> type (<code>opParam</code>).</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step2A"></a>GetExtendedLine Implementation</h4>
<p>This routine enables us retrieve the base feature (<strong>Line</strong>), extended 
by our RelimitedLine.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetExtendedLine</strong>(<strong>CAAIPstINFLine</strong> * &amp; opiPstINFOnBaseFeature )
{	
	HRESULT rc = E_FAIL;
	opiPstINFOnBaseFeature   = NULL ;

	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsExtension(MyCredential)</strong>;
	if ( FAILED(rc) ) return rc ;

	<strong>CATFmFeatureFacade FeatFacadeOnThis(*MyCredential,this)</strong>;

	CATFmAttributeValue oAttrValueOnBaseFeat;
	rc = <strong>FeatFacadeOnThis.GetBaseFeature</strong>(oAttrValueOnBaseFeat);

	if ( SUCCEEDED(rc) )
	     rc = <strong>oAttrValueOnBaseFeat.QueryInterfaceOnFeature</strong>(<strong>IID_CAAIPstINFLine</strong>, (void**) &amp;opiPstINFOnBaseFeature);
         return rc ; 
}</pre>
<p>The first step is to retrieve the <strong>Credentials</strong> object which authorizes 
access to the feature extension (RelimitedLine) catalog. This is realized by calling 
the <code>CAAPstINFRetrieveCredentialsExtension</code>() global routine, detailed 
in the article &quot;<strong>Defining Feature Extension</strong>&quot;[<a href="#References"><span class="style1">5</span></a>].</p>
<p>We next create a feature facade, a <em>CATFmFeatureFacade</em> type on 
the RelimitedLine, associated with the <strong>Credentials</strong>, retrieved above.</p>
<p>The call to GetBaseFeature() of the <em>CATFmFeatureFacade</em> class retrieves 
the base feature, if invoked on a feature extension. The base feature is retrieved 
valuated to a <em>CATFmAttributeValue</em> type.</p>
<p>The call to <code>QueryInterfaceOnFeature</code>() retrieves the feature associated 
with a <em>CATFmAttributeValue</em> type, in the current casse as a <em>CAAIPstINFLine</em> 
type.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step2B"></a>GetDefiningPtsFromBaseFeat Implementation</h4>
<p>This routine returns the Start and End Points of our base feature (Line) extended 
by our Relimited Line. These points are those fundamentally defining our RelimitedLine, 
which explains the reason why we have named this routine as <code>GetDefiningPointsFromBaseFeat</code>().</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLine::GetDefiningPtsFromBaseFeat</strong>(CAAIPstINFPoint * &amp; opiPstINFOnStartPt, CAAIPstINFPoint * &amp; opiPstINFOnEndPt)
{	
    CATFmCredentials * MyCredential = NULL ;
    rc = ::<strong>CAAPstINFRetrieveCredentialsExtension(MyCredential)</strong>;
    if ( FAILED(rc) ) return rc ;

    <strong>CATFmFeatureFacade FeatFacadeOnThis(*MyCredential,this)</strong>;

    CATFmAttributeValue oAttrValueOnBaseFeat;
    rc = <strong>FeatFacadeOnThis.GetBaseFeature(oAttrValueOnBaseFeat)</strong>;
    if ( SUCCEEDED(rc) )
    {
	<strong>CAAIPstINFLine_var spLineBaseFeat =</strong> <strong>oAttrValueOnBaseFeat.GetFeature()</strong>;  // The line
         if ( NULL_var != spLineBaseFeat )
	{
	   CAAIPstINFPoint * pLocalvalue1 = NULL ;
	   CAAIPstINFPoint * pLocalvalue2 = NULL ;
	   <strong>spLineBaseFeat -&gt; GetPoint(1,pLocalvalue1)</strong>;
	   <strong>spLineBaseFeat -&gt; GetPoint(2,pLocalvalue2)</strong>;
     ...
}</pre>
<p>The first step is to retrieve the <strong>Credentials</strong> object which authorizes 
access to the feature extension (RelimitedLine) catalog. This is realized by calling 
the <code>CAAPstINFRetrieveCredentialsExtension</code>() global routine, detailed 
in the article &quot;<strong>Defining Feature Extension</strong>&quot;[<a href="#References"><span class="style1">5</span></a>].</p>
<p>We next create a feature facade, a <em>CATFmFeatureFacade</em> type on 
the RelimitedLine, associated with the <strong>Credentials</strong>, retrieved above.</p>
<p>The call to <code>GetBaseFeature</code>() of the <em>CATFmFeatureFacade</em> 
class retrieves the base feature, if invoked on a feature extension. The base feature 
is retrieved valuated to a <em>CATFmAttributeValue</em> type.</p>
<p>The call to <code>GetFeature</code>() of the <em>CATFmAttributeValue</em> class, 
retrieves the feature associated with the <em>CATFmAttributeValue</em> type. The 
feature is retrieved as a <em>CAAIPstINFLine_var</em> type (spLineBaseFeat)</p>
<p>The call to <code>GetPoint</code>() of the <em>CAAIPstINFLine</em> Interface, 
on the Line feature, retrieves its Start and End Points.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Implementing CATIAlias</h3>
<p>The <em>CATIAlias</em> Interface is responsible for setting and retrieving an 
external name for an object. [<a href="#References">6</a>]</p>
<p>We do not allow the user to set an external name for our RelimitedLine. That 
explains the &quot;do nothing&quot; implementation for <code>SetAlias</code>() that 
follows.</p>
<pre class="code">void   <strong>CAAEPstINFAliasRelimitedLine::SetAlias (const CATUnicodeString&amp;  iName )</strong> 
{
<strong>	HRESULT rc = E_NOTIMPL</strong>;
}</pre>
<p>The <code>GetAlias</code>() implementation on our feature extension retrieves 
its external name (alias), as the code that follows depicts.</p>
<pre class="code"><strong>CATUnicodeString</strong>  <strong>CAAEPstINFAliasRelimitedLine::GetAlias</strong> () 
{
	HRESULT rc = E_FAIL;
    	CATUnicodeString ReturnedName ="";
	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsExtension(MyCredential)</strong>;
	if ( SUCCEEDED(rc) )
	{
       		CATFmFeatureFacade FmFeatFacadeOnRelimitedLine (*MyCredential, this);
	   	rc = <strong>FmFeatFacadeOnRelimitedLine.GetDisplayName(ReturnedName)</strong>;
	}

	return ReturnedName;
}</pre>
<p>The first step is to retrieve the <strong>Credentials</strong> object which authorizes 
access to the feature extension (RelimitedLine) catalog. This is realized by calling 
the <code>CAAPstINFRetrieveCredentialsExtension</code>() global routine, detailed 
in the article &quot;<strong>Defining Feature Extension</strong>&quot;[<a href="#References"><span class="style1">5</span></a>].</p>
<p>We next create a feature facade, a <em>CATFmFeatureFacade</em> type on 
the RelimitedLine, associated with the <strong>Credentials</strong>, retrieved above.
</p>
<p>The <code>GetDisplayName</code>() call of the <em>CATFmFeatureFacade</em> class, 
retrieves the display name of the feature. It is returned as a <em>CATUnicodeString</em> 
type.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>Implementing CATIFmFeatureBehaviorCustomization</h3>
<p>This Interface is dedicated to implement user-defined behavior, which primarily 
involves:</p>
<ul>
	<li><strong>Delete Protocol Customization</strong> (the <code>CanBeRemoved</code>() 
		and <code>BeforeRemove</code>() methods).</li>
	<li><strong>Cut, Copy, Paste Customization</strong>.</li>
	<li><strong>Update</strong> (the <code>Build</code> method).</li>
</ul>
<p>The implementation details follow. Our implementation class is derived from the 
Adapter Class <em>CATFmFeatureCustomizationAdaptor</em>.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4>CATIFmFeatureBehaviorCustomization::Build Implementation</h4>
<p>This method is invoked by the Update enging on feature update i.e. on modification 
of its sp_in attributes.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLineBehavior::Build</strong>()
{
    CATIModelEvents * pModelEvents = NULL;                
    HRESULT rc = <strong>QueryInterface(IID_CATIModelEvents</strong>,  (void**)&amp;pModelEvents);
		                 
    if (SUCCEEDED(rc))
    {
       CATModify Notif (pModelEvents); 
       <strong>pModelEvents-&gt;Dispatch(Notif)</strong>;
       ...
    return rc;
</pre>
<p>The implementation involves QI for a <em>CATIModelEvents</em> type (<code>pModelEvents</code>) 
on our RelimitedLine.&nbsp;The RelimitedLine next sends a Visualization event by 
invoking <code>Dispatch</code>(), a method of the <em>CATIModelEvents</em> Interface 
it implements. This finally updates the 3D Visualization of our RelimitedLine, thus 
synchronizing it with the Model, which was updated.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4>CATIFmFeatureBehaviorCustomization::CanBeRemoved()&nbsp;Implementation</h4>
<p>This method sets the &quot;<strong>deletability</strong>&quot; status of a feature. 
Services and algorithms invoke this method to check if the removal of an applicative 
feature is legitimate. The default implementation allows the deletion of all features 
which are not aggregated, while prohibits the deletion of an aggregated feature. 
One can override this implementation to customize the delete call.</p>
<p>It is significant to note that not all services/algorithms invoke this method. 
For eg. the <code>DeleteSelf</code>() call of the <em>CATFmFeatureFacade</em> class 
never invokes this method. It is typically invoked by the <code>Delete</code>() 
call of the <em>DataCommonProtocolServices</em> class, the customized delete() service 
exposed by the feature owner.</p>
<pre class="code">HRESULT <strong>CAAEPstINFRelimitedLineBehavior::CanBeRemoved</strong>(CATBoolean &amp; oDeletable) const
{
    <strong>oDeletable = TRUE</strong>; 
    return S_OK;
}</pre>
<p>The impelmentation above sets the <em>CATBoolean</em> type, <code>oDeletable</code> 
to TRUE. This implies that feature extension delete is permitted in our case.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>Implementing CATIModelEvents</h3>
<p>In the <strong>MVC</strong> (<strong>Model View Control</strong>) architecture, 
the Model world and the Visualization world are independent. Every action i.e. a 
geometry modification or model update must trigger a visualization update. This 
communication of the Model world with the Visualization world is realized with the
<em>CATIModelEvents</em> implementation. It connects the objects which communicate 
with one another by sending and receiving the visualization events.</p>
<p>We do not provide an explicit implementation to <em>CATIModelEvents</em> but 
rely on the default implementation provided by <em>CATExtIModelEvents</em> adapter 
class, which serves as a base class for our implementation class which derives from 
it, as depicted below.</p>
<pre class="code">class <strong>CAAEPstINFModelEventsRelimitedLine</strong>: public <strong>CATExtIModelEvents</strong>
</pre>
<p>The most significant methods of the <em>CATIModelEvents</em> are the <code>ConnectTo</code>() 
and <code>Dispatch</code>(). It would be worthwhile discussing their relevance in 
the Visualization Update of the RelimitedLine. The method below is one of those 
called in the State Command which interactively creates the RelimitedLine. It is 
interesting to note how after creating our RelimitedLine in the Model world, we 
proceed to update its Visualization in 3D.</p>
<pre class="code">CATBoolean <strong>CAAPstCreateLineExtensionCmd::SelectLineToExtend</strong>( void *data )
{
   ...
   HRESULT rc = ::<strong>CAAPstCreateLineExtension</strong>(pSelection,&amp;pIRelimitedLine);
   ...
   CAAIPstINFLine * pBaseFeature = NULL ;
   <strong>pIRelimitedLine-&gt;GetExtendedLine</strong>(pBaseFeature) ;

   // Get the rep instance from the base feature (or pIRelimitedLine) -&gt; they are inside the same Rep Techno
   CATBaseUnknown * pTechnoRepInstance = NULL ;
   ::<strong>CAAPstRetrieveTechnoRep</strong>(pBaseFeature, &amp;pTechnoRepInstance);

   // Visu events connection  
   if ( NULL != pTechnoRepInstance )
   {
      <strong>CATIModelEvents_var spModelEvtOnRepInstance = pTechnoRepInstance</strong> ;
      if ( NULL_var != spModelEvtOnRepInstance )
          <strong>spModelEvtOnRepInstance-&gt;ConnectTo(pIRelimitedLine)</strong> ;

   // Update the visu
   if (  NULL!=pTechnoRepInstance )
   {
     // inform the PLM Techno Rep Instance Visu Rep to be updated due to the creation
<strong>     CATIModelEvents_var spModelEvtOnRelimitedLine = pIRelimitedLine</strong> ;
     ... 
     CATCreate notif(pIRelimitedLine,pTechnoRepInstance);
     <strong>spModelEvtOnRelimitedLine-&gt;Dispatch</strong>(notif);
   ...</pre>
<p>The first step on creation of our feature extension (RelimitedLine) is to connect 
it with its Techno Rep Instance, so that it can send/receive the Visualization events, 
when an Update is required. This connections is realized as follows.</p>
<p>The call to <code>CAAPstCreateLineExtension</code>() global routine, creates 
a RelimitedLine in the Model world.</p>
<p>We next retrieve the base feature (Line), it extends, which in turn enables us 
retrieve the referencing Techno Rep Instance.</p>
<p>Then we retrieve the <em>CATIModelEvents</em> type on the Techno Rep Instance. 
The call to <code>ConnectTo</code>() of the <em>CATIModelEvents</em> implementation 
on a Techno Rep Instance, connects it, to the RelimitedLine.</p>
<p>Next, we seek the <em>CATIModelEvents</em> type on our RelimitedLine. The call 
to <code>Dispatch</code>() of the <em>CATIModelEvents</em> implementation on our 
RelimitedLine then dispatches a visualization event, to its parent, the Techno Rep 
Instance. This invokes the <code>Receive</code>() method on the parent which processes 
it, if defined and then dispatches the event higher up in the visualization hierarchy, 
until the event reaches the last connected object in the hierarchy, the <em>CATVisManager</em> 
which has the ability to process the Visualization event.</p>
<p>In this way, we accomplish a Visualization Update of our RelimitedLine, which 
is created interactively.</p>
<p>On the other hand, if one updates RelimitedLine interactively, all one needs 
to do is to send a Visualization Notification from our RelimitedLine, up the Visualization 
hierarchy. The method that follows is that invoked on a RelimitedLine model update 
interactively.</p>
<pre class="code">void <strong>CAAPstINFEditRelimitedLineDlg::ModifyModelAndVisu</strong>(const CATUnicodeString Name)
{
 ... 
  // Notification to update the display
  if ( NULL != _piRelimitedLineEdit )
  {   
     CATIModelEvents * pModelEvents = NULL;                
     HRESULT rc = <strong>_piRelimitedLineEdit -&gt; QueryInterface</strong>(<strong>IID_CATIModelEvents</strong>, (void**)&amp;pModelEvents);
     if (SUCCEEDED(rc))
     {
       CATModify Notif (pModelEvents);
       <strong>pModelEvents-&gt;Dispatch(Notif)</strong>;
   ...
}
</pre>
<p>We initially seek the <em>CATIModelEvents</em> type on our RelimitedLine. We 
next invoke the <code>Dispatch</code>() method of the <em>CATIModelEvents</em> Interface, 
which dispatches our notification,up the hierarchy.</p>
<p>The rest of the steps are similar to those described earlier, which ultimately 
result in the Visualization update of our RelimitedLine modified in the model world.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step6"></a>Implementing CATI3DGeoVisu</h3>
<p>The <em>CATI3DGeoVisu</em> Interface is responsible for a 3D Representation of 
an object.</p>
<p>The Visualization of our RelimitedLine in 3D is realized by the <em>CATI3DGeoVisu</em> 
implementation. Our implementation class derives from the <em>CATExtIVisu</em> adapter 
class.</p>
<p>We compute the start and end points of the RelimitedLine. The mathematical formulae 
to compute this is simple:</p>
<ul>
	<li>StartPoint = P1 + (P2-P1) * param1.</li>
	<li>EndPoint = P1 + (P2-P1) * param2.</li>
</ul>
<p>where <strong>P1</strong> and <strong>P2</strong> are the <em>CAAPstINFPoint</em> 
features representing the start and end points of the base feature (a <em>CAAPstINFLine</em> 
feature), and <strong>param1</strong> and <strong>param2</strong> the two parameters 
defining the <em>CAAPstINFRelimitedLine</em> . see the picture in the
<a href="CAAPstUcINFExtensionOverview.htm">Overview</a> article.</p>
<p>The only one method is the <code>BuildRep</code> method, whose implementation 
follows.</p>
<pre class="code">CATRep * <strong>CAAEPstINFVisuRelimitedLine::BuildRep</strong>()
{
  HRESULT rc = E_FAIL;

  // Retrieve param1 and param2 of the feature extension
  CAAIPstINFRelimitedLine *piPstINFRelimitedLine = NULL;   
  float param1 = 0.0f, param2 =1.0f;
  rc = <strong>QueryInterface(IID_CAAIPstINFRelimitedLine,</strong>(void**)&amp;piPstINFRelimitedLine);
  if ( SUCCEEDED(rc) )
  {
     <strong>piPstINFRelimitedLine-&gt;GetParam1(param1)</strong>;
     <strong>piPstINFRelimitedLine-&gt;GetParam2(param2)</strong>;
  }</pre>
<p>The <em>CAAIPstINFRelimitedLine</em> type Interface on our RelimitedLine exposes 
the services <code>GetParam1</code>() and <code>GetParam2</code>() which enable 
us retrieve <strong>param1</strong> and <strong>param2</strong>, respectively.</p>
<p>Next we proceed to retrieve the co-ordinates of the start and end points of the 
base feature.</p>
<pre class="code">  ... 
  // Retrieve pt1 &amp; pt2 forming the line  (the base feature) 
  CAAIPstINFPoint* piPstINFOnStartPt = NULL;
  CAAIPstINFPoint* piPstINFOnEndPt   = NULL;

  if (NULL != piPstINFRelimitedLine)
 	rc = <strong>piPstINFRelimitedLine-&gt;GetDefiningPtsFromBaseFeat(</strong>piPstINFOnStartPt,piPstINFOnEndPt);
  
  // Retrieve pt1, pt2 coordinates
  <strong>float coordP1[3]</strong>;
  if ( SUCCEEDED(rc) &amp;&amp; ( NULL !=piPstINFOnStartPt) )
  {
     double dCoord = 0.0f;
     <strong>piPstINFOnStartPt -&gt; GetX (&amp;dCoord)</strong>;
     coordP1[0] = dCoord ;
     <strong>piPstINFOnStartPt -&gt; GetY (&amp;dCoord)</strong>;
     coordP1[1] = dCoord ;
     <strong>piPstINFOnStartPt -&gt; GetZ (&amp;dCoord)</strong>;
     coordP1[2] = dCoord ;
  }

<strong>  float coordP2[3]</strong> ;
  if ( SUCCEEDED(rc) &amp;&amp; ( NULL !=piPstINFOnEndPt) )
  {
     double dCoord = 0.0f;
     <strong>piPstINFOnEndPt -&gt; GetX (&amp;dCoord)</strong>;
     coordP2[0] = dCoord ;
     <strong>piPstINFOnEndPt -&gt; GetY (&amp;dCoord)</strong>;
     coordP2[1] = dCoord ;
     <strong>piPstINFOnEndPt -&gt; GetZ (&amp;dCoord)</strong>;
     coordP2[2] = dCoord ;
  }</pre>
<p>The <code>GetDefiningPtsFromBaseFeat</code>() of the <em>CAAIPstINFRelimitedLine</em> 
Interface returns the Start and End Points of the base feature of our RelimitedLine, 
as a <em>CAAIPstInfPoint</em> types.</p>
<p>The <code>GetX</code>, <code>GetY</code> and <code>GetZ</code> calls of the
<em>CAAIPstInfPoint</em> Interface enables us to retrieve the X, Y and Z co-ordinates 
of the Points. &nbsp;These co-ordinates are stored in an array of doubles.</p>
<pre class="code">  // Compute new points
      // <strong>PNew1 = P1 + param1* (P2P1)</strong>
      float coord[6];
      coord[0] = coordP1[0]+ param1 * (coordP2[0]-coordP1[0]);
      coord[1] = coordP1[1]+ param1 * (coordP2[1]-coordP1[1]);
      coord[2] = coordP1[2]+ param1 * (coordP2[2]-coordP1[2]);

      // <strong>PNew2 = P1 + param2* (P2P1)</strong>
      coord[3] = coordP1[0]+ param2 * (coordP2[0]-coordP1[0]);
      coord[4] = coordP1[1]+ param2 * (coordP2[1]-coordP1[1]);
      coord[5] = coordP1[2]+ param2 * (coordP2[2]-coordP1[2]);

      CATMathPoint start(coord[0],coord[1],coord[2]);
      CATMathPoint end(coord[3],coord[4],coord[5]);

     // Creation of the 3D graphic representation 
     CAT3DCustomRep *pLineRep = NULL ;
     <strong>pLineRep = new CAT3DCustomRep()</strong>;

     // Constructs the graphic primitive dedicated to the line
     <strong>CAT3DLineGP * pLineGp = new CAT3DLineGP(coord,2)</strong>;

     // Default attribut graphique 
     <strong>CATGraphicAttributeSet   LineGa</strong>;
     
     // Association of the Gp and the Ga to the Representation
     <strong>pLineRep-&gt;AddGP(pLineGp,LineGa)</strong>;

     // Computes the Bounding sphere
     CATMathPoint center =  start + ((end-start) / 2.f)  ;
     float radius = (float) start.DistanceTo(center);
<strong>     CAT3DBoundingSphere be(center,radius)</strong>;

     // Sets the bounding sphere
     <strong>pLineRep-&gt;SetBoundingElement(be)</strong>;
  }
  return pLineRep;
}</pre>
<p>The co-ordinates of the end points of the RelimitedLine is then computed, based 
on the mathematical formulae specified in the beginning of this section. The end 
points of the RelimitedLine are then created as <em>CATMathPoint</em> types.
</p>
<p>A <em>CAT3DCustomRep</em> type (<code>pLineGp</code>) is a 3D Graphic Representation 
for our RelimitedLine, represented as a collection of a list of graphic primitives 
and attributes associated with those.</p>
<p>The graphic primitive is a <em>CAT3DLineGP</em> type, dedicated a 3D Line. The 
attributes is represented by a <em>CATGraphicAttributeSet</em> type (LineGa).</p>
<p>The graphic primitives and attributes are set to our RelimitedLine with a call 
to <code>AddGP</code>() of the <em>CAT3DCustomRep</em> class.</p>
<p>The smallest bounding element of our RelimitedLine is then set with a call to
<code>SetBoundingElement</code>(). It takes a <em>CAT3DBoundingSphere</em> type 
as an input. This sphere is created with its centre and radius as input. The centre 
is computed as a <em>CATMathPoint</em> type, a point at the centre of our RelimitedLine, 
computed with the start and end points, as input.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step7"></a>Implementing CATIVisProperties</h3>
<p>This Interface is responsible for managing graphic properties. Your components 
has a set of object like <strong>line</strong>, <strong>surface</strong> which are 
defined by their <em>CATVisGeomType</em>. Each &quot;object&quot; has a set of graphic 
properties. With this Interface you read/write these objects.</p>
<p>This Interface is typically implemented on a data extension of the component 
that implements an Interface derived from <em>CATIVisu</em> such as <em>CATI3DGeoVisu</em> 
or <em>CATI2DGeoVisu</em>. The implementation is derived from an Adapter Class namely.
<em>CATExtIVisProperties</em>. The article &quot;<strong>Graphic Property StartUp 
Behavior</strong>&quot; [<a href="#References"><span class="style1">4</span></a>] 
delves into the depths of this subject.</p>
<p>The two methods of the Interface which are implemented by our RelimitedLine are
<code>IsGeomTypeDefined</code> and <code>GetSubTypeFromPath</code>.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4>CATIVisProperties::IsGeomTypeDefined Implementation</h4>
<p>This routine determines if the Geometry type of our RelimitedLine is among the 
predefined types.</p>
<pre class="code">HRESULT <strong>CAAEPstINFVisPropertiesRelimitedLine</strong>::<strong>IsGeomTypeDefined</strong>( CATVisGeomType &amp; iGeomType )
{
  HRESULT rc = E_FAIL;

   if ( (<strong>CATVPLine</strong> == iGeomType) || (<strong>CATVPGlobalType</strong> == iGeomType) )
        rc =  S_OK ;
  
  return rc;
}
</pre>
<p>The two Geometry types, whose graphic attributes are handled by the application 
are Line (<em>CATVpLine</em> type) and the more generic, Global Type (<em>CATVPGlobalType</em>). 
For both those valid case, the routine returns S_OK.</p>
<p>If the type is <code>CATVPLine</code>, the line attributes like color, 
thickness, type are handled while for type <code>CATVPGlobalType</code>, i.e for 
more generic types, capabilities like pick color, show, layer are handled.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4>CATIVisProperties::GetSubTypeFromPath() Implementation</h4>
<p>This method is automatically called to update the &quot;<strong>Graphic Properties</strong>&quot; 
toolbar. This toolbar contains combos to modify the color, the type of a line, etc. 
of the selected feature(s). The goal of this method is to return the type of geometry,
<code>oGeomType</code>, for the input graphical properties <code>iPropertyType</code>, 
concerned by the toolbar modifications. The returned type of geometry must be of 
course defined by the feature.</p>
<pre class="code">HRESULT <strong>CAAEPstINFVisPropertiesRelimitedLine</strong>::<strong>GetSubTypeFromPath</strong>(CATPathElement     &amp; iPathElement,
                                                                <strong>CATVisPropertyType   iPropertyType</strong>,
                                                                <strong>CATVisGeomType     &amp; oGeomType</strong>,
                                                                unsigned int       &amp; oPropertyNumber )
{
   HRESULT rc = E_FAIL ;

    <strong>switch ( iPropertyType )</strong>
    {
    <strong>case CATVPColor</strong>:
<strong>    case CATVPLineType</strong>:
    <strong>case CATVPWidth</strong>:
        <strong>oGeomType = CATVPLine</strong> ;
        rc = S_OK ;
        break;

    }
    // Set always 0
    oPropertyNumber = 0 ;
    
    return rc ;
}</pre>
<p>A point to note about the input argument to that method:</p>
<ul>
	<li><code>oPropertyNumber</code> is not used by the visualization mechanism, 
		so valuate it by zero.</li>
	<li>do not process the type of property <code>CATVPGlobalType</code>. It is 
		done by the visualization mechanism.</li>
	<li>for the <code>CATVPColor</code>, <code>CATVPLineType</code> and the
		<code>CATVPWidth</code> properties, the type of geometry is <code>CATVPLine</code>.</li>
</ul>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step8"></a>Implementing CATISelectShow</h3>
<p>The Interface manages the hide/show command. It enables show or no-show for the 
last object of the pathelement which implements <em>CATISelectShow</em>. This object 
is the one returned by the <code>GetElementForHideShow</code>().Attention, the
<i>CATISelectShow</i> interface must be implemented, if you want the hide/show functionality.
</p>
<p>This interface is implemented by using the <i>CATExtISelectShow</i> adapter class.</p>
<pre class="code">HRESULT <strong>CATEPstINFSelectShowRelimitedLine</strong>::<strong>GetElementForHideShow</strong>(CATPathElement *iPathElt,CATBaseUnknown *&amp; oSelectedObject, int&amp; oPostProcess)
{
  oPostProcess = 0;
  <strong>oSelectedObject = this</strong>;
  return S_OK;
}</pre>
<p>You'll notice in the implementation above we return this (RelimitedLine), implying 
we do provide support for hide/show for our RelimitedLine. For hide/show the <em>
CATIVisProperties</em> Interface implemenation on our object is accessed.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step9"></a>Implementing CATINavigateObject</h3>
<p>The <em>CATINavigateObject</em> Interface enables visualizing an object in the 
spec tree. It primarily exposes two services</p>
<ul>
	<li><code>GetIdentificators</code>(), to retrieve the text associated with the 
		node. In other words, the string that gets displayed in the spec tree corresponding 
		to your object.</li>
	<li><code>GetChildren</code>(), to retrieve the list of direct children of an 
		object, for display in the spec tree.</li>
</ul>
<p>We begin with describing the <code>GetIdentificators</code>() implementation.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4>CATINavigateObject::GetIdentificators()</h4>
<p>The routine simply returns the text to be displayed for your feature extension, 
for display in the spec tree in a V6 session.</p>
<pre class="code">CATListValCATUnicodeString *<strong>CAAEPstINFNavigateRelimitedLine::GetIdentificators</strong>()
{
  CATListOfCATUnicodeString *pIdent = new CATListOfCATUnicodeString;
<strong>  CATIAlias_var AliasOnThis = this</strong> ;

  if ( NULL_var != AliasOnThis )
  {
     <strong>CATUnicodeString NameRoot = AliasOnThis-&gt;GetAlias()</strong> ;
     pIdent -&gt; Append(NameRoot);
  }

  return pIdent;
}</pre>
<p>We simply retriev a <em>CATIAlias</em> type on our RelimitedLine.</p>
<p>The <code>GetAlias</code>() routine of the <em>CATIAlias</em> Interface returns 
the string that identifies our RelimitedLine. It is retrieved as a <em>CATUnicodeString</em> 
type (NameRoot).</p>
<p>The alias is appended to a list, which is finally returned from the routine.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4>CATINavigateObject::GetChildren()</h4>
<p>The <code>GetChildren</code>() implementation retrieves the list of direct children 
to be displayed under our RelimitedLine. We display the two Knowledge Parameters 
that our RelimitedLine aggregates.</p>
<pre class="code">CATListValCATBaseUnknown_var * <strong>CAAEPstINFNavigateRelimitedLine::GetChildren</strong>()
{
  HRESULT rc = E_FAIL;
  CATListValCATBaseUnknown_var* pList = NULL ;

  CATICkeParm *param1 = NULL ;
  CATICkeParm *param2 = NULL ; 
  CAAIPstINFRelimitedLine *piPstINFRelimitedLine = NULL;   
  rc = <strong>QueryInterface</strong>(<strong>IID_CAAIPstINFRelimitedLine</strong>,(void**)&amp;piPstINFRelimitedLine);
  if ( SUCCEEDED(rc) )
  {
     <strong>piPstINFRelimitedLine-&gt;GetParameter1(param1)</strong>;
     <strong>piPstINFRelimitedLine-&gt;GetParameter2(param2)</strong>;

     if ( (param1!=NULL) &amp;&amp; (param2!=NULL) )
     {
	 pList = new CATListValCATBaseUnknown_var;
         <strong>pList-&gt;Append(param1)</strong>;
	 <strong>pList-&gt;Append(param2)</strong>;
   ...</pre>
<p>The implementation simply involves retrieving the values of attributes &quot;<strong>Param1</strong>&quot; 
and &quot;<strong>Param2</strong>&quot;, as Knowledge Parameters of type <em>CATICkeParm</em>.</p>
<p>The retrieved entities are appended to a list and finally returned from the routine.
</p>
<p>This results in the RelimitedLine being displayed in the spec tree with these 
two Knowledge Parameters displayed as sub nodes under it, which implies an aggregation 
link, as the Fig. that follows depicts.</p>
<table>
	<caption>Fig.1: Parameter Display in Spec Tree</caption>
	<tr>
		<td>
		<img alt="Parameter Display in Spec Tree" height="357" src="images/CAAPstUCInfExtensionBehaviors_Fig1.jpg" width="309"/></td>
	</tr>
</table>
<p>Note: By default the code does not add the parameters under the RelimitedLine 
node in the spec tree. This code is currently commented. Once uncommented and built, 
the parameters will be displayed in the spec tree, as depicted in the fig. above.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step10"></a>Implementing CATIEdit</h3>
<p>Our RelimitedLine feature extension will react to double clicking, only if it 
implements the <em>CATIEdit</em> Interface.&nbsp;Our implementation class derives 
from the <em>CATExtIEdit</em> Adapter class.</p>
<pre class="code"><strong>class CAAEPstINFEditRelimitedLine : public CATExtIEdit</strong></pre>
<p>On &quot;<strong>double clicking</strong>&quot; a <strong>CATIA</strong> 
object, its <code>Activate</code>() routine of the <em>CATIEdit</em> Interface is 
invoked, which starts a <em>CATCommand</em>. A sample implementation of the
<code>Activate</code>() routine, for our UC follows:</p>
<pre class="code">CATCommand  * <strong>CAAEPstINFEditRelimitedLine::Activate</strong>(CATPathElement *pPath)
{
  CAAPstINFEditRelimitedLineCmd *pCommandToLaunch = NULL;

  // Gets the CAAIPstINFRelimitedLine interface RelimitedLine
  CAAIPstINFRelimitedLine *piPstINFRelimitedLineEdit = NULL;                
  HRESULT rc = <strong>QueryInterface(IID_CAAIPstINFRelimitedLine,(void**)&amp;piPstINFRelimitedLineEdit)</strong>;
	                          
  if (SUCCEEDED(rc))
  {
     // Creates the command 
     <strong>pCommandToLaunch = new CAAPstINFEditRelimitedLineCmd(piPstINFRelimitedLineEdit)</strong>;
    ...
  }

  // Returns the CATCommand to edit the selected RelimitedLine.
  return (CATCommand*) pCommandToLaunch;
}</pre>
<p>The implementation initially QI for a <em>CAAIPstINFRelimitedLine</em> type from 
the current object. This serves as an input for a <em>CAAPstINFEditRelimitedLineCmd</em> 
type. Please note that before our feature extension is activated, the UI Activation 
Manager UI-Activates the first UI-Activable object immediately up the hierarchy 
of this feature extension.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step11"></a>Implementing CATICSOFilter</h3>
<p>This Interface is primarily responsible for disabling the contextual menu commands 
for the selected objects. After a selection, the select command analyses if the 
current UI Active object implements the <em>CATICSOFilter</em> Interface. If it 
does, the implementation of this interface will decide which commands are to be 
made available. If it does not, all the commands of the contextual menu are available.
</p>
<pre class="code">HRESULT <strong>CAAEPstINFCSORelimitedLine::CommandIsAvailable</strong> (const char *pHeaderID, const CATCSO *pCSO)
{
    HRESULT result;
    result = E_FAIL;
  
    // only the delete command is possible ( cut / copy / paste / paste spacial : no)
    <strong>if (!strcmp(pHeaderID, "Delete")) 
        return S_OK ;</strong>

    return result;	
}</pre>
<p>In the implementation above, only the <strong>Delete</strong> command will be 
available. The four others will be grayed since the method returns <strong>E_FAIL</strong>.
</p>
<p>It is significant to understand here the relevance of contexts, since it is the 
context which is responsible for calling your implementation above.</p>
<p>In a CATProduct document context, the ASMProduct is the UI-Active object, which 
already implements this Interface and disables all the commands except Cut, Copy, 
Paste and Delete. Further, the ASMProduct seeks a specific Interface implementation 
on features for each of those four commands, and if that is not found, it 
disables these four commands, as well.</p>
<p>On similar lines, in a CATPart context, the MechanicalPart is the UI-Active object, 
which does not implement this Interface. As a result, all the commands are available 
in the contextual menu.</p>
<p>Another significant point to note here is that it is always possible for a
<em>CATCommandHeader</em> to either enable or disable a command in the contextual 
menu, by overriding the <code>BecomeAvailable</code>() and <code>BecomeUnavailable</code>() 
methods of the <em>CATCommandHeader</em>.</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This article illustrates associating a feature extension with various behaviors 
(Model, Visualization, Interactive Command). Associating specific behavior calls 
for implementing a dedicated Interface which is also detailed in the current UC.
</p>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="refence">
	<tr>
		<td>[1]</td>
		<td>
		<a href="../CAAFmFeatModExt/CAAFmExtTaFeatureExtension.htm">
		Understanding Feature Extensions</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAAPstUcINFBuildCatalog.htm">Integrating Applicative Data In 
		Product Context</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[4]</td>
		<td><a href="CAAPstUcINFGraphicalProperties.htm">Graphical Property StartUp 
		Behavior</a></td>
	</tr>
	<tr>
		<td>[5]</td>
		<td><a href="CAAPstUcINFExtensionStartUp.htm">Defining Feature Extensions</a></td>
	</tr>
	<tr>
		<td>[6]</td>
		<td>
		<a href="../CAAFmFeatModExt/CAAFmExtTaNamingFeatures.htm">
		Understanding Feature Naming</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [Oct 2007]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop()</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
