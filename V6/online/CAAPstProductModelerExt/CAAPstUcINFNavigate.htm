<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Enabling Specification Tree Navigation</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Enabling Specification Tree Navigation</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article discusses the CAAPstINFNavigate use case. This use case 
		explains how to integrate new features created &quot;from scratch&quot; 
		in the product structure's specs tree. This article is an illustration of 
		the concept of Provider explained in the referenced article [<a href="#References">1</a>].</p>
		<p>The native process takes into account the different containers and features 
		that are native to DS modelers. However, it has no knowledge of features 
		created in user-defined applicative containers. The purpose of this use 
		case is to show how these types of features can nevertheless be displayed 
		in the specification tree.</p>
		<p>This article is one among a set of articles which together discuss the 
		"Integrating Applicative Data in Product Context" use case [<a href="#References">2</a>].</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAAPstINFNavigate Use Case</a>
				<ul>
					<li><a href="#What">What Does CAAPstINFNavigate Do</a></li>
					<li><a href="#How">How to Launch CAAPstINFNavigate</a></li>
					<li><a href="#Where">Where to Find the CAAPstINFNavigate Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#CAAPstCheckAndRetrieveContainerFromContext">CAAPstCheckAndRetrieveContainerFromContext</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>This use case is intended to illustrate how new features created &quot;from scratch&quot; 
in an applicative container can be integrated in the specification tree process.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAAPstINFNavigate Use Case</h2>
<p>The CAAPstINFNavigate is a use case defined in the CAAProductStructureExtend.edu 
framework that illustrates the integration of DataCommonProtocolUse, FeatureModelerExt 
capabilities in the scope of a Product structure.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does the CAAPstINFNavigate Use Case Do</h3>
<p>This use case illustrates the integration in the navigation process of new features 
created in an applicative container within a PLM Technological Representation.</p>
<table>
	<caption>New Features in a PLM Technological Representation</caption>
	<tr>
		<td><img alt="New Features in a PLM Technological Representation" src="images/CAAPstINFInteractiveCreation.png"/></td>
	</tr>
</table>
<p>If you have read the referenced technical article [<a href="#References">1</a>], 
you know that when the specification tree below the PLM Representation instance 
is updated, the data to display must be provided by the application owner of the 
applicative container. So, thanks a provider mechanism, you have to provide the 
list of elements to display below the PLM Representation instance. This use case 
shows that you only have to provide the &quot;root' features. It is done by a class 
implementing <em>CATINavigateProvider</em>. The 
recursive process will retrieve the feature below each root.</p>
<p>So, this use case explains how to implement <em>CATINavigateObject</em> for each 
feature type, and how to provide this list of root.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch the CAAPstINFNavigate Use Case</h3>
<p>See the section entitled &quot;How to Launch the CAAPstINFIntegrateNewFeatures 
Use Case&quot; in the &quot;Integrating Applicative Data in Product Context&quot; 
[<a href="#References">2</a>] use case for a detailed description of how this use 
case should be launched.</p>
<p>Specifically, the code described in this article is executed upon loading the 
PLM Product Reference into the V6 session. (You can use CAAPstINFProductRef.3dxml 
file in the InputData directory of the CAAProductStructureExtend.edu framework).</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAAPstINFNavigate Code</h3>
<p>This use case describes the implementation class of the <em>CATINavigateProvider</em> 
interface, called <em>CAAPstNavigProvForCAAPstINFCont</em>, which is found in the 
CAAPstNavigProvForCAAPstINFCont.cpp source file and CAAPstNavigProvForCAAPstINFCont.h 
header file inside CAAPstINFContainer module:</p>
<p><code>InstallRootFolder\CAADoc\CAAProductStructureExtend.edu\CAAPstINFContainer.m</code></p>
<p>It also describes the implementation class of the <em>CATINavigateObject</em> interface:</p>
<ul>
	<li>For CAAPstINFRoot : called <em>CAAEPstINFNavigateObjectRoot</em>, which is 
		found in the CAAEPstINFNavigateObjectRoot.cpp source file and CAAEPstINFNavigateObjectRoot.h 
		header file.</li>
	<li>For others named sub-elements (CAAPstINPoint/CAAPstINLine/CAAPstINWire): 
		called <em>CAAEPstINFNavigateSubElement</em>, which is found in the CAAEPstINFNavigateSubElement.cpp 
		source file and CAAEPstINFNavigateSubElement.h header file.</li>
</ul>
<p>inside:</p>
<p><code>InstallRootFolder\CAADoc\CAAProductStructureExtend.edu\CAAPstINFModelerUI.m</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">3</a>] is the folder 
where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>There are five logical steps to CAAPstINFNavigate:</p>
<ol>
	<li><a href="#Step1">Implementing the Navigation Provider</a></li>
	<li><a href="#Step2">The CATINavigateProvider Implementation</a></li>
	<li><a href="#Step3">Implementing CATINavigateObject On Root</a></li>
	<li><a href="#Step4">Implementing CATINavigateObject for Sub-Elements</a></li>
	<li><a href="#Step5">Retrieving the Extension Features</a></li>
</ol>
<p>The code implementations use interfaces implemented by each feature of the data 
model. You have a description of these interface in the referenced article [<a href="#References">4</a>].</p>
<p>Don't forget to update the interface dictionary file to insert a interface implementation 
declaration.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Implementing The Navigation Provider</h3>
<p>When the applicative container which contains the data model features is created 
or loaded in session, the I<code>nit </code>method of the <em>CATInit</em> interface 
is called by the process. This <code>Init </code>method declares the providers as 
described by a previous article &quot;Initializing Applicative Container at Runtime&quot; 
[<a href="#References">5</a>]. The current use case deals wit the spec tree (navigation) 
provider.</p>
<p>The navigation provider is implemented by the <em>CAAPstNavigProvForCAAPstINFCont</em> class.</p>
<p>Here an extract of the <em>CAAPstNavigProvForCAAPstINFCont</em> header file.</p>
<pre class="code"><strong>class CAAPstNavigProvForCAAPstINFCont</strong>: public CATBaseUnknown
{
  <strong>CATDeclareClass</strong>;

  public:
  CAAPstNavigProvForCAAPstINFCont();
  virtual ~CAAPstNavigProvForCAAPstINFCont();

 
  HRESULT <strong>GetChildren</strong>(CATBaseUnknown *ipObj,
	             CATLISTP(CATBaseUnknown) **opListChildren); 

  private:

  // Copy constructor and assignment operator, not implemented
  // Set as private to prevent from compiler automatic creation as public.
  // -----------------------------------
  CAAPstNavigProvForCAAPstINFCont(CAAEPstINFNavigProviderCont&amp;);
  CAAPstNavigProvForCAAPstINFCont&amp; operator=(CAAPstNavigProvForCAAPstINFCont&amp;);
	
};				                     
...</pre>
<p>The <em>CAAPstNavigProvForCAAPstINFCont</em> C++ class derives from <em>CATBaseUnknown</em>. 
The <code>CATDeclareClass</code> macro declares that the <em>CAAPstNavigProvForCAAPstINFCont</em> 
class belongs to a component. The copy constructor and the &quot;=&quot; operator 
are set as private to prevent the compiler from automatically creating as public.</p>
<p>The <em>CATINavigateProvider</em> interface contains one method to override that 
is detailed in the <a href="#Step2">The CATINavigateProvider 
Implementation</a> section.</p>
<p>Now an extract of the <em>CAAPstNavigProvForCAAPstINFCont</em> source file.</p>
<pre class="code">// Tie the implementation to its interface
#include &quot;TIE_CATINavigateProvider.h&quot;
<strong>TIE_CATINavigateProvider</strong>(<strong>CAAPstNavigProvForCAAPstINFCont</strong>);

// To declare that the class 
//
<strong>CATImplementClass</strong>( <strong>CAAPstNavigProvForCAAPstINFCont</strong>,
                   Implementation, 
                   <strong>CATBaseUnknown</strong>,
                   CATNull );
				                     
...</pre>
<p>The <code>CATImplementClass</code> macro is used in conjunction with the
<code>CATDeclareClass</code> macro in the class header file to express that the 
class is part of a CAA Object Modeler component. It is a component which OM Derives 
from <em>CATBaseUnknown</em> (third argument). The fourth argument must always be 
set to <code>CATNull</code> for component main classes.</p>
<p>Do not forget to modify the interface dictionary:</p>
<pre class="code">...
CAAPstNavigProvForCAAPstINFCont CATINavigateProvider     libCAAPstINFModeler  
...</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>The CATINavigateProvider Implementation</h3>
<p>The purpose of this navigation provider implementation is to return the list 
of &quot;CAAPstINFRoot&quot; features found in the applicative container whose latetype 
is &quot;CAAPstINFCont&quot; and the name is &quot;CAAPstINFContainer&quot;. if 
called by the Product engine in order to structure these features under the good 
PLM Techno Rep in the specs tree. It contains only one method, <code>GetChildren</code>, 
which is described in detail below.</p>
<p>This steps is divided in three sub-steps:</p>
<ol>
	<li><a href="#Step21">Verifying that the Context is a &quot;Good&quot; PLM Techno Representation</a></li>
	<li><a href="#Step22">Retrieving the &quot;CAAPstINFRoot&quot; Features from the Applicative Container</a></li>
	<li><a href="#Step23">Creating the Output List</a></li>
</ol>
<p>Each step is detailed now.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step21"></a>Verifying that the Context is a &quot;Good&quot; PLM Techno Representation</h4>
<p>This step consists in to check that the PLM Representation Reference, the context 
of the call, is the same one that those aggregating this.</p>
<pre class="code">HRESULT <strong>CAAPstVisuProvForCAAPstINFCont ::GetChildren</strong>(CATBaseUnknown *<strong>pContext</strong>, CATLISTP(CATBaseUnknown) **pListChildren) 
{
    CATBaseUnknown * pAppliCont  = NULL ;
    HRESULT rc = ::<strong>CAAPstCheckAndRetrieveContainerFromContext</strong>(pContext,
                                                             "CAAPstINFContainer",  // container name
                                                             "CAAPstINFCont",  // container type
                                                             &amp;pAppliCont);
                                                             </pre>
<p><em>CAAPstCheckAndRetrieveContainerFromContext</em> is a global function, 
explained further in the article
<a href="#CAAPstCheckAndRetrieveContainerFromContext">#</a>. This method checks 
if an applicative container whose the name is <code>CAAPstINFContainer</code> and 
the late type is <code>CAAPstINFCont</code> exists in the PLM Representation reference 
associated with <code>pContext</code>, which is a PLM Representation Instance.</p>
<p><em>CAAPstCheckAndRetrieveContainerFromContext</em> fails only if there 
is an internal error, the fact to find or not the right container is not an error, 
the method will be successful. So, after this call, the most important is the returned 
pointer <code>pAppliCont</code> . If the pointer is NULL, the PLM Representation 
Instance is not the right one, <code>GetChildren</code> will return S_OK but with 
an empty list of children.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step22"></a>Retrieving the &quot;CAAPstINFRoot&quot; Features from the Applicative Container</h4>
<p>Now we are sure that the input context contains this, so we can use <em>CAAIPstINFFactory</em><strong>
</strong>an interface implemented by our container [<a href="#References">4</a>].</p>
<pre class="code">...
   CAAIPstINFFactory<strong> </strong>* piFactoryOnAppliCont = NULL ;
   if ( NULL != pAppliCont )
   {
      rc = <strong>pAppliCont-&gt;QueryInterface(IID_CAAIPstINFFactory, (void**) &amp;piFactoryOnAppliCont)</strong>;   
      pAppliCont-&gt;Release();
      pAppliCont = NULL ;
   }
   CATListPtrCATBaseUnknown ListRoot ;
   if (piFactoryOnAppliCont != NULL)
   {
       rc = <strong>piFactoryOnAppliCont-&gt;GetRootElements(IID_CATBaseUnknown,ListRoot)</strong>;
       piFactoryOnAppliCont-&gt;Release();
       piFactoryOnAppliCont = NULL ;
    }
...
</pre>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step23"></a>Creating the Output List</h4>
<p>The output list is created only if there is at least one root features to add, 
and the input list is NULL.</p>
<pre class="code">...
  if ( (ListRoot.Size() != 0) &amp;&amp; (NULL == *pListChildren)  )
  { 
     (*pListChildren) = new CATLISTP(CATBaseUnknown);
  }
    
  // Fill in the output list with the CAAPstINFRoot feature of the container
  for (int i=1; i&lt;=ListRoot.Size(); i++ )
  {
      CATBaseUnknown *pCurrentRoot = ListRoot[i] ;
      if ( NULL != pCurrentRoot )
      {
<strong>         (*pListChildren)-&gt;Append(pCurrentRoot)</strong>;
      }
  }
...
</pre>
<script type="text/javascript">insertLinkToTop();</script>
<p>The root features are then appended to the input list.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Implementing CATINavigateObject On Root</h3>
<p>The <em>CATINavigateObject</em> interface is [<a href="#References">6</a>] implemented 
on the feature root of type &quot;CAAPstINFRoot&quot;. This interface has two methods:</p>
<ol>
	<li><code>GetIdentificators</code> - this method returns the display name of 
		the feature root object.</li>
	<li><code>GetChildren</code> - this method returns the list of the children 
		aggregated by the feature root object.</li>
</ol>
<p>They are implemented as follows:</p>
<ol>
<li>Implementing the <code>GetIdentificators</code> method.
<pre class="code">...
<strong>CATListValCATUnicodeString * CAAEPstINFNavigateObjectRoot::GetIdentificators()</strong>
{
   CATListOfCATUnicodeString *pIdent = new CATListOfCATUnicodeString;

  CATIAlias_var AliasOnThis = this ;

  if ( NULL_var != AliasOnThis )
  {
<strong>     CATUnicodeString NameRoot = AliasOnThis-&gt;GetAlias()</strong> ;
     pIdent -&gt; Append(NameRoot);
  }

  return pIdent;
}
...</pre>
<p>This method returns the display name of the &quot;CAAPstINFRoot&quot; feature 
root object returned by the <em>CATIAlias</em> implementation [<a href="#References">7</a>].</p>
</li>

<li>Implementing the <code>GetChildren</code> method.
<pre class="code">...
CATListValCATBaseUnknown_var * <strong>CAAEPstINFNavigateObjectRoot</strong>::<strong>GetChildren</strong>()
{
    HRESULT rc = E_FAIL;
    CATListValCATBaseUnknown_var* pList = new CATListValCATBaseUnknown_var;

    CAAIPstINFRoot* piPstINFOnRoot = NULL;
    rc = <strong>QueryInterface(IID_CAAIPstINFRoot,(void**)&amp;piPstINFOnRoot)</strong>;
    if (SUCCEEDED(rc))
    {
	rc =  <strong>piPstINFOnRoot-&gt;GetChildren (*pList)</strong>;

	int nbelement = pList.Size();
	piPstINFOnRoot-&gt;Release();
	piPstINFOnRoot = NULL;
   }
   return pList;
}
...</pre>
</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>Implementing CATINavigateObject for Sub-Elements</h3>
<p>The <em>CATINavigateObject</em> interface is [<a href="#References">6</a>] implemented 
on the other features, those below the &quot;CAAPstINFRoot&quot;.</p>
<ol>
<li>Implementing the <code>GetIdentificators</code> method.
<pre class="code">...
<strong>CATListValCATUnicodeString * CAAEPstINFNavigateSubElement::GetIdentificators()</strong>
{
   CATListOfCATUnicodeString *pIdent = new CATListOfCATUnicodeString;

  <strong>CATIAlias_var AliasOnThis = this </strong>;

  if ( NULL_var != AliasOnThis )
  {
 <strong>    CATUnicodeString Name= AliasOnThis-&gt;GetAlias()</strong> ;
     pIdent -&gt; Append(Name);
  }

  return pIdent;
}
...</pre>
<p>This method returns the display name of the &quot;CAAPstINFRoot&quot; feature 
root object returned by the <em>CATIAlias</em> implementation [<a href="#References">7</a>].</p>
</li>
<li>Implementing the <code>GetChildren</code> method.
<p>The implementation is fist required for the CAAPstINFWire features, since we 
have to returned the CAAPstINFPoint features building up the wire.</p>
<pre class="code">...
CATListValCATBaseUnknown_var * <strong>CAAEPstINFNavigateSubElement</strong>::<strong>GetChildren</strong>()
{
    HRESULT rc = E_FAIL;
    CATListValCATBaseUnknown_var* pList = new CATListValCATBaseUnknown_var;

  <strong> CAAIPstINFWire_var spWire = this </strong>;
   if ( NULL_var !=  spWire )
   {
       CATListPtrCATBaseUnknown pListPoint ;
       <strong>spWire-&gt;GetPoints(pListPoint)</strong> ;
       for ( int i=1 ; i &lt;= pListPoint.Size() ; i++)
       {
	   <strong>CATBaseUnknown * pCurrent =  pListPoint[i]</strong> ;
	   if ( NULL != pCurrent)
	   {
                  <strong>pList-&gt;Append(pCurrent)</strong>;
                  pCurrent-&gt;Release(); pCurrent = NULL ;
...</pre>
<p>Then we manage the possible extension.</p>
<pre class="code">...
   ::<strong>CAAPstINFRetrieveExtension</strong>(this,*pList);
...     
</pre>
<p>The <em>CAAPstINFRetrieveExtension</em> is a global function retrieving the extension 
whatever the sub-elements of our data model. This method is explained further
in <a href="#Step5">Retrieving the Extension Features</a>.</p>
<p>Finally we return the list.</p>
<pre class="code">...
   NbElement = pList-&gt;Size();
   if ( NbElement == 0 ) 
   {
	delete pList ; 
	pList = NULL ;
    }
   return pList;
...</pre>
</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step5"></a>Retrieving the Extension Features</h3>
<p>In our use case we grant any extension to be displayed below its base feature. 
You can see that with <code>CAAPstINFRelimitedLine</code>, an extension of the
<code>CAAPstINFLine</code> features. In the article [<a href="#References">7</a>], 
[Fig.4], you can see the Feature extension below the <code>CAAPstINFLine</code> 
feature.</p>
<pre class="code">...
 HRESULT <strong>CAAPstINFRetrieveExtension</strong>( CATBaseUnknown * <strong>iElement</strong>, CATListValCATBaseUnknown_var &amp; <strong>iListExtention</strong> ) 
{
   ...

   // all sub element's extension are  returned for pour modelization
   CAAIPstINFSubElement_var spSubElement = iElement ;
   if ( NULL_var == spSubElement ) return  E_INVALIDARG ;

   //  root's extension are not return for pour modelization
   <strong>CAAIPstINFRoot_var spRoot = iElement </strong>;
   <strong>if ( NULL_var != spRoot ) return  E_INVALIDARG</strong> ; 

   HRESULT rc = E_FAIL ;
 
   // get the credential 
   CATFmCredentials * MyCredential = NULL ;
   rc = ::<strong>CAAPstINFRetrieveCredentialsModeler</strong>(<strong>MyCredential</strong>);
   if (FAILED(rc) ) return  rc ;

   //Get the iterator of extension
   <strong>CATFmFeatureFacade TheFacadeOnInputElement(*MyCredential,iElement)</strong>;

   CATFmFeatureIterator ListExtension ;
   rc = <strong>TheFacadeOnInputElement.ScanExtensions(ListExtension)</strong>;
   if ( SUCCEEDED(rc) )
   {
      CATFmFeatureFacade CurrentExtension ;
      HRESULT rc_loop = <strong>ListExtension.Next(CurrentExtension)</strong>;
      while ( SUCCEEDED(rc_loop) )
      {
         <strong>CATBaseUnknown_var CurrentExtAsCBU = CurrentExtension.GetFeature()</strong>;
	if ( NULL_var != CurrentExtAsCBU ) 
	{
               <strong>iListExtention.Append(CurrentExtAsCBU)</strong>;
	}
         rc_loop = ListExtension.Next(CurrentExtension);
       }
    }
    return rc ;
}
...</pre>
<p>The first check is to confirm that the input element is essentially a <em>CAAIPstINFSubElement</em> 
implementation.</p>
<p>The next check confirms if the input element is not a <em>CAAIPstINFRoot</em> 
implementation since a root feature will never have a feature extension to it.</p>
<p>The call to <code>CAAPstRetrieveCredentialsModeler()</code> retrieves the Credentials 
required to work with the features defined in the <strong>CAAPstINFCatalog</strong>.[<a href="#References">9</a>].</p>
<p>A Feature Facade is next created on the input element and the Credentials above 
are associated with it.</p>
<p>The call to <code>ScanExtension()</code> of the <em>CATFmFeatureFacade</em> class 
retrieves the feature extensions associated with the base feature. These feature 
extensions are then appended to the input list.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="CAAPstCheckAndRetrieveContainerFromContext"></a>CAAPstCheckAndRetrieveContainerFromContext</h2>
<p>In the provider implementation ( Navigation/Visualization/Contextual Menu), we 
need to know if the context calling the provider is the right PLM Representation 
Reference. The &quot;right&quot; meaning that it contains our applicative container. 
So we have defined the CAAPstCheckAndRetrieveContainerFromContext global function.</p>
<pre class="code">...
RESULT <strong>CAAPstCheckAndRetrieveContainerFromContext</strong>(CATBaseUnknown* <strong>ipContext</strong>,
					    const CATUnicodeString &amp; iContainerName,
					    const CATUnicodeString &amp; iContainerType,
				             CATBaseUnknown ** opIAppliCont )
	   
{
    ...
    CATIPLMNavRepInstance *piPLMNavRepInstanceOnContext = NULL;
    HRESULT rc = <strong>ipContext-&gt;QueryInterface(IID_CATIPLMNavRepInstance,(void **) &amp;piPLMNavRepInstanceOnContext)</strong>;
    ...</pre>
<p>First we retrieve a <em>CATIPLMNavRepInstance</em> interface pointer on the input 
context: <code>piPLMNavRepInstanceOnContext</code>.</p>
<pre class="code">...
   CATIPLMNavRepReference *pRepRefOfContext = NULL;
   rc = <strong>piPLMNavRepInstanceOnContext-&gt;GetRepReferenceInstanceOf(pRepRefOfContext)</strong>;
...</pre>
<p>Then we retrieve the PLM Representation Reference used to create the PLM Representation 
Instance. <code>pRepRefOfContext</code> , a <em>CATIPLMNavRepReference</em> interface 
pointer is retrieved thanks to the <code>GetRepReferenceInstanceOf</code> method 
of <em>CATIPLMNavRepInstance</em>.</p>
<pre class="code">...
   CATBaseUnknown * pIter = NULL ;
   rc = <strong>pRepRefOfContext-&gt;RetrieveApplicativeContainer(iContainerName,IID_CATBaseUnknown,(void**)&amp;pIter)</strong>;
   pRepRefOfContext-&gt;Release(); 
   pRepRefOfContext = NULL ;
   if ( NULL == pIter )  return S_OK;
	
   <strong>(*opIAppliCont) = pIter</strong> ;
...</pre>
<p>Then we retrieve the container by its name. <code>pRepRefOfContext</code> using 
the <code>RetrieveApplicativeContainer</code> method of <em>CATIPLMNavRepReference</em>.</p>
<pre class="code">...
   if (SUCCEEDED(rc))
   {
      int valIsA = <strong>(*opIAppliCont)-&gt;IsAKindOf(iContainerType) </strong>;
      if ( 0 == valIsA ) 
      {
            (*opIAppliCont)-&gt;Release();(*opIAppliCont)= NULL ;    
	   return S_OK;
      }
    } else return E_FAIL; 
	
return S_OK ;
...</pre>
<p>Eventually we check that the late type of the container is the right one. We 
use <code>IsAKindOf</code> method of <em>CATBaseUnknown</em>.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>The CAAPstINFNavigate use case has shown you how new features created &quot;from 
scratch&quot; in an applicative container can be taken into account by the navigation 
process in order to integrate them in the product structure specs tree. You have 
seen how to code a provider implementation corresponding to <em>CATINavigateProvider</em> 
and how to implement the <em>CATINavigateObject</em> interface for each data model 
features.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td><a href="CAAPstTaProviders.htm">Understanding Applicative Container 
		Integration</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAAPstUcINFBuildCatalog.htm">Integrating Applicative Data In 
		Product Context</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a Use Case</a></td>
	</tr>
	<tr>
		<td>[4]</td>
		<td><a href="CAAPstUcINFIntrinsicFeatBehavior.htm">Inherent StartUp Behavior</a></td>
	</tr>
	<tr>
		<td>[5]</td>
		<td><a href="CAAPstUcINFInitCont.htm">Initializing Applicative Container 
		at Runtime</a></td>
	</tr>
	<tr>
		<td>[6]</td>
		<td>
		<a href="../CAAOmbModelingProtocol/CAAOmbUcGeoNavigate.htm">
		The Object Navigator</a></td>
	</tr>
	<tr>
		<td>[7]</td>
		<td><a href="CAAPstUcINFAlias.htm">External Name StartUp Behavior</a></td>
	</tr>
	<tr>
		<td>[8]</td>
		<td><a href="CAAPstUcINFExtensionOverview.htm">Extending Applicative Feature</a></td>
	</tr>
	<tr>
		<td>[9]</td>
		<td><a href="CAAPstUcINFBuildCatalog.htm">Defining StartUp Catalogs</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [June 2002]</td>
		<td>Document created</td>
	</tr>
	<tr>
		<td>Version: <strong>2</strong> [Oct 2006]</td>
		<td>Document updated - new provider mechanism</td>
	</tr>
	<tr>
		<td>Version: <strong>2</strong> [Jan 2011]</td>
		<td>Document updated for extend project</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
