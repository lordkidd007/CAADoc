<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Inherent StartUp Behavior</title>
</head>

<body>

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Inherent StartUp Behavior</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article discusses the <code>CAAPstINFIntrinsicFeatBehavior</code> 
		use case. This Use Case (UC) illustrates the various Interface implementations 
		to handle Applicative Containers (instantiate features, scan through its 
		contents) and features (feature introspection) of the &quot;<strong>Integrating 
		Applicative Data</strong>&quot; use case. We call these Interfaces &quot;<strong>Intrinsic</strong>&quot;, 
		since they manage their contents.</p>
		<p>This article is one among a set of articles which together discuss the &quot;Integrating 
		Applicative Data in Product Context&quot; use case [<a href="#References">1</a>].
		</p>
		<ul>
			<li><a href="#Learn">What You Will Learn With This Use Case</a></li>
			<li><a href="#UseCase">The CAAPstINFIntrinsicFeatBehavior Use Case</a>
				<ul>
					<li><a href="#What">What Does CAAPstINFIntrinsicFeatBehavior 
						Do</a></li>
					<li><a href="#How">How to Launch CAAPstINFIntrinsicFeatBehavior</a></li>
					<li><a href="#Where">Where to Find the CAAPstINFIntrinsicFeatBehavior 
						Code</a></li>
				</ul>
			</li>
			<li><a href="#Step">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>The UC teaches an end-user:</p>
<ul>
	<li>Usage of Applicative Container as a Factory to instantiate features inside 
		it, realized by implementing a Factory Interface on it.</li>
	<li>Setting and Retrieving feature attributes, realized by implementing dedicated 
		Interfaces on the features.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="UseCase"></a>The CAAPstINFIntrinsicFeatBehavior Use Case</h2>
<p>The CAAPstINFIntrinsicFeatBehavior is is a use case defined in the CAAProductStructureExtend.edu 
framework that illustrates the integration of FeatureModelerExtend framework capabilities 
in the scope of a Product structure.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="What"></a>What Does the CAAPstINFIntrinsicFeatBehavior Use Case Do</h3>
<p>This UC details the implementation of the:</p>
<ul>
	<li><em>CAAIPstINFFactory</em> Interface on an <strong>Applicative Container</strong> 
		exposing services to instantiate features (Root, Point, Line, Wire) inside 
		it.</li>
	<li><em>CAAIPstINFFactory</em> Interface on an <strong>Applicative Container</strong> 
		exposing services to retrieve features (root and otherwise) instantiated 
		inside it.</li>
	<li><em>CAAIPstINFRoot</em> Interface on a <strong>Root</strong> feature to 
		aggregate the other features (Point, Line, Wire).</li>
	<li><em>CAAIPstINFPoint</em> Interface on a <strong>Point</strong> feature to 
		valuate and retrieve its 2D Co-ordinates.</li>
	<li><em>CAAIPstINFLine</em> Interface on a <strong>Line</strong> feature to 
		set and retrieve its Start and End Points.</li>
	<li><em>CAAIPstINFWire</em> Interface on a <strong>Wire</strong> feature to 
		set and retrieve the set of points which define it.</li>
	<li><em>CAAIPstINFSubElement</em> Interface on a <strong>Point</strong>,
		<strong>Line</strong> and <strong>Wire</strong> feature to retrieve the 
		their aggregating root.</li>
</ul>
<p>These implementations are used by the code of the UC &quot;<strong>Creating Features 
in a Technological Representation</strong>&quot; [<a href="#References">2</a>].</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="How"></a>How to Launch the CAAPstINFIntrinsicFeatBehavior Use Case</h3>
<p>This Use Case is in fact referenced by another UC &quot;Creating Features in 
a Technological Representation&quot; [<a href="#References">2</a>]. Hence, the launch 
of this referencing UC, invokes the code of the current UC.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Where"></a>Where to Find the CAAPstINFIntrinsicFeatBehavior Code</h3>
<p>The <code>CAAPstINFIntrinsicFeatBehavior</code> use case is made of several source 
files:</p>
<ul>
	<li><strong>CAAEPstINFFactory.cpp</strong>, which has the <em>CAAIPstINFFactory</em> 
		implementation on our Container (late type <strong>CAAPstINFCont</strong>).</li>
	<li><strong>CAAEPstINFPoint.cpp</strong>, which has the <em>CAAIPstINFPoint</em> 
		implementation on our Point feature (late type <strong>CAAPstINFPoint</strong>).</li>
	<li><strong>CAAEPstINFLine.cpp</strong>, which has the <em>CAAIPstINFLine</em> 
		implementation on our Line feature (late type <strong>CAAPstINFLine</strong>).</li>
	<li><strong>CAAEPstINFWire.cpp</strong>, which has the <em>CAAIPstINFWire</em> 
		implementation on our Wire feature (late type <strong>CAAPstINFWire</strong>).</li>
	<li><strong>CAAEPstINFSubElement.cpp</strong> which has the <em>CAAIPstINFSubElement</em> 
		implementation on our Wire/Point/Line features.</li>
	<li><strong>CAAPstINFRetrieveCredentialsModeler.cpp</strong> which contains 
		the global routine <code>CAAPstINFRetrieveCredentialsModeler</code>() to 
		retrieve the Credentials authorizing access to the <strong>CAAPstINFCatalog</strong> 
		catalog.</li>
</ul>
<p>These sources are at the location:</p>
<p><code>InstallRootFolder\CAADoc\CAAProductStructureExtend.edu\CAAPstINFModeler.m</code></p>
<p>where <code>InstallRootFolder</code> [<a href="#References">3</a>] is the folder 
where the API CD-ROM is installed.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="Step"></a>Step-by-Step</h2>
<p>The UC CAAPstINFIntrinsicFeatBehavior implementation is broadly split into two 
sections listed below:</p>
<ol>
	<li><a href="#Step1">Applicative Container as a Factory to Create Feature Data</a>
		<ol>
			<li><a href="#Step11">Factory Implementation on a Container to Create 
				Root Feature</a></li>
			<li><a href="#Step12">Factory Implementation on a Container to Create 
				Point Feature</a></li>
			<li><a href="#Step13">Factory Implementation on a Container to Create 
				Line Feature</a></li>
			<li><a href="#Step14">Factory Implementation on a Container to Create 
				Wire Feature</a></li>
		</ol>
	</li>
	<li><a href="#Step2">Applicative Container Services to Retrieve its Children</a>
		<ol>
			<li><a href="#Step21">Container Service to Retrieve Root Features inside 
				It</a></li>
			<li><a href="#Step22">Container Service to Retrieve Child Features of 
				a Specific Type inside It</a></li>
		</ol>
	</li>
	<li><a href="#Step3">Valuating and Retrieving the Feature Attributes</a>
		<ol>
			<li><a href="#Step31">Valuating and Retrieving the Point Coordinates</a></li>
			<li><a href="#Step32">Valuating and Retrieving the Line Start and End 
				Points</a></li>
			<li><a href="#Step33">Valuating and Retrieving the Wire Points</a></li>
		</ol>
	</li>
	<li><a href="#Step4">CAAIPstINFSubElement</a></li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step1"></a>Applicative Container as a Factory to Create Feature Data</h3>
<p>The features are instantiated inside an Applicative Container. This is realized 
by providing a <em>CAAIPstINFFactory</em> implementation on a Container, responsible 
for instantiating features inside the container.</p>
<p>Note: Since the features Point, Line and Wire must essentially be aggregated 
under Root, these services ensure that the child features are essentially aggregated 
under Root at the time of instantiation.</p>
<pre class="code">// Tie the implementation to its interface.
#include "TIE_CAAIPstINFFactory.h"
<strong>TIE_CAAIPstINFFactory(CAAEPstINFFactory)</strong>;

// To declare that the class is a data extension of CAAPstINFCont
<strong>CATImplementClass</strong> (<strong>CAAEPstINFFactory</strong>,
                   <strong>DataExtension</strong>,    
                   CATBaseUnknown,
                   <strong>CAAPstINFCont</strong>); 
 
// To declare that CAAEPstINFFactory implements CAAIPstINFFactory for the CAAPstINFCont
// component, insert the following line in the interface dictionary:
// <strong>CAAPstINFCont CAAIPstINFFactory  libCAAINFModeler</strong>
</pre>
<p>The Container is declared as a <em>CAAIPstINFFactory</em> implementation.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step11"></a>Factory Implementation on a Container to Create Root Feature</h4>
<p>We begin by the <code>CreateRoot</code>() implementation which follows, which 
instantiates the Root feature, inside the applicative container.</p>
<pre class="code">HRESULT <strong>CAAEPstINFFactory::CreateRoot</strong>(CAAIPstINFRoot *&amp; <b>oNewRoot</b>)<strong>
</strong>{
	HRESULT rc = E_FAIL ;
	oNewRoot = NULL ;

	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsModeler</strong>(MyCredential);
	if ( FAILED(rc) ) return rc ;

	<strong>CATFmContainerFacade MyContainerFacade(*MyCredential,this)</strong>;

	CATUnicodeString rootSUType("<strong>CAAPstINFRoot</strong>");
	CATFmStartUpFacade RootStartUpFacade(*MyCredential,rootSUType);

         CATFmFeatureFacade FeatFacadeOnRootInst ; 
	rc = <strong>RootStartUpFacade.InstantiateIn</strong>(<strong>MyContainerFacade</strong>,FeatFacadeOnRootInst);
	if (SUCCEEDED(rc))
 	    rc = <strong>FeatFacadeOnRootInst.QueryInterfaceOnFeature</strong>(IID_CAAIPstINFRoot,
 	                                                     (void**) &amp;<strong>oNewRoot</strong>);

	return rc ;
}</pre>
<p><strong>The feature &quot;<strong>CAAPstINFRoot</strong>&quot; is instantiated. 
It serves as a root feature, a parent feature aggregating other features, instantiated 
in the steps that follow</strong>.</p>
<p><strong>The instantiation involves the steps listed below. The details of these 
steps could be found in the UC &quot;<b>Creating Features</b>&quot; [<a href="#References">4</a>]</strong></p>
<ul>
	<li>Retrieving the Credentials which authorize user to work with the features 
		defined in the <strong>CAAPstINFCatalog.CATfct catalog</strong> [<a href="#References">5</a>].</li>
	<li>Create a Container Facade over the Container, which is infact the current 
		Component implementing the <em>CAAIPstINFFactory</em> Interface.</li>
	<li>Create a StartUp Facade for the <strong>CAAPstINFRoot</strong> StartUp.</li>
	<li>Instantiate the <strong>CAAPstINFRoot</strong> feature, by calling <code>
		InstantiateIn</code>() of the <em>CATFmStartUpFacade</em> class. The root 
		feature is retrieved as a its Feature Facade, a <em>CATFmFeatureFacade</em> 
		type (<code>FeatFacadeOnRootInst</code>).</li>
	<li>Finally the root feature is retrieved as a <em>CAAIPstINFRoot</em>* type 
		(<code>oNewRoot</code>). This is realized with a call to <code>QueryInterfaceOnFeature</code>().</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step12"></a>Factory Implementation on a Container to Create Point Feature</h4>
<p>Next, we proceed to instantiate a Point feature inside the Root. This is realized 
by the <code>CreatePoint</code>() implementation of the <em>CAAIPstINFFactory</em> 
Interface on our Container.</p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::CreatePoint</b>(double <b>ix</b>, double <b>iy</b>, double <b>iz</b>,
                                       CAAIPstINFRoot * <b>ipParent</b>,
                                       CAAIPstINFPoint *&amp; <b>opNewPoint</b>)
{
         ... 
        if (SUCCEEDED(rc))
	     rc = <strong>FeatFacadeOnPointInst.QueryInterfaceOnFeature</strong>(<strong>IID_CAAIPstINFPoint</strong>,
		                                              (void**) &amp;opNewPoint);

	// Point Valution
         if ( SUCCEEDED(rc) &amp;&amp; (opNewPoint != NULL) )
	{
            <strong>opNewPoint-&gt;SetX</strong>(ix);
	   opNewPoint-&gt;SetY(iy);
	   opNewPoint-&gt;SetZ(iz);
	}
</pre>
<p>The steps to instantiate the &quot;<strong>CAAIPstINFPoint</strong>&quot; feature 
are as detailed in the previous step, where the root feature is instantiated. The 
Point feature is finally retrieved as a <em>CAAIPstINFPoint</em>* type (<code>opNewPoint</code>). 
We next valuate the <b>X</b>, <b>Y</b> and <b>Z</b> co-ordinates of the Point, with 
a call to <code>SetX</code>(), <code>SetY</code>() and <code>SetZ</code>() respectively 
of the <em>CAAIPstINFPoint</em> Interface to our Point feature.</p>
<p>The Point feature is then aggregated under the Root feature with a call to the
<code>AddChild</code>() implementation, local to our Component, as depicted in the 
code below.</p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::CreatePoint</b>(double <b>ix</b>, double <b>iy</b>, double <b>iz</b>, 
                                       CAAIPstINFRoot * <b>ipParent</b>, 
                                       CAAIPstINFPoint *&amp; <b>opNewPoint</b>)
{
	// Point aggregation
	if ( SUCCEEDED(rc) &amp;&amp; (opNewPoint != NULL) )
	{
            rc = <strong>AddChild(opNewPoint,ipParent)</strong>;
	}
}</pre>
<p>The <code>AddChild</code>() implementation follows. It takes two inputs namely. 
the child feature and the parent feature, in that order.</p>
<pre class="code">HRESULT <strong>CAAEPstINFFactory::AddChild</strong>( CATBaseUnknown* <b>ipCBUOnChild</b> , 
                                     CAAIPstINFRoot* <b>ipRootParent</b>)<strong>
</strong>{
    ...
    CATFmCredentials * MyCredential = NULL ;
    rc = ::<b>CAAPstINFRetrieveCredentialsModeler</b>(MyCredential);
    if ( FAILED(rc) ) return rc ;
    <b>CATFmFeatureFacade FeatFacadeOnRoot(*MyCredential,ipRootParent)</b>;

    // Valuate the Root Attribute value to the child feature
    CATFmAttributeValue ChildAsAttrValue;
    <b>ChildAsAttrValue.SetFeature(ipCBUOnChild)</b>;

    // Retrieve the attribute key in order to access the list of aggregated features
    CATUnicodeString keyName("ListOfComponents");
    <b>CATFmAttributeName RootAttrKey(keyName)</b>;

    rc = <b>FeatFacadeOnRoot.AppendValue</b>(RootAttrKey,ChildAsAttrValue);
    ...
}</pre>
<p>The <code>AddChild</code>() implementation simply aggregates a feature under 
another feature. This is realized by valuating the attribute &quot;<b>ListOfComponents</b>&quot;, 
of type &quot;<b>list of components</b>&quot;. The steps involved to aggregate a 
feature are described in the UC &quot;<b>Setting up Aggregating Links</b>&quot; 
[<a href="#References">6</a>].</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step13"></a>Factory Implementation on a Container to Create Line Feature</h4>
<p><b>Next, we proceed to instantiate a Line feature inside the Root. This is realized 
by the <code>CreateLine</code>() implementation of the <em>CAAIPstINFFactory</em> 
Interface on our Container.</b></p>
<pre class="code">HRESULT <strong>CAAEPstINFFactory::CreateLine</strong>(CAAIPstINFPoint *<b>ipStartPoint</b>,
                                      CAAIPstINFPoint *<b>ipEndPoint</b>, 
                                      CAAIPstINFRoot * <b>ipParent</b>, 
                                      CAAIPstINFLine *&amp; <b>opNewLine</b>)<strong>
{
    ... 
    rc = <strong>FeatFacadeOnLineInst.QueryInterfaceOnFeature(IID_CAAIPstINFLine,</strong></strong>
                                                     (void**) &amp;opNewLine);
    ...</pre>
<p><b>The steps to instantiate the &quot;<b>CAAIPstINFLine</b>&quot; feature are 
as detailed in the previous step, where the root feature is instantiated. The Line 
feature is finally retrieved as a <em>CAAIPstINFLine</em>* type (<code>opNewLine</code>). 
We next set the Start and End Points to our Line feature with a call to <code>SetPoint</code>() 
of the <em>CAAIPstINFLine</em> Interface to our Line feature.</b></p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::CreateLine</b>(CAAIPstINFPoint *<b>ipStartPoint</b>,
                                      CAAIPstINFPoint *<b>ipEndPoint</b>, 
                                      CAAIPstINFRoot * <b>ipParent</b>, 
                                      CAAIPstINFLine *&amp; <b>opNewLine</b>)
{
     ...
    // Line Valution with the two input points
    if ( SUCCEEDED(rc) &amp;&amp; (opNewLine != NULL) )
    {
       HRESULT rc1 = <b>opNewLine-&gt;SetPoint</b>(1,ipStartPoint);
       HRESULT rc2 = opNewLine-&gt;SetPoint(2,ipEndPoint);
       ...
</pre>
<p>The next step involves aggregating the Line feature under the Root, realized 
with a call to <code>AddChild</code>().</p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::CreateLine</b>(CAAIPstINFPoint *<b>ipStartPoint</b>,
                                      CAAIPstINFPoint *<b>ipEndPoint</b>, 
                                      CAAIPstINFRoot * <b>ipParent</b>, 
                                      CAAIPstINFLine *&amp; <b>opNewLine</b>)
{
     ...
    // line aggregation below the input parent ( a root)
    if ( SUCCEEDED(rc) &amp;&amp; (opNewLine != NULL) )
<strong>	rc = AddChild(opNewLine,ipParent)</strong>;
</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step14"></a>Factory Implementation on a Container to Create Wire Feature</h4>
<p>Finally we detail the steps involved to instantiate a Wire feature under Root.This 
is realized by the <code>CreateWire</code>() implementation of the <em>CAAIPstINFFactory</em> 
Interface on our Container.</p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::CreateWire</b>(CATListPtrCATBaseUnknown &amp; <b>pListPoint</b>, 
                                      CAAIPstINFRoot * <b>ipParent</b>, 
                                      CAAIPstINFWire *&amp; <b>opNewWire</b>)
{
    ...
    rc = <strong>FeatFacadeOnWireInst.QueryInterfaceOnFeature(IID_CAAIPstINFWire,</strong>(void**) &amp;opNewWire);</pre>
<p>The steps to instantiate the &quot;<b>CAAIPstINFWire</b>&quot; feature are as 
detailed in the previous step, where the root feature is instantiated. The Wire 
feature is finally retrieved as a <em>CAAIPstINFWire</em>* type (<code>opNewWire</code>). 
We next set the Points which define our Wire feature with a call to <code>SetPoints</code>() 
of the <em>CAAIPstINFWire</em> Interface to our Wire feature.</p>
<pre class="code">HRESULT <strong>CAAEPstINFFactory::CreateWire</strong>(CATListPtrCATBaseUnknown &amp; <strong>pListPoint</strong>, 
                                      CAAIPstINFRoot * <strong>ipParent</strong>, 
                                      CAAIPstINFWire *&amp; <strong>opNewWire</strong>) 
 {
    ... 
    // Wire valuation with the input list of point
    if ( SUCCEEDED(rc) &amp;&amp; (opNewWire != NULL) )
    rc = opNewWire-&gt;SetPoints(pListPoint);
    ...
}</pre>
<p>The next step involves aggregating the Wire feature under the Root, realized 
with a call to <code>AddChild</code>().</p>
<pre class="code">HRESULT <strong>CAAEPstINFFactory::CreateWire</strong>(CATListPtrCATBaseUnknown &amp; <strong>pListPoint</strong>,
                                      CAAIPstINFRoot * <strong>ipParent</strong>, 
                                      CAAIPstINFWire *&amp; <strong>opNewWire</strong>) 
 {
    ... 
       // Wire aggregation below the input parent ( a root)
       if ( SUCCEEDED(rc) &amp;&amp; (opNewWire != NULL) )
       rc = <strong>AddChild</strong>(opNewWire,ipParent);
    ...
}</pre>
<p>We next proceed to detail the implementation of those routines which are responsible 
for setting attribute values to our features. This is realized by the <em>CAAIPstINFPoint</em>,
<em>CAAIPstINFLine</em> and <em>CAAIPstINFWire</em> implementation on our <b>Point</b>,
<b>Line</b> and <b>Wire</b> features.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step2"></a>Applicative Container Services to Retrieve its Children</h3>
<p>The Applicative Container exposes services to retrieve the child features instantiated 
inside it. There are two services listed below:</p>
<ol>
	<li><a href="#Step21">Container Service to Retrieve Root Features inside It</a></li>
	<li><a href="#Step22">Container Service to Retrieve Child Features of a Specific 
		Type inside It</a></li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step21"></a>Container Service to Retrieve Root Features inside It</h4>
<p>The call below retrieves the feature inside an applicative container of a specific 
type. The type of features are those implementing the <em>CAAIPstINFRoot</em> Interface.</p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::GetRootElements</b>(<b>const IID &amp;iIID</b>, 
                                   CATListPtrCATBaseUnknown &amp; <b>ioListElement</b> ) 
{
     ...
     CATFmCredentials * MyCredential = NULL ;
     rc = ::<b>CAAPstINFRetrieveCredentialsModeler</b>(MyCredential);

     <b>CATFmContainerFacade MyContainerFacade(*MyCredential,this)</b>;
	
    // First we get all the stand-alone features
    CATFmFeatureIterator Iterator;
    rc = <b>MyContainerFacade.ScanRootFeatures(Iterator)</b>;

    //The method ensures that the returned objects are all CATPstINFRoot
    CATFmFeatureFacade FeatFacadeOnCurrentElement;
    HRESULT rc_loop =  <b>Iterator.Next(FeatFacadeOnCurrentElement)</b>;
    while (SUCCEEDED(rc_loop))
    {
	CAAIPstINFRoot * pStandALoneCurrent = NULL ;
	<b>FeatFacadeOnCurrentElement.QueryInterfaceOnFeature</b>(<b>IID_CAAIPstINFRoot</b>,
	                                                  (void**) &amp; pStandALoneCurrent);
	if ( NULL != pStandALoneCurrent ) // it is a root
	{
             CATBaseUnknown * pRootToReturn = NULL ;
	<b>    pStandALoneCurrent-&gt;QueryInterface</b>(<b>iIID</b>,(void**)&amp;pRootToReturn);
	   if ( pRootToReturn != NULL )
	       <b>ioListElement.Append(pRootToReturn)</b>;
	   ...		
            rc_loop = <b>Iterator.Next(FeatFacadeOnCurrentElement)</b>;
	}
	
	return rc ;
}</pre>
<p>The GetRootElements() implementation of the <em>CAAIPstINFFactory</em> Interface 
of an Applicative Container consists of the steps listed below:</p>
<ul>
	<li>Retrieving the Credentials which authorize user to work with the features 
		defined in the <strong>CAAPstINFCatalog.CATfct catalog</strong> [<a href="#References">4</a>].</li>
	<li>Create a Container Facade over the Container, which is infact the current 
		Component implementing the <em>CAAIPstINFFactory</em> Interface. The facade 
		is associated with the Credentials retrieved above.</li>
	<li>The <code>ScanRootFeatures</code>() call of the <em>CATFmContainerFacade</em> 
		class retrieves the root features inside it, inside an iterator, of type
		<em>CATFmFeatureIterator</em>.</li>
	<li>The <code>Next</code>() call of the <em>CATFmFeatureIterator</em> class 
		parses through an Iterator to retrieve the root features in it, each stored 
		as a <em>CATFmFeatureFacade</em> type (<code>FeatFacadeOnCurrentElement</code>).</li>
	<li>The call to <code>QueryInterfaceOnFeature</code>() of the <em>CATFmFeatureFacade</em> 
		class retrieves each root feature as a <em>CAAIPstINFRoot*</em> type (<code>pStandAloneCurrent</code>). 
		Since we retrieve each feature as a <em>CAAIPstINFRoot</em>* type, the SUCCESS 
		of this call confirms that the feature retrieved is indeed a root feature.</li>
	<li>The call to <code>QueryInterface</code>() next retrieves our root feature 
		as an Interface type, as desired by the user, input as a <code>IID</code> 
		type during invocation.</li>
	<li>The root feature is then appended to the out list, type <em>CATListPtrCFATBaseUnknown</em>.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step22"></a>Container Service to Retrieve Child Features of a Specific 
Type inside It</h4>
<p>The call below retrieves the feature inside an appication of a specific type. 
The type is determined by a distinct Interface implemented by these child features.</p>
<pre class="code">HRESULT <b>CAAEPstINFFactory::GetElementsByType</b>(const IID &amp;<b>iIID</b>, 
                                      CATListPtrCATBaseUnknown &amp; <b>ioListElement</b> ) 
{
	HRESULT rc = E_FAIL ;

	CATFmCredentials * MyCredential = NULL ;
	rc = ::<b>CAAPstINFRetrieveCredentialsModeler</b>(MyCredential);
	if ( FAILED(rc) ) return rc ;

    <b>CATFmContainerFacade MyContainerFacade(*MyCredential,this)</b>;

	// First we get all the stand-alone features
	CATFmFeatureIterator Iterator;
    rc = <b>MyContainerFacade.ScanFeatures(Iterator)</b>;

	//The method ensures that the returned objects are all CATPstINFRoot
    CATFmFeatureFacade FeatFacadeOnCurrentElement;
    HRESULT rc_loop =  <b>Iterator.Next(FeatFacadeOnCurrentElement)</b>;
	while (SUCCEEDED(rc_loop))
	{
		void * pTypedChildElement = NULL ;
		<b>FeatFacadeOnCurrentElement.QueryInterfaceOnFeature</b>(<b>iIID</b>,
		                                (void**)&amp;pTypedChildElement);
		if ( NULL != pTypedChildElement )
	       <b>ioListElement.Append</b>((CATBaseUnknown*)pTypedChildElement);
	        
		rc_loop = <b>Iterator.Next</b>(FeatFacadeOnCurrentElement);
	}
	return rc ;
}
</pre>
<p>The <code>GetElementsByType</code>() implementation of the <em>CAAIPstINFFactory</em> 
Interface of an Applicative Container consists of the steps listed below:</p>
<ul>
	<li>Retrieving the Credentials which authorize user to work with the features 
		defined in the <strong>CAAPstINFCatalog.CATfct</strong> catalog [<a href="#References">5</a>].</li>
	<li>Create a Container Facade over the Container, which is infact the current 
		Component implementing the <em>CAAIPstINFFactory</em> Interface. The facade 
		is associated with the Credentials retrieved above.</li>
	<li>The <code>ScanFeatures</code>() call of the <em>CATFmContainerFacade</em> 
		class retrieves the features inside it, inside an iterator, of type <em>
		CATFmFeatureIterator</em>.</li>
	<li>The <code>Next</code>() call of the <em>CATFmFeatureIterator</em> class 
		parses through an Iterator to retrieve the features in it, each stored as 
		a <em>CATFmFeatureFacade</em> type (FeatFacadeOnCurrentElement).</li>
	<li>The call to <code>QueryInterfaceOnFeature</code>() of the <em>CATFmFeatureFacade</em> 
		class retrieves each feature as an Interface type (<code>pTypedChildElement</code>). 
		This step essentially filters the child features stored inside the Iterator 
		to retrieve only those which implement the Interface input the routine (<code>IID</code> 
		type input).</li>
	<li>The retrieved feature is then appended to the out list, type <em>CATListPtrCFATBaseUnknown</em>.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step3"></a>Valuating and Retrieving the Feature Attributes</h3>
<p>The features are always associated with attributes. These attributes need to 
be valuated and retrieved.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step31"></a>Valuating and Retrieving the Point Coordinates</h4>
<p>Our Point feature is a 3D Point which has the X, Y, Z co-ordinates associated 
with it. The co-ordinates of the point are set with the Set routines. A sample
<code>SetX</code>() routine of the <em>CAAIPstINFPoint</em> Interface implemented 
by the Point feature follows:</p>
<pre class="code">HRESULT <b>CAAEPstINFPoint::SetX</b>(double iX)
{
         ...
	CATFmCredentials * MyCredential = NULL ;
	rc =::<b>CAAPstINFRetrieveCredentialsModeler</b>(MyCredential);
	if ( FAILED(rc) ) return rc ;

	// Retrieve a CATFmFeatureFacade type on Point (this)
	<b>CATFmFeatureFacade FeatFacadeOnPoint(*MyCredential,this)</b>;

	// Retrieve the "X" attribute key 
	CATUnicodeString PointXkeyName("X");
  CATFmAttributeName PointXAttrKey(PointXkeyName);
	CATFmAttributeValue PointXAttrValue(iX)<strong>;</strong>
<strong>	rc = <b>FeatFacadeOnPoint.SetValue</b>(PointXAttrKey,PointXAttrValue);
	
</strong>	return rc;
}</pre>
<p>The steps involved to set/retrieve a feature attribute value is detailed in the 
UC &quot;<strong>Accessing Feature Attributes</strong>&quot; [<a href="#References">7</a>]. 
The X co-ordinate of the Point is set above, by valuating its &quot;<strong>X</strong>&quot; 
attribute, with the value input to the <strong>Set</strong> routine.</p>
<p>On similar lines, the co-ordinates are retrieved as depicted in the implementation 
of the <code>GetX</code>() routine that follows:</p>
<pre class="code">HRESULT <strong>CAAEPstINFPoint::GetX(double *pX)</strong> 
{
         ...

	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsModeler</strong>(MyCredential)<strong>;
</strong>	if ( FAILED(rc) ) return rc ;<strong>

</strong>	// Retrieve a CATFmFeatureFacade type on Point (this)
	<strong>CATFmFeatureFacade FeatFacadeOnPoint(*MyCredential,this)</strong>;

	// Retrieve the "X" attribute key 
	CATUnicodeString <strong>PointXkeyName</strong>("<strong>X</strong>");
	CATFmAttributeName PointXAttrKey(PointXkeyName);
	CATFmAttributeValue PointXAttrValue;
	rc = <strong>FeatFacadeOnPoint.GetValue</strong>(<strong>PointXAttrKey</strong>,PointXAttrValue);
	if (SUCCEEDED(rc))
		rc = <strong>PointXAttrValue.GetDouble</strong>(*pX);

	return rc;
}</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step32"></a>Valuating and Retrieving the Line Start and End Points</h4>
<p>Our Line feature is characterized by a Start and End Point.</p>
<p>The <code>SetPoint</code>() implementation of the <em>CAAIPstINFLine</em> implementation 
on our line feature, sets the start and end points. We proceed to explain the implementation 
of this routine.</p>
<pre class="code">HRESULT CAAEPstINFLine::SetPoint(int <strong>iNum</strong>, CAAIPstINFPoint* <strong>iPstINFOnPoint</strong>)
{
    HRESULT rc = E_FAIL;

    CATFmCredentials * MyCredential = NULL<b> ;</b>
    rc = ::<strong>CAAPstINFRetrieveCredentialsModeler</strong>(MyCredential);
    ...

    CATUnicodeString keyName;
    if (1 == iNum)   
	keyName = "Point1";
    else 
	keyName = "Point2";
    CATFmAttributeName PointAttrKey(keyName);

    CATFmAttributeValue PointAttrValue;
    <strong>PointAttrValue.SetFeature</strong>(<strong>iPstINFOnPoint</strong>);

    CATFmFeatureFacade FeatFacadeOnThis(*MyCredential,this);
    rc = <strong>FeatFacadeOnThis.SetValue</strong>(<strong>PointAttrKey</strong>,<strong>PointAttrValue</strong>);

    return rc;
}</pre>
<p>The implementation simply involves valuating either of the two Line attributes, 
namely. <strong>Point1</strong> and <strong>Point2</strong> which respectively represent 
the <strong>Start</strong> and <strong>End</strong> point of the Line. The UC &quot;<strong>Making 
Reference Links</strong>&quot; [<a href="#References">8</a>] details the steps involved 
in setting a referencing link to the start and end points of a Line.</p>
<p>On similar lines, we can retrieve the start and end points of a Line feature 
using the <code>GetPoint</code>() implementation of the <em>CAAIPstINFLine</em> 
Interface on a Line feature. The code follows:</p>
<pre class="code">HRESULT <strong>CAAEPstINFLine::GetPoint</strong>(int <b>iNum</b>, CAAIPstINFPoint* &amp; <strong>oPstINFOnPoint</strong>)
{
         ...
	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsModeler</strong>(MyCredential);
         ...

	CATUnicodeString keyName;
	if (1 == iNum) 
		<strong>keyName = "Point1"</strong>;
	else 
		<strong>keyName = "Point2"</strong>;

	CATFmFeatureFacade FmFeatFacadeOnPoint;
	CATFmAttributeName <strong>PointAttrKey</strong>(keyName);
	CATFmAttributeValue PointAttrValue;
	<strong>CATFmFeatureFacade FeatFacadeOnThis(*MyCredential,this)</strong>;
	rc = <strong>FeatFacadeOnThis.GetValue</strong>(<strong>PointAttrKey</strong>,PointAttrValue);

	if (SUCCEEDED(rc))
	{
	    <strong>CATBaseUnknown_var spCBUOnPoint</strong> = <strong>PointAttrValue.GetFeature</strong>();
	    if ( NULL_var != spCBUOnPoint )
                  rc = <strong>spCBUOnPoint-&gt;QueryInterface</strong>(<strong>IID_CAAIPstINFPoint</strong>,
                                                 (void**)&amp; <strong>oPstINFOnPoint</strong>);
	    else rc = E_FAIL ; // no feature, error 
	}

	return rc;
}</pre>
<p>The steps involved to retrieve a feature attribute value is detailed in the UC &quot;<strong>Accessing 
Feature Attributes</strong>&quot; [<a href="#References">7</a>]. The referenced 
Point feature is finally retrieved as a <em>CAAIPstINFPoint</em>* type (<strong>oPstINFOnPoint</strong>).</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h4><a name="Step33"></a>Valuating and Retrieving the Wire Points</h4>
<p>Our Wire feature is defined by a list of points. The call to <code>SetPoints</code>() 
implementation of the <em>CAAIPstINFWire</em> Interface on our Wire feature sets 
a list of points to our Wire feature. The implementation of the <code>SetPoints</code>() 
routine follows.</p>
<pre class="code">HRESULT <strong>CAAEPstINFWire::SetPoints</strong>(<strong>CATListPtrCATBaseUnknown &amp; iListOfPoints</strong>)<strong> 
</strong>{
         ...
	CATFmCredentials * MyCredential = NULL ;
	rc = ::<strong>CAAPstINFRetrieveCredentialsModeler</strong>(MyCredential);
	if ( FAILED(rc) ) return rc ;

	// Create a CATFmAttributeValue type with the input list
	CATFmAttributeValue fmAttrValueOnListOfPoints;
	int i = 1 ;
	while ( SUCCEEDED(rc) &amp;&amp; ( i &lt;= iListOfPoints.Size() ) )
	{
		<strong>CATBaseUnknown* piCBUOnPoint = iListOfPoints[i]</strong>;
		CAAIPstINFPoint* piPstINFPoint = NULL;
		if (NULL != piCBUOnPoint)
			<strong>piCBUOnPoint-&gt;QueryInterface</strong>(IID_CAAIPstINFPoint,
			                            (void**)&amp;<strong>piPstINFPoint</strong>);
		if (NULL !=piPstINFPoint)
		{
                           ...
			CATFmAttributeValue fmAttrValueOnPoint;
			<strong>fmAttrValueOnPoint.SetFeature(piCBUOnPoint)</strong>;
			<strong>fmAttrValueOnListOfPoints.Append(fmAttrValueOnPoint)</strong>;
		} else rc = E_FAIL ;
		i++ ;
	}

	if ( SUCCEEDED(rc) )
	{
	   // Retrieve a CATFmFeatureFacade type on Wire (this)
	   <strong>CATFmFeatureFacade FeatFacadeOnWire(*MyCredential,this)</strong>;
            // Retrieve the "Points" attribute key 
	   CATFmAttributeName <strong>WirePointsAttrkey</strong>("<strong>Points</strong>");
            rc = <strong>FeatFacadeOnWire.SetValue</strong>(<strong>WirePointsAttrkey</strong>,fmAttrValueOnListOfPoints);
	}
	 
	return rc;
} 
</pre>
<p>The implementation simply involves setting up a reference link in the wire feature 
to a list of points. This is realized by valuating the Wire attribute &quot;<strong>Points</strong>&quot;, 
of type &quot;<strong>list of spec objects</strong>&quot;. The UC &quot;<strong>Making 
Reference Links</strong>&quot; [<a href="#References">8</a>] details the steps involved 
in setting up a referencing link from a feature.</p>
<p>On similar lines, we can also retrieve the list of Point features referenced 
by the Wire feature. The <code>GetPoints</code>() routine of the <em>CAAIPstINFWire</em> 
Interface implemented by the Wire feature, follows:</p>
<pre class="code">
HRESULT <strong>CAAEPstINFWire::GetPoints(CATListPtrCATBaseUnknown &amp; oListOfPoints)</strong> 
{
         ...
	CATFmCredentials * MyCredential = NULL ;
	rc = <strong>::CAAPstINFRetrieveCredentialsModeler(MyCredential)</strong>;
	if ( FAILED(rc) ) return rc ;

	// Retrieve a CATFmFeatureFacade type on Wire (this)
	<strong>CATFmFeatureFacade FeatFacadeOnWire(*MyCredential,this)</strong>;

	// Retrieve the "Points" attribute key 
	<strong>CATFmAttributeName WirePointsAttrkey("Points")</strong>;
	CATFmAttributeValue WirePointsAttrValue;
	rc = <strong>FeatFacadeOnWire.GetValue</strong>(WirePointsAttrkey,WirePointsAttrValue)<strong>;
	
	</strong>int i = 1;
	while ( i&lt;=WirePointsAttrValue.Size() )
	{
             CATFmAttributeValue CurrentValue = WirePointsAttrValue[i] ;
	    <strong>CATBaseUnknown_var spCBUOnCurrentPoint = CurrentValue.GetFeature()</strong>;
	    if (NULL_var != spCBUOnCurrentPoint)
	    {
	           CATBaseUnknown* piCBUOnPoint = NULL;
		  <strong>spCBUOnCurrentPoint-&gt;QueryInterface</strong>(IID_CATBaseUnknown,(void**)&amp;piCBUOnPoint);
		  if ( piCBUOnPoint!= NULL ) <strong>oListOfPoints.Append</strong>(piCBUOnPoint);
	    }
		i++ ;
	}

	return rc;
}</pre>
<p>The Point features referenced by the Wire feature is retrieved as a <em>CATListPtrCATBaseUnknown</em> 
type (<strong>oListOfPoints</strong>).</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="Step4"></a>CAAIPstINFSubElement</h3>
<pre class="code">HRESULT CAAEPstINFSubElement::GetParent (CAAIPstINFRoot *&amp; oTheParent)
{

    HRESULT rc = E_FAIL;
    oTheParent = NULL ;
	 
    CATFmCredentials * MyCredential = NULL ;
    rc = ::<b>CAAPstINFRetrieveCredentialsModeler</b>(MyCredential);
    ...
    CATFmFeatureFacade FmFeatFacadeOnSubElement(*MyCredential,this);
	
    CATFmAttributeValue TheParentAsAttribute ;
    rc = FmFeatFacadeOnSubElement.<b>GetParentFeature</b>(TheParentAsAttribute);
    if ( SUCCEEDED(rc) )   
    {
	rc = TheParentAsAttribute.QueryInterfaceOnFeature(IID_CAAIPstINFRoot,(void **) &amp;oTheParent);
    }
   
    return rc;
}</pre>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>The CAAPstINFIntrinsicFeatBehavior use case illustrates:</p>
<ul>
	<li>Factory Implementation on an Applicative Container responsible for instantiating 
		and retrieving features inside it.</li>
	<li>Implementing dedicated Interfaces on a Feature to realize setting and retrieving 
		its attribute values.</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>[1]</td>
		<td><a href="CAAPstUcINFBuildCatalog.htm">ntegrating Applicative Data In 
		Product Context</a></td>
	</tr>
	<tr>
		<td>[2]</td>
		<td><a href="CAAPstUcINFCreateDocument.htm">Creating Data in PLM Technological 
		Representation</a></td>
	</tr>
	<tr>
		<td>[3]</td>
		<td>
		<a href="../CAADocUseCases/CAADocRunSample.htm">
		Building and Launching a CAA Use Case</a></td>
	</tr>
	<tr>
		<td>[4]</td>
		<td>
		<a href="../CAAFmFeatModExt/CAAFmExtUcInstantiation.htm">
		Creating Features</a></td>
	</tr>
	<tr>
		<td>[5]</td>
		<td><a href="CAAPstUcINFBuildCatalog.htm">Defining StartUp Catalog</a></td>
	</tr>
	<tr>
		<td>[6]</td>
		<td>
		<a href="../CAAFmFeatModExt/CAAFmExtUcAggregatedAttr.htm">
		Setting up Aggregation Links</a></td>
	</tr>
	<tr>
		<td>[7]</td>
		<td>
		<a href="../CAAFmFeatModExt/CAAFmExtUcSimpleAttr.htm">
		Accessing Feature Attributes</a></td>
	</tr>
	<tr>
		<td>[8]</td>
		<td>
		<a href="../CAAFmFeatModExt/CAAFmExtUcReferencedAttr.htm">
		Making Reference Links</a></td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="History"></a>History</h2>
<table class="history">
	<tr>
		<td>Version: <strong>1</strong> [Jan 2011]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
