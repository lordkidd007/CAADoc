<html>
	<head>
		<title>Retrieving Source and Targets of Logical-Functional Implement Relation</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<meta content="Microsoft FrontPage 12.0" name="GENERATOR">
		<meta content="FrontPage.Editor.Document" name="ProgId">
		<link href="../CAADocStyleSheets/caav5.css" type="text/css" rel="Stylesheet">
         <script language="JavaScript" src="../CAADocJavaScript/submit.js">
		</script>

        

          

        

                </head>
		
	<body  >
<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1>Retrieving Source and Targets of Logical-Functional Implement Relation</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>


				<!---------------------------------comment------------------------------------->
		<table class="abstract">
			<tr>
				<td>
					<h2>Abstract</h2>
					<p>This Use case mainly illustrates the retrieval of Source 
					object from Target object&nbsp; and Target object from 
					source object. In addition this use case illustrates of the 
					loading of an Implement relation in the session.</p>
				<ul>
							<li><A href="#Learn">What You Will Learn 
                                With This Use Case</A>
							<li><a href="#UseCase">The 
                                CAALilRetrieveImplLink Use Case</a>
							<ul type="disc">
								<li><a href="#What">What Does 
                                        CAALilRetrieveImplLink Do</a>
								<li><a href="#How">How to Launch 
								CAALilRetrieveImplLink </a>
								<li><a href="#Where">Where to Find the 
								CAALilRetrieveImplLink Code</a> </li>
							</ul>
							<li><A href="#Step">Step-by-Step</A>
							<li><A href="#InShort">In Short</A>
							<li><A href="#References">References</A> </li>
						</ul>
				</td>
			</tr>
		</table>
		<!---------------------------------comment------------------------------------->
		<h2><a name="Learn"></a>What You Will Learn With This Use Case</h2>
<p>Most importantly, user learns to load an Implement relation between 
Logical Root Reference and Functional Root Reference.&nbsp; Then we learn about retrieving 
count of Targets from 
source and Source from Target. </p>
<p>In addition, in this process we will learn the must conditions for 
loading the Implement relation link&nbsp;in the session, which will tech us that 
an 
Implement relation is PLM Connection type PLM Component &nbsp; </p>
<ul>
	<li>&nbsp;Implement relation gets loaded in Authoring Loading mode along with 
	aggregating Logical Reference</li>
	<li>The source and target must be in current sessions</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script> 
		<!---------------------------------comment------------------------------------->
		<h2><a name="UseCase"></a>The CAALilRetrieveImplLink
        Use Case</h2>
		<p><code><a>CAALilRetrieveImplLink</a></code> is a use case of the 
        <code><a>CAAPhysImplLinkUseItf.edu</a></code> framework that 
			illustrates <code>CATLogicalImplementLinkUseItf</code> framework capabilities.</p>
		<script type="text/javascript">insertLinkToTop();</script> 
		<!---------------------------------comment------------------------------------->
		<h3><a name="What"></a>What Does CAALilRetrieveImplLink
        Do</h3>
		<p>The Use case basically talks about loading an Implement relation link 
		between Logical Reference and Functional Reference.</p>
<p>This use case is demonstrating only Reference to Reference Implement link. The 
input data to this use case contains Implement link between Logical Reference and 
Functional Reference.&nbsp;&nbsp;This use case is data specific.</p>
<p>To demonstrate the loading condition of an Implement relation in session we 
do some trial cases </p>
<ul>
	<li>Initially we load Logical Reference and Functional Reference in session in ShortNavigation mode. This will load the both References Component in session 
(Source as well as target elements of Implement relation link). </li>
	<li>
<p>Next we create Object in context for Source (Logical Root) and Target 
(Functional Root). Then we try to retrieve the list of Target elements associated 
with the Source element and vice versa but the list result shows empty list 
since an Implement relation is not loaded in the session.</p>
	</li>
	</ul>
	<p>Actually for loading an Implement relation link object in current session 
	(which is 
aggregated under the Logical Root), we switch the loading mode of <strong>Logical 
Reference</strong> to <strong>Authoring</strong> mode. </p>
<p>Now we again try to retrieve the list of Target elements associated with the 
Source element and vice versa. This time result shows count is atleast One (1) it means 
Implement relation object loaded in session successfully. The count could be 
more than one (1) since one source could have multiple targets and vice versa. </p>
	<script type="text/javascript">insertLinkToTop();</script> 
		<h3><a name="How"></a>How to Launch CAALilRetrieveImplLink</h3>
		<p>To launch <code>CAALilRetrieveImplLink</code>, you will need to set up the build time environment, 
			then compile <code>CAALilRetrieveImplLink<b> </b></code>along with its prerequisites, set up the run time 
			environment, and then execute the use case [<a href="#References">1</a>].&nbsp;</p>
<p>To
launch the use case execute the command:</p>
<p><code> <a>mkrun -c &quot;</a>CAALilRetrieveImplLink </code><a><code><i>Repository Server User Password SecurityCtx 
LogicalPLMType FunctionalPLMType&nbsp;</i></code></a></p>
<p><code><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -LogRef </i>
</code><a><code><i>Attribute_name1 
Attribute_value1  [Attribute_name1 Attribute_value1 ...]</i></code></a></p>
<p><code><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -FunRef Attribute_name2 Attribute_value2 [Attribute_name2 Attribute_value2 ...] </i>
</code><a><code>&quot;</code></a> </p>
<p>where:</p>

<table class="border1"  id="table13" >
  <tr>
    <th><b>Repository</b></th>
    <td><script type="text/javascript">insertRepository();</script></td>
  </tr>
  <tr>
    <th><b>Server</b></th>
    <td>The server as Host:Port_number/RootURI</td>
  </tr>
  <tr>
    <th ><b>User</b></th>
    <td>The user name</td>
  </tr>
  <tr>
    <th ><b>Password</b></th>
    <td >The user password to authenticate the user</td>
  </tr>
  <tr>
    <th><b>SecurityCtx</b></th>
    <td>A string representing the security context (Role.Organization.Project) Choose Role as Reviewer ( as the use case does not modify the PLM Data)</td>
  </tr>
  
	<tr>
			<th> LogicalPLMType</th>
			<td>Logical PLMType name </td>
		</tr>
		<tr>
			<th > FunctionalPLMType</th>
			<td >Functional PLMType name</td>
		</tr>

	<tr>
    <th ><b>Attribute_name1</b></th>
    <td>The identification attribute name for Logical reference  </td>
  </tr>
  <tr>
    <th ><b>Attribute_value1</b></th>
    <td>The identification attribute value for Logical reference</td>
  </tr>
  <tr>
    <th ><b>Attribute_name2</b></th>
    <td>The identification attribute name for Functional reference </td>
  </tr>
	<tr>
    <th ><b>Attribute_value2 </b></th>
    <td>The identification attribute value for Functional Reference</td>
  </tr>
  </table>

<p>The input model for this use case is retrieved by importing the <code>CAALilRetrieveImplLink</code><a><code>.3dxml</code></a> file which 
located at:</p>
<table id="table15" >
    <tr>
      <td ><code>InstallRootDirectory\CAADoc\LogImplLinkUseItf.edu\InputData</code></td>
    </tr>
</table>
	<p >&nbsp;CAALilRetrieveImplLink.3dxml this 3D XML file contains the root 
	Logical Reference and Functional Root Reference with the
following attributes:</p>
<ul>
  <li><a><code>PLM_ExternalID</code></a>:
    CAALilRetrieveImplLink_Log_Root</li>
  <li><a><code>Version</code></a>:
    ---</li>
</ul>
<ul>
  <li><a><code>PLM_ExternalID</code></a>:
CAALilRetrieveImplLink_Func_Root</li>
  <li><a><code>Version</code></a>:
    ---</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script> 
		<h3><a name="Where"></a>Where to Find the CAALilRetrieveImplLink
        Code</h3>
<p>The <code>CAALilRetrieveImplLink<b> </b></code>use case is defined at the 
location:</p>
<table >
  <tr>
    <td><code>InstallRootDirectory\CAADoc\CAALogImplLinkUseItf.edu\CAALilRetrieveImplLink.m\</code></td>
  </tr>
</table>
<p>where <code><a>InstallRootDirectory</a></code>  [<a href="#References">1</a>]
is the directory where the CAA CD-ROM
is installed.</p>
		<script type="text/javascript">insertLinkToTop();</script> 
		<h2><a name="Step"></a>Step-by-Step</h2>
		<ul >
			<li><a href="#Prolog">Prolog</a><li>
			<a href="#Load Prod Ref">Load the Logical Reference in session in short navigation mode 
			</a> </li>
			<li>
			<a href="#Load Logical Ref">Load the Functional Reference in session in short navigation mode 
			</a> </li>
			<li>
			<a href="#Create OIC">Create the two Object in context (one for the source, and one for the target)</a></li>
			<li>
			<a href="#Retrieve ImplLink">Retrieve the Implement  link manager</a></li>
			<li>
			<a href="#check count ImplLink">Check the Count of Number of source from target and Target from 
			source.</a></li>
			<li>
			<a href="#Load Prod Ref Authoring mode">Load the Logical Reference in Authoring Mode</a></li>
			<li>
			<a href="#Check the Count of Number of source from target and Target from source">Check the Count of Number of source from target and Target from 
			source.</a></li>
			<li><a href="#Epilog">Epilog</a></li>
	</ul>
    <script type="text/javascript">insertLinkToTop();</script> 
	<h3><a name="Prolog"></a>Prolog&nbsp;</h3>
<p>The <code>CAALilRetrieveImplLink</code> use case begins by creating a 
session and connecting to the Input Repository  with an 
appropriate role (Reviewer, in this case). The Use Case&nbsp; &quot;<b>Creating a Basic PLM Batch</b>&quot;
[<a href="#References">2</a>] deals with Opening and Closing a PLM Session.</p>
		<script type="text/javascript">insertLinkToTop();</script> 
		<h3 >
        <a name="Load Prod Ref"></a>Load the Logical Reference in the session in short Navigation mode</h3>
		<p>We begin with by retrieving the <code>Identificator</code> [<a href="#References">3</a>] 
		of input Logical Reference, prerequisite for this is retrieving usable type 
		of&nbsp;the input Logical Reference.</p>
<p>Further we load the Logical Reference in the session in shot navigation mode. </p>
		<table class="code" id="Table42">
			<tr>
				<td><pre>...
   const char * istrLogicalPLMTypeInput=iArgv[6];
   <strong>CATIAdpPLMIdentificator</strong>* opiIDCompOnLogRef = NULL;
   
   hr = CAARetrieveIDofUniquePLMObject(iListAttributeNameLogRef,iListAttributeValueLogRef,
				   istrLogicalPLMType,opiIDCompOnLogRef);

   ...
   <strong>CATIPLMComponent</strong>* piPLMCompOnLogRoot = NULL;
   <strong>CATOmbLifeCycleRootsBag</strong> Bag;
   <strong>CATAdpOpenParameters</strong> params(CATAdpExpandParameters::OneLevelNavigation);
   <strong>CATAdpOpener</strong> opener(Bag,params);
   
   hr= opener.<strong>CompleteAndOpen</strong>(opiIDCompOnLogRef,IID_CATIPLMComponent, (void**) &amp;piPLMCompOnLogRoot);
...</pre>
				</td>
			</tr>
		</table>
		<p>The call to <code>CAARetrieveIDofUniquePLMObject</code> retrieves an 
		Identificator pointer. The details we can see in the [<a href="#References">3</a>] UC. </p>
<p>Further we open the Logical Root Reference in session using call to&nbsp;<code>CompleteAndOpen</code> of <em>CATAdpOpener</em> in ShortNavigation mode (OneLevelNavigation) [<a href="#References">4</a>].&nbsp;</p>
<script type="text/javascript">insertLinkToTop();</script> 
	<h3>
<a name="Load Logical Ref"></a>Load the Functional Reference in session in short navigation mode</h3>
<p>
Now we load the Functional Reference in the session in Short-Navigation. We open the 
Functional reference 
for which we have retrieved identificator.&nbsp; </p>
<table class="code" id="table51">
			<tr>
				<td><pre>...   
   const char* istrFunctionalPLMTypeInput = iArgv[7];
  
   CATIAdpPLMIdentificator* opiIDCompOnFuncRef = NULL;
	
   hr = CAARetrieveIDofUniquePLMObject(iListAttributeNameFuncRef,iListAttributeValueFuncRef,
				  istrFunctionalPLMType,opiIDCompOnFuncRef);


<strong>CATIPLMComponent</strong> *piPLMCompOnFunctionalRoot = NULL;
hr= opener.<strong>CompleteAndOpen</strong>(opiIDCompOnFuncRef,IID_CATIPLMComponent, (void**) &amp;piPLMCompOnFunctionalRoot);
...</pre>
				</td>
			</tr>
		</table>
<p>
A call to <code> CompleteAndOpen</code> of <em>CATAdpOpener</em> loads the 
Functional reference in 
the session of given identificator.</p>
<p>
This call insert Logical Reference Components within the <code>BAG </code> while opening object, thus letting the execution have 
	selectively, a complete control over their lifecycle. Please refer to the 
	tech article [<a href="#References">5</a>] to understand the details of the 
	BAG concept.</p>
<script type="text/javascript">insertLinkToTop();</script> 
<h3>
<a name="Create OIC"></a>Create two Object in context (one for the source, and one for the target)</h3>




<p>The input Logical Reference and Functional Reference are all loaded in the 
current session. Now we will create Object in Context (OIC) for loaded Logical 
Reference as well Functional Reference.</p>
		<table class="code" id="Table38">
			<tr>
				<td><pre>...
    CATListPtrCATIPLMComponent ComponentList;

    CATOmbObjectInContext * piOmbObjCtxOnLogRoot = NULL;
    hr = CATOmbObjectInContext::<strong>CreateObjectInContext</strong>(ComponentList, NULL, piPLMCompOnLogRoot, piOmbObjCtxOnLogRoot);
    ...	
    CATOmbObjectInContext * piOmbObjCtxOnFunctionalRoot = NULL;
    hr = CATOmbObjectInContext::<strong>CreateObjectInContext</strong>(ComponentList, NULL, piPLMCompOnFunctionalRoot, piOmbObjCtxOnFunctionalRoot);
...</pre>
				</td>
			</tr>
		</table>
		<p>The <code>CreateObjectInContext</code> of <em>CATOmbObjectInContext</em>
		call in this case takes a empty list namely. <code>ComponentList </code> and 
		opened PLM Component pointer,&nbsp;as 
		an input. in this case we call this method twice one for Logical 
		Reference (<code>piPLMCompOnLogRoot</code>) and for Functional Reference (<code>piPLMCompOnFunctionalRoot</code>) 
		this API returns the Object in context (<code>piOmbObjCtxOnLogRoot</code>, and <code>piOmbObjCtxOnFunctionalRoot</code>
		). </p>
<p>Please note that in this case we are giving empty list as first argument 
and second argument as NULL since we are creating object in context for Root 
object. </p>
		<script type="text/javascript">insertLinkToTop();</script> 
<h3 ><a name="Retrieve ImplLink"></a>Retrieve the Implement link manager</h3>
	<p>Now here we proceed to retrieve Implement link manager. This Implement 
	manager will provide services to manage the Implement link.&nbsp; </p>
		<table class="code" id="Table37">
			<tr>
				<td><pre>...
    <strong>CATILogicalImplementLinkManager</strong>* piImplementLinkManager = NULL;
    hr = CATLogicalImplementLinkProvider::<strong>GetImplementLinkManager</strong>(piImplementLinkManager);
...</pre>
				</td>
			</tr>
		</table>
		<p align="left">A call to <code>CreateImplementRelation</code> of <em>CATIPhysicalImplementLinkManager</em> on 
<code>piImplementLinkManager</code> creates a Implement link between two input 
objects.</p>
	<script type="text/javascript">insertLinkToTop();</script> 
		<h3 >
		<a name="check count ImplLink"></a>Check Count of source from target and Target from 
		source</h3>
	<p>Now we retrieve count of targets associated with source 
	object in contact (OIC) (Logical reference). Then further we retrieve count of 
	Source from Target object in context (Functional reference). </p>
<p>Please note that here expected count is zero. Implement link object is 
aggregated under the Logical Reference(Source) and it is a Connection type PLM 
Component. Since source is loaded in short-Navigation mode so Implement link 
will not load in the session since Implement link is of Connection type PLM 
object which is get loaded in Authoring mode only. </p>
		<table class="code" id="Table44">
			<tr>
				<td><pre>...
    hr = <strong>RetrieveCountOfTargets</strong>(piImplementLinkManager,piOmbObjCtxOnLogRoot,iTargetCount);
    ...
    hr = <strong>RetrieveCountOfSource</strong>(piImplementLinkManager,piOmbObjCtxOnFunctionalRoot,iSourceCount);
...</pre>
				</td>
			</tr>
		</table>
		<p>A call to <code>RetrieveCountOfTargets </code>global method of this use case 
		returns a count of Targets associated with input Source 
		(<code>piOmbObjCtxOnLogRoot</code>) Component [<a href="#RetrieveCountOfTargets">#</a>]. </p>
		<p>A call to <code>RetrieveCountOfSource</code> global method of this use case 
		returns a count of Source associated with input Target 
		(<code>piOmbObjCtxOnFunctionalRoot</code>) Component [<a href="#RetrieveCountOfSource">#</a>]. </p>
<p>These two methods are explained below. </p>
<script type="text/javascript">insertLinkToTop();</script> 
	<h3 >
		<a name="Load Prod Ref Authoring mode"></a>Load the Logical Reference in Authoring Mode</h3>
		<p>Now we will switch the mode of the opened Logical Reference to 
		Authoring mode which was we opened in Short-Navigation mode in previous 
		step. Due to switching of the mode of Logical reference to Authoring 
		mode the PLM Connection elements aggregated under the Logical Reference. </p>
				<table class="code" id="Table37">
			<tr>
				<td><pre>...
    <strong>CATAdpOpener</strong> opener2(Bag);
    hr= opener2.<strong>CompleteAndOpen</strong>(opiIDCompOnLogRef,IID_CATIPLMComponent, (void**) &piPLMCompOnLogRoot);
...</pre>
				</td>
			</tr>
		</table>
<p>A call to <code>CompleteAndOpen</code> of <em>CATAdpOpener</em> reopens the same object in 
Authoring mode [<a href="#References">4</a>].</p>

<script type="text/javascript">insertLinkToTop();</script> 
<h3 >
		<a name="Check the Count of Number of source from target and Target from source">
		</a>Check the Count of Number of source from target and Target from source</h3>

<p>Now we will again retrieve count of source as well target as we have 
retrieved in earlier steps, but here we expect count at least 1. Since we have loaded one 
target and one source in the session and Logical Reference (source) is opened in 
Authoring session .</p>
				<table class="code" id="Table37">
			<tr>
				<td><pre>...
    hr = RetrieveCountOfTargets(piImplementLinkManager,piOmbObjCtxOnLogRoot,iTargetCount);
	
    if ((FAILED(hr))||(1&lt;iTargetCount))
       return hr;

    hr = RetrieveCountOfSource(piImplementLinkManager,piOmbObjCtxOnFunctionalRoot,iSourceCount);

   if ((FAILED(hr))||(1&lt;iSourceCount))
       return hr;
...</pre>
				</td>
			</tr>
		</table>
<p>A call to <code>RetrieveCountOfTargets </code>returns a Count of Target [<a href="#RetrieveCountOfTargets">#</a>]. </p>
<p>A call to <code>RetrieveCountOfSource </code>returns a count of Source [<a href="#RetrieveCountOfSource">#</a>].</p>
<p>Please note that here we are using same object in context&nbsp;(OIC) object since we 
are using same pointer to switch (reopening ) the mode of the Logical reference.</p>
<script type="text/javascript">insertLinkToTop();</script> 
	<h3><a name="Epilog"></a>Epilog</h3>
<p align="left">The <code>CAALilRetrieveImplLink</code> use case ends by simply closing the PLM session. Since all use cases necessarily conclude by closing the PLM session, we have a dedicated article on this topic namely &quot;Creating a
Basic PLM Batch&quot; [<a href="#References">2</a>].&nbsp;</p>
		<script type="text/javascript">insertLinkToTop();</script> 
		
		<h3><a name="Epilog"></a><a name="RetrieveCountOfTargets"></a>RetrieveCountOfTargets</h3>
<p align="left">The <code>RetrieveCountOfTargets</code> method initially 
retrieves the list of Target objects in context loaded in session associated 
with input Source Component. Further from that list method retrieves count of 
element in the list. </p>
				<table class="code" id="Table37">
			<tr>
				<td ><pre>
HRESULT RetrieveCountOfTargets(CATILogicalImplementLinkManager* piImplementLinkManager, CATOmbObjectInContext * piOmbObjCtxOnLogRoot, int &amp;NbTargets )
{
   ...
   CATLISTP(CATOmbObjectInContext) ListOfTargetsBeforeNewImpliLinkCreation;
   CATLISTP(CATILogicalImplementLink) ListOfImplementLinks ;
   rc = piImplementLinkManager-&gt;<strong>GetImplementRelationTargets</strong>(piOmbObjCtxOnLogRoot,
                                                                           ListOfTargetsBeforeNewImpliLinkCreation,ListOfImplementLinks );
   ...
   NbTargets = ListOfTargetsBeforeNewImpliLinkCreation.Size();
   ...
}</pre>
				</td>
			</tr>
		</table>

<p>A call to <code>GetImplementRelationTargets</code> of <em>CATILogicalImplementLinkManager</em> 
retrieves the List of Object in context of Targets (<code>ListOfTargetsBeforeNewImpliLinkCreation</code>)&nbsp; 
associated with the input Source Object in context (<code>piOmbObjCtxOnLogRoot</code>) 
and the list of implement link relation objects.</p>		<script type="text/javascript">insertLinkToTop();</script> 
		
			<h3><a name="Epilog"></a><a name="RetrieveCountOfSource"></a>RetrieveCountOfSource</h3>
<p align="left">The <code>RetrieveCountOfSource</code> method initially 
retrieves the list of Source objects in context loaded in session associated 
with input Target component. Further from that list method retrieves count of 
element in the list. </p>

				<table class="code" id="Table37">
			<tr>
				<td ><pre>HRESULT RetrieveCountOfSource(CATILogicalImplementLinkManager* piImplementLinkManager, CATOmbObjectInContext * piOmbObjCtxOnFunctionalRoot, int &amp;NbSources )
{
   ...
   CATLISTP(CATOmbObjectInContext) ListOfSourcesBeforeNewImpliLinkCreation;
   CATLISTP(CATILogicalImplementLink) ListOfImplementLinks ;
   rc = piImplementLinkManager-&gt;<strong>GetImplementRelationSources</strong>(piOmbObjCtxOnFunctionalRoot,
                                                            ListOfSourcesBeforeNewImpliLinkCreation, ListOfImplementLinks );
   ...	
   NbSources = ListOfSourcesBeforeNewImpliLinkCreation.Size();
   ...
}</pre>
				</td>
			</tr>
		</table>

<p>A call to <code>GetImplementRelationSources</code> of <em>CATILogicalImplementLinkManager</em>
retrieves the List of object in context of Sources 
(<code>ListOfSourcesBeforeNewImpliLinkCreation</code>)&nbsp; associated with the input 
Source Object in context (<code>piOmbObjCtxOnLogRoot</code>) and the list of 
implement link relation objects.</p>
		<script type="text/javascript">insertLinkToTop();</script> 


		<!---------------------------------comment------------------------------------->
		<h2><a name="InShort"></a>In Short</h2>
<p align="left">The Use Case illustrates the loading of Implement link and 
demonstrates its prerequisite conditions. Basic conditions are</p>
<ul>
	<li>
	<p align="left">Source and targets must be in session</p>
	</li>
	<li>
	<p align="left">The Logical Reference (aggregating implement link Component) 
	must be loaded in Authoring mode to load the Implement relation in session.
	</p>
	</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script> 
		<!---------------------------------comment------------------------------------->
		<h2><a name="References"></a>References</h2>
		<table>
			
			<tr>
				<td vAlign="top" >[1]</td>
				<td ><a href="../CAADocUseCases/CAADocRunSample.htm">Building 
						and Launching a CAA Use Case</A></td>
			</tr>
			<tr>
				<td vAlign="top" >[2]</td>
				<td >
                <a href="../CAAPlmServerAccess/CAAAdpUcBasicBatch.htm">
                Creating a PLM Basic Batch</a></td>
			</tr>
			<tr>
			<td vAlign="top" >[3]</td>
				<td >
				<a href="../CAAPlmServerAccess/CAAPlmTaCATIAdpPLMIdentificator.htm">PLM Component Identifier</a></td>
			</tr>
			<tr>
				<td vAlign="top" >[4]</td>
				<td ><a href="../CAAPlmServerAccess/CAAAdpUcQueryOpen.htm">Querying, Expanding and Opening PLM Components</a></td>
			</tr>
			<tr>
				<td vAlign="top" >[5]</td>
				<td >
				<a href="../CAAOmbPLMCompMngt/CAAAdpTaBAGMechanism.htm">
				Understanding PLM Component Life Cycle</a></td>
			</tr>
			</table>
		
		<!---------------------------------comment------------------------------------->
		<h2><a name="History"></a>History</h2>
		<table >
			<tr>
				<td vAlign="top">Version: <strong>1</strong> [Jan 2010]</td>
				<td vAlign="top">Document created</td>
			</tr>
			</table>
		<script type="text/javascript">insertLinkToTop();</script>
		<!---------------------------------comment------------------------------------->
		  <script type="text/javascript">insertCopyright();</script>
	</body>
</html>


