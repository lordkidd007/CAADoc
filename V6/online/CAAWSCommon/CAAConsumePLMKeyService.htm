<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type" />
<link href="../CAADocStyleSheets/caav5.css" rel="stylesheet" type="text/css"/>
<script src="../CAADocJavaScript/DSDocTocToc.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/DSDocHighlight.js" type="text/javascript">/* */</script>
<script src="../CAADocJavaScript/submit.js" type="text/javascript">/* */</script>
<title>Generating PLM Keys</title>
</head>

<body onload="highlightSearchTerms();">

<table class="DocHeader">
	<tr>
		<td class="DocHeader1">
		<h1><a name="Top"></a>Generating PLM Keys</h1>
		</td>
	</tr>
	<tr>
		<td class="use">Use Case</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table class="abstract">
	<tr>
		<td>
		<h2>Abstract</h2>
		<p>This article explains how to be able to get plm keys by calling a web 
		service that generates and revokes keys. Those plm keys are intended to 
		be used as first input parameter of Dassault Syst&#232;mes web services.</p>
		<ul>
			<li><a href="#1">What You Will Learn With This Use Case</a></li>
			<li><a href="#2">Preliminary Steps</a></li>
			<li><a href="#3">Step-by-Step</a></li>
			<li><a href="#InShort">In Short</a></li>
			<li><a href="#References">References</a></li>
		</ul>
		</td>
	</tr>
</table>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="1"></a>What You Will Learn With This Use Case</h2>
<p>In this use case, you will learn how to generate &quot;plm keys&quot; by calling 
the <strong>PLMKeyService</strong> web service, given input data values called &quot;credentials&quot;.</p>
<p>Such keys will be needed for accessing the other Web Services delivered by Dassault 
Syst&#232;mes, as &quot;plm keys&quot; will always be their first input parameter.</p>
<p>The <strong>PLMKeyService</strong> web service, is the endpoint (i.e. the delivered 
implementation) of the <em>IPLMKeyManagement</em> portType and offers three &quot;web 
methods&quot;:</p>
<table class="fill">
	<tr>
		<th>Method</th>
		<th>Parameters</th>
		<th>Description</th>
	</tr>
	<tr>
		<td><strong>generatePLMKeyFromSimpleContext</strong> </td>
		<td>(adminKey, name, password, contextURI, validityURI)</td>
		<td>A simple way to create keys when the credentials have a simple type: 
		the authentication is based on user/password pair, the applicative and validity 
		credentials are a list of simple types.</td>
	</tr>
	<tr>
		<td><strong>generatePLMKeyFromStructuredContext</strong> </td>
		<td>(adminKey,credentialset)</td>
		<td>A more structured way to create the input credentials. To be used when 
		the credentials have specific patterns, or when the authentication is not 
		simply a user/password pair.</td>
	</tr>
	<tr>
		<td><strong>revokePLMKeys</strong></td>
		<td>(adminKey,PLMKeys)</td>
		<td>Revokes a list of keys that have been created by the web service earlier. 
		The revoked key values will no more use-able in any web service relying 
		on plm keys.</td>
	</tr>
</table>
<p><strong>INFORMATION</strong>: the first argument of each method, <strong>adminKey</strong>, 
is a key value generated by administrators. Its goal is to restrict the access to 
authorized people only. This means that you ought to get an admin key before using 
the PLMKeyService (see <a href="#21">Admin Keys</a>)</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="2"></a>Preliminary Steps</h2>
<ul>
	<li>Ensure that the <strong>PLMKeyService</strong> has been deployed on an application 
		server (WebSphere 6.1 enhanced with the Feature Pack for web services, Tomcat 
		6.0, etc.).
		<p><strong>Example</strong>: if the web service has been deployed on WebSphere, 
		you should ask for the following url, in an internet browser:</p>
		<p>http://&lt;serverhost&gt;:&lt;serverport&gt;/&lt;rootURI/PLMKeyService</p>
		<p>And you should see the following result:</p>
		<p>
		<img alt="PLM Key Service Check Deployment" src="images/PLMKeyServiceCheckDeploy.gif"/></p>
		<p>(If the enovia application has been deployed on Tomcat, you can access 
		the list of web services through the URL</p>
		<p>http://&lt;serverhost&gt;:&lt;serverport&gt;/&lt;rootURI&gt;/webservice.)</p>
	</li>
	<li><a name="21"></a><strong>AdminKeys</strong>: You must have an adminKey value 
		at least, to be able to consume the <strong>PLMKeyService</strong> web service. 
		Admin keys can be generated from the createAdminKeys.bat (on WINDOWS) or 
		createAdminKeys.sh (on UNIX ) utilities delivered with Enovia application. 
		This utility can be simply used as follows:
		<p><strong>createAdminKeys.bat -u &lt;user&gt; -p &lt;password&gt; -r &lt;URI&gt;</strong> 
		... on WINDOWS operating system<br />
		<strong>createAdminKeys.sh -u &lt;user&gt; -p &lt;password&gt; -r &lt;URI&gt;</strong> 
		... on UNIX operating systems.</p>
		<p>This will return an admin key value which you will be able to use as 
		the first argument of the web methods. <br />
		<strong>Note</strong>: The chosen user must belong to the &quot;Service 
		Administrators&quot;, which is a dedicated role in ENOVIA server, else the 
		creation of the admin key will fail, as the user will not have the genuine 
		rights to perform this operation. Usually, the admin user owns those rights.</p>
	</li>
	<li><a name="22"></a><strong>Credential sets</strong>: On the client side, 
		one must know the credential sets definitions that are available, in order 
		to build the right input parameter structures which are expected by the 
		web service:
		<ul>
			<li>A credential set has an identifier, defined by Dassault Syst&#232;mes.</li>
			<li>A credential set is composed of three domains of credentials:
				<ol>
					<li><strong>Authentication</strong>: credentials used for authenticating 
						the client.</li>
					<li><strong>Applicative</strong>: contains the credentials specific 
						to an application or a group of applications.</li>
					<li><strong>Validity</strong>: contains credentials which define 
						the validity duration of the key.</li>
				</ol>
			</li>
			<li>Credentials are defined by a name, a type and a value. The credential 
				type is always a simple type ( as defined by the W3C consortium).</li>
			<li>For current use case purpose only, we provide a specific credential 
				set, defined as follows:
				<table class="fill">
					<tr>
						<th>ID</th>
						<th>CAATST</th>
					</tr>
					<tr>
						<th>VERSION</th>
						<th>1</th>
					</tr>
					<tr>
						<th>DOMAINS</th>
						<th colspan="2">CREDENTIALS</th>
					</tr>
					<tr>
						<td rowspan="2">authentication</td>
						<td>&quot;user&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>&quot;password&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td rowspan="2">applicative</td>
						<td>&quot;company&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>&quot;product&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>validity</td>
						<td>&quot;validityMinutes&quot;</td>
						<td>(int)</td>
					</tr>
				</table>
				<p><strong>NOTA BENE</strong>: This credential set can be used for 
				tests only, and plmkeys relying on this definition can't be used 
				for real scenarios. </p>
			</li>
			<li>The official Credential Set which <strong>MUST</strong> be used 
				in a real context, i.e. when creating plmkeys that will be parameters 
				of other Dassault Syst&#232;mes web services, has the following 
				definition:
				<table class="fill">
					<tr>
						<th>ID</th>
						<th>V6LOGIN</th>
					</tr>
					<tr>
						<th>VERSION </th>
						<th>V6R2009-x</th>
					</tr>
					<tr>
						<th>DOMAINS</th>
						<th colspan="2">CREDENTIALS</th>
					</tr>
					<tr>
						<td rowspan="2">authentication</td>
						<td>&quot;user&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>&quot;password&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>&nbsp;</td>
						<td>&quot;SecurityContext&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>applicative</td>
						<td>&quot;Machine&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>&nbsp;</td>
						<td>&quot;port&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>&nbsp;</td>
						<td>&quot;URLPath&quot;</td>
						<td>(string)</td>
					</tr>
					<tr>
						<td>validity</td>
						<td>&quot;validityHours&quot;</td>
						<td>(int)</td>
					</tr>
				</table>
				<p><strong>IMPORTANT</strong>: if you want to generate such &quot;official&quot; 
				plmkeys, use-able as parameters of the Dassault Syst&#232;mes web services, 
				a dedicated utility is provided for that: <strong>createPLMKeys.bat 
				/.sh</strong> (launch the utility with the -h option to get the 
				help). For this utility, the credential set which is used is the 
				V6LOGIN one, and the parameters of the executable fit with the credentials 
				described above.</p>
			</li>
			<li>The current use case is able to test the <strong>PLMKeyService</strong> 
				web service, either it has been deployed on <strong>WAS6.1 + FeaturePack 
				for web services</strong>, either on <strong>Tomcat 6.0</strong> 
				or<strong> IIS</strong> and that the client to be used is a
				<strong>WCF</strong> one. one of the &quot;main&quot; input parameters 
				will be the type of server.</li>
		</ul>
	</li>
</ul>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="3"></a>Step-by-Step</h2>
<p>The following section first describes how to set up your project, then how to 
import the use case code samples, and finally how to build the project. It then 
explains how to launch the related use case scenario. Note again that we just show 
a simple way to.</p>
<ol>
	<li><a href="#30">Prerequisites</a></li>
	<li><a href="#31">Provided Materials</a></li>
	<li><a href="#32">Setting Up a New Visual Studio Project</a></li>
	<li><a href="#33">Writing the Client Code </a></li>
	<li><a href="#34">Building the Use Case Code Samples</a></li>
	<li><a href="#35">Launching the Use Case Scenario</a></li>
</ol>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="30"></a>Prerequisites</h3>
<p>Before you start your web service client project, you MUST have generated the 
client proxy for the <strong>PLMKeyService</strong> web service or used <strong>
mkmk</strong> tool to compile the <strong>caawsplmkey.mj </strong>module which has 
been delivered, as indicated in [<a href="#References">1</a>].</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="31"></a>Provided Material</h3>
<p>In the <strong>caawsplmkey.mj</strong> module, under <strong>CAAWebServices.edu</strong> 
framework, you will find several files:</p>
<ol>
	<li>A sample of a web service client which consumes the <strong>PLMKeyService</strong> 
		web service: <strong>TestCAAPLMKeyWS.cs</strong>. We will rely on this class 
		for showing how to create your own client.</li>
	<li>An already generated proxy : <strong>PLMKeyService.cs</strong>, which shows 
		you the kind of c# classes the <strong>svcutil.exe</strong> tool generates 
		from a wsdl.</li>
	<li>A configuration file sample, generated by the svcutil.exe utility:
		<strong>caawsPLMKey.exe.config</strong>.</li>
</ol>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="32"></a>Setting Up a New Visual Studio Project</h3>
<p>Please refer to [1] to see how to set up the Visual Project. We only focus on 
the client code to be written.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="33"></a>Writing the Client Code</h3>
<p>In our sample, we will create keys associated to our <strong>CAATXT</strong> 
credential set, and we have to give the associated credentials values. So the
<strong>Main</strong> input arguments are:</p>
<ul>
	<li>The adminKey which allows you to use this web service (see <a href="#21">
		adminKeys</a> section).</li>
	<li>The root URI where the web service can be called; the format is &quot;http://&lt;host&gt;:&lt;port&gt;/&lt;application&gt;.</li>
	<li>The userName value for the &quot;user&quot; credential of the CAATXT credential 
		set.</li>
	<li>The password value for the &quot;password&quot; credential.</li>
	<li>The company name.</li>
	<li>The product name.</li>
	<li>The validity duration in minutes.</li>
</ul>
<pre class="code">caawsplmkey.exe -h | -k adminKey [-u service_url] [-n user] [-p password] [-c company] [-a product] [-m keyValidityInMn]</pre>
<p><strong>Example:</strong></p>
<pre class="code">caawsplmkey.exe -k 03E246273207149BD879837DB60E7567F -u http://kipp3dsy:9081/CAAPLMKey/PLMKeyService -n user_1 -p pwd_1 -c Dassault_Systemes -a CATIAV5 -m 3</pre>
<p>The steps for calling the web service deployed on the application server are:</p>
<ol>
	<li>Create the Main class, and write methods to test arguments:
		<pre class="code"><span class="keyword">static void</span> Main(<span class="keyword">ststring[]</span> args)
{
  TestCAAPLMKeyClient ws = <span class="keyword">new</span> TestCAAPLMKeyClient();
  <span class="keyword">if</span> (ws.ParseArgs(args)) {
    ws.PrintUsage();
    <span class="keyword">return</span>;
  }
  <span class="keyword">else</span> {
    ws.CallService();
  }
}</pre>
		<p>(we do not detail the <i>ParseArgs</i> and <i>PrintUsage</i> methods, 
		just look at the provided material).</p>
	</li>
	<li>In the <strong><i>CallService</i></strong> method of the test class, create 
		an instance of the proxy:
		<pre class="code">PLMKeyManagementClient genKeySvc = new PLMKeyManagementClient(&quot;IPLMKeyManagement&quot;, _url);</pre>
	</li>
	<li>For the first web method of the web service, build the context &quot;URI&quot; 
		and the validity &quot;URI&quot;; those URIs have the format:
		<pre class="code">&lt;credentialset_ID&gt;:&lt;credential1_value&gt;:&lt;credential2_value&gt;:...</pre>
		<p>Where credentialset_ID is the ID of the credential set we want to create 
		a key for.</p>
		<p>Then the credential values list, separated by <strong>':' </strong>must 
		be given in the exact order the credential have been defined in the definition 
		schema. For the context URI, the values are associated with the &quot;applicative&quot; 
		credentials, while the validity uri contains the values associated to the &quot;validity&quot; 
		credentials. In our use case, we MUST have a context URI like:</p>
		<p><code>&quot;CAATEST:companyName:productName&quot;</code> and a validity 
		URI like &quot;<code>CAATEST:durationInMinutes&quot;</code></p>
		<p>So the code of the client is:</p>
		<pre class="code"><span class="keyword">try</span> {
  Console.WriteLine(&quot;CLIENT&gt;&gt; call the first web method of the PLMKey service.&quot;);<br />     Console.WriteLine(&quot;CLIENT&gt;&gt; ======================================================.\n&quot;);<br />    <span class="keyword">string</span> contextURI = &quot;CAATEST:&quot; + _companyName + &quot;:&quot; + _productName;<br />    <span class="keyword">string</span> validityURI = &quot;CAATEST:&quot; + _validityInMn;<br />     ...</pre>
	</li>
	<li>Call the first web method which generates a PLM key from those parameters 
		values:
		<pre class="code"><strong>simpleGenKey = genKeySvc.generatePLMKeyFromSimpleContext(_adminKey,_userName, _pwdName, contextURI, validityURI);</strong><br />Console.WriteLine(&quot; CLIENT&gt;&gt; key generated from simple context =\&quot;{0}\&quot;\n\n&quot;, simpleGenKey);</pre>
	</li>
	<li>For the web method using a structured credential set object, writing the 
		code is straightforward, given that we have to fill the authentication credentials, 
		the applicative ones, and then the validity ones:
		<pre class="code">CredentialSet csInstance = <span class="keyword">new</span> CredentialSet();
csInstance.id = &quot;CAATEST&quot;;
<span class="comment">// a) the authentication credentials.</span>
credential userCred = <span class="keyword">new</span> credential();
userCred.name = &quot;user&quot;;
userCred.Value = _userName;
credential pwdCred = <span class="keyword">new</span> credential();
pwdCred.name = &quot;password&quot;;
pwdCred.Value = _pwdName;
pwdCred.ispassword = <span class="keyword">true</span>;
<span class="comment">// add the credentials to the credential set authentication part.</span>
csInstance.authentication = <span class="keyword">new</span> credential[2];
csInstance.authentication[0] = userCred;
csInstance.authentication[1] = pwdCred;
<span class="comment">//b) the applicative credentials</span>
credential companyCred = <span class="keyword">new</span> credential();
companyCred.name = &quot;company&quot;;
companyCred.Value = _companyName;
credential productCred = <span class="keyword">new</span> credential();
productCred.name = &quot;product&quot;;
productCred.Value = _productName;<br />csInstance.applicative = <span class="keyword">new</span> credential[2];
csInstance.applicative[0] = companyCred;
csInstance.applicative[1] = productCred;
<span class="comment">//c) the validity credentials</span>
credential validCred = <span class="keyword">new</span> credential();
validCred.name = &quot;validityMinutes&quot;;
validCred.Value = _validityInMn.ToString();
csInstance.validity = <span class="keyword">new</span> credential[1];
csInstance.validity[0] = validCred;</pre>
	</li>
	<li>Then, we call the web method which will generate a key from this data:
		<pre class="code"><strong>structGenKey = genKeySvc.generatePLMKeyFromStructuredContext(_adminKey,csInstance);</strong>
Console.WriteLine(&quot; CLIENT&gt;&gt; key generated from structured context =\&quot;{0}\&quot;\n\n&quot;, structGenKey);</pre>
	</li>
	<li>We finish the client code by revoking the keys we created ( sample code, 
		checks should be done on keys, to prevent from manipulating null values):
		<pre class="code"><span class="keyword">string</span> keysToRevoke = simpleGenKey;
keysToRevoke += &quot; &quot;;
keysToRevoke += structGenKey;
<span class="comment">// way in WCF to map to a list of strings ...</span>
<span class="keyword">try</span> {
  Console.WriteLine(&quot;CLIENT&gt;&gt; Test revocation web method of the PLMKey service. &quot;);
  Console.WriteLine(&quot;CLIENT&gt;&gt; ======================================================.\n&quot;);
  <strong>genKeySvc.revokePLMKeys(_adminKey, keysToRevoke);</strong>
  Console.WriteLine(&quot; CLIENT&gt;&gt; revocation of keys =\&quot;{0}\&quot; is done&quot;, keysToRevoke);
}
<span class="keyword">catch</span> (Exception e)
{...}</pre>
	</li>
	<li><strong>REMINDER</strong> : the credential set that was used in this code 
		sample (CAATest ) is available for tests only. If you want to create a plm 
		key for official web services consumption, you MUST fill the official credential 
		set (id=&quot;<strong>V6LOGIN</strong>&quot; - see <a href="#22">Credential 
		sets</a> section) </li>
</ol>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="34"></a>Building the Use Case Code Samples</h3>
<p>You have 2 ways to build this caa use cases :use the Visual Studio tools, if 
you chose to write your client class, or use mkmk tools if you chose to directly 
use the provided material. Please refer to [<a href="#References">1</a>] for more details.</p>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h3><a name="35"></a>Launching the Use Case Scenario</h3>
<p>Run the TestCAASecuredPing Executable:</p>
<ol>
	<li>Open a new command window.</li>
	<li>If you are using Visual Studio, go to the <strong>bin (or the bin/Debug)</strong> 
		directory, under the directory where your project is located, or in the 
		CAA Workspace intel_a\code\clr directory if you simply used the provided 
		material.
		<p>Example:</p>
		<pre class="code">cd C:\Documents and Settings\bbb.DS\My Documents\Visual Studio 2005\Projects\TestCAAPLMKeyClient\TestCAAPLMKeyClient\bin\Debug</pre>
	</li>
	<li>Check the configuration file has the right name:
		<p>Example (if the executable is caawsplmkey.exe):</p>
		<pre class="code">caawsplmkey.exe.config</pre>
	</li>
	<li>Then run the exe file with your input arguments (if needed):
		<pre class="code">caawsplmkey.exe -k &lt;keyval&gt; -u fooUser -p XXXXXXX -c DASSAULT SYSTEMES -a CATIA V5 -m 1</pre>
		<p>You should have traces like:</p>
		<p>
		<img alt="PLM Key Service Client Output" src="images/PLMKeyServiceClientOutput.png"/></p>
	</li>
</ol>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="InShort"></a>In Short</h2>
<p>This use case describes how to set up a build time and run time environment that 
enables to easily call a web service which generates plm keys, that will be used 
as input parameters for the other Dassault Syst&#232;mes web services. Retrieving 
the credentials associated to those keys help the web services implementations to 
rebuild contexts and checks the ability of the web service client to access the 
web services.</p>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<h2><a name="References"></a>References</h2>
<table class="reference">
	<tr>
		<td>1</td>
		<td>
		<a href="CAAWSBuildingLaunching.htm">Building 
		and Launching a Web Service Use Case</a></td>
	</tr>
</table>
<h2>History</h2>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<table>
	<tr>
		<td>Version: <strong>1</strong> [Dec 2006]</td>
		<td>Document created</td>
	</tr>
</table>
<script type="text/javascript">insertLinkToTop();</script>
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-comment-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<script type="text/javascript">insertCopyright();</script>

</body>

</html>
